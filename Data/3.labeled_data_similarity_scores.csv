#,id,library,aspect,search_word,aspect_question,so_id,so_question_title,so_question_body,so_answer,question_keyword,explanation,error reason,label,callid,sim_ques_ans_how,sim_ques_ans_why,sim_ques_ans_really,sim_ques_how_why,sim_ques_how_really,sim_ques_why_really,sim_ans_base_how,sim_ans_base_why,sim_ans_base_really,sim_ans_how_why,sim_ans_how_really,sim_ans_why_really,sim_ques_ans_how_qaqa,sim_ques_ans_why_qaqa,sim_ques_ans_really_qaqa,sim_ques_how_why_qaqa,sim_ques_how_really_qaqa,sim_ques_why_really_qaqa,sim_ans_base_how_qaqa,sim_ans_base_why_qaqa,sim_ans_base_really_qaqa,sim_ans_how_why_qaqa,sim_ans_how_really_qaqa,sim_ans_why_really_qaqa,id+kw
66,19,Spacy,Performance,performance,Performance aspect,58724562,When creating a Doc using the standard constructor the model is not loaded ,"I'm trying to use SpaCY and instantiate the Doc object using the constructor:
but when I do that, if I try to use the dependency parser:
I get the error:

ValueError: [E029] noun_chunks requires the dependency parse, which requires a statistical model to be installed and loaded. For more info, see the documentation:
While if I use the method nlp(""Hello world!"") that does not happens.

The reason I do that, is because I use the entity extraction from a third party application I want to supply to SpaCy my tokenisation and my entities.
What should I do? load the pipeline by myself in the document, and exclude the tokeniser for example?","nlp() returns a Doc where the tokenizer and all the pipeline components in nlp.pipeline have been applied to the document.

If you create a Doc by hand, the tokenizer and the pipeline components are not loaded or applied at any point.

After creating a Doc by hand, you can still apply individual pipeline components from a loaded model:

nlp = spacy.load('en_core_web_sm')
nlp.tagger(doc)
nlp.parser(doc)
Then you can add your own entities to the document. (Note that if your tokenizer is very different from the default tokenizer used when training a model, the performance may not be as good.)",pipeline components can be applied individually to a doc object,"After manually creating a Doc object in Spacy, it is possible to apply individual pipeline components from a loaded model like the tagger and parser to the document. One can also add their own entities to the document.",,1,C20230706014829643970,0.682736278,0.836072564,0.771582723,0.72217977,0.637101948,0.815715909,0.459931582,0.726807714,0.66207844,0.498640686,0.597026825,0.663625419,0.609651685,0.638723433,0.808665514,0.526782393,0.534008324,0.592414916,0.507633865,0.823283732,0.756577849,0.666278481,0.587589025,0.860006213,19pipeline components can be applied individually to a doc object
90,26,Spacy,Performance,fast,Performance aspect,59830899,sense2vec performance improvemets,"I am using Sense2Vec (builds upon Spacy, a fantastic NLP library/tool) and testing the similarity between various words. Unfortunately the performance is quite slow (execution is over a second on a regular MacBook Pro).

Does anyone have a way to speed this up?

Here is the code:

term = ""dog|NOUN""
sense2vec = Sense2Vec().from_disk(""path-to-s2v_reddit_2019_lg"")
sims = sense2vec.most_similar(term, n=top)
I suspect some caching would speed things, but I am not sure which elements should be cached.
","There is indeed a way to speed up Sense2Vec.most_similar. There is a script available from https://github.com/explosion/sense2vec/blob/master/scripts/06_precompute_cache.py, which precomputes a cache of the nearest neighbors. It will then save that cache with the component on disk, making the data larger but the queries fast. If a query is not covered by the cache, most_similar falls back to using the normal computation.",precomputing cache,Precomputing a cache of the nearest neighbors can speed up the Sense2Vec.most_similar function.,,1,C20230706014916811414,0.7472772,0.757479429,0.601181984,0.98162204,0.714921653,0.688316882,0.790005624,0.815399528,0.750787318,0.959612846,0.802137673,0.809239686,0.623154163,0.623533666,0.603674471,0.975961924,0.53260082,0.491180629,0.752886117,0.802730143,0.719191015,0.923487663,0.832474113,0.814683199,26precomputing cache
133,38,Spacy,Stability,bug,Stability aspect,64164360,How can I add a specific substring to tokenize on in spaCy?,"I am using spaCy to tokenize a string, and the string is likely to contain a specific substring. If the substring is present, I would like spaCy to treat the substring as a token, regardless of any other rules it has. I would like to keep all other rules intact. Is this possible?

To provide a concrete example, suppose the substring of interest is 'banana'; I want 'I like bananabread.' to be tokenized as ['I', 'like', 'banana', 'bread', '.'].

Where do I go from here (keeping in mind that I would like to keep the rest of the tokenizer rules intact)? I have tried adding 'banana' to the prefixes, suffixes, and infixes, with no success.","Adding the string as a prefix, suffix, and infix should work, but depending on which version of spacy you're using, you may have run into a caching bug while testing. This bug is fixed in v2.2+.

With spacy v2.3.2:

(In v2.1 or earlier, the tokenizer customization still works on a newly loaded nlp, but if you've already processed some texts with the nlp pipeline and then modify the settings, the bug was that it would use the stored tokenization from the cache rather than the new settings.)",clear solution provided,The answer provides a clear solution to the questioner's problem of adding a specific substring to the tokenizer rules.,,1,C20230706014940738928,0.743824422,0.388878375,0.320037365,0.321644008,0.333993286,0.603668928,0.773230195,0.700750351,0.470224857,0.461392522,0.28571105,0.674227476,0.613598406,0.431819856,0.467262566,0.479125142,0.305159181,0.468500376,0.706263065,0.777492702,0.631170094,0.795314789,0.683076501,0.80034703,38clear solution provided
128,37,Spacy,Stability,bug,Stability aspect,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.",community engagement,"User found a similar question on the topic, indicating a level of community support and engagement with the library.",,1,C20230706014939356483,0.694460511,0.767986894,0.716564476,0.913080156,0.855048358,0.847517192,0.805521071,0.733465552,0.750077963,0.797679722,0.91550529,0.776309252,0.530252576,0.625345767,0.754498541,0.978273928,0.964874029,0.952750325,0.747672915,0.757706106,0.372467101,0.795742393,0.241260543,0.372873604,37community engagement
267,78,Spacy,Feature,dependency parsing,dependency parsing feature,39258476,Collocations with spaCy,"I've been using NLTK for finding collocations, or n-grams, and have recently discovered the spaCy module for NLP. I've only just begun familiarizing myself with it and have, thus far, seen little mention for supported collocation functions.

Can spaCy be used to find collocations directly?

I have read through the documentation, but haven't seen mention.","Collocations detection also can be based on dependency parsing, but spaCy do not have support to do it. You can use spaCy as part of an approach, but not directly.

may you also consider gensim: https://radimrehurek.com/gensim/models/phrases.html

I hope it can help you",no direct support,Spacy does not have direct support for collocation detection based on dependency parsing.,,1,C20230706015058221783,0.514262021,0.446851254,0.600988626,0.865969598,0.560850143,0.596183002,0.637807608,0.277092963,0.760448337,0.478524208,0.668304503,0.235880226,0.651501119,0.444672853,0.545586824,0.533812702,0.493198663,0.543123126,0.761526525,0.740490913,0.748856068,0.90017128,0.878426969,0.862503409,78no direct support
242,72,Spacy,Feature,POS,POS tagging feature,42830248,how to write spacy matcher of POS regex,"Spacy has two features I'd like to combine - part-of-speech (POS) and rule-based matching.

How can I combine them in a neat way?

For example - let's say input is a single sentence and I'd like to verify it meets some POS ordering condition - for example the verb is after the noun (something like noun**verb regex). result should be true or false. Is that doable? or the matcher is specific like in the example

Rule-based matching can have POS rules?

If not - here is my current plan - gather everything in one string and apply regex","Sure, simply use the POS attribute.

import spacy
nlp = spacy.load('en')
from spacy.matcher import Matcher
from spacy.attrs import POS
matcher = Matcher(nlp.vocab)
matcher.add_pattern(""Adjective and noun"", [{POS: 'ADJ'}, {POS: 'NOUN'}])

doc = nlp(u'what are the main issues')
matches = matcher(doc)",ease of use,The POS attribute can be used seamlessly with Spacy matcher.,,1,C20230706015044036755,0.614449263,0.531622231,0.549978971,0.627398908,0.551412642,0.563290298,0.418373972,0.566913307,0.546577275,0.473021358,0.369049758,0.699100614,0.640939116,0.47253257,0.610606194,0.549213111,0.535207272,0.389388353,0.754743636,0.70731163,0.561478794,0.638902366,0.714305282,0.472618043,72ease of use
338,100,Spacy,Feature,Rule-based matching,Rule-based matching feature,57479028,spaCy NLP custom rule matcher,"I am begginer with NLP. I am using spaCy python library for my NLP project. Here is my requirement,

I have a JSON File with all country names. Now i need to parse and get goldmedal count for the each countries in the document. Given below the sample sentence,

""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics""
I am able to fetch country names but not it medal count. Given below my code. Please help to proceed further.","Spacy provides Rule-based matching which you could use.

They can be used as follows:

import spacy
from spacy.pipeline import EntityRuler
nlp = spacy.load('en_core_web_sm', disable=[""ner"", ""parser""])

countries = ['Czech Republic', 'Slovakia']
ruler = EntityRuler(nlp)
for a in countries:
    ruler.add_patterns([{""label"": ""country"", ""pattern"": a}])
nlp.add_pipe(ruler)


doc = nlp(""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics"")

with doc.retokenize() as retokenizer:
    for ent in doc.ents:
        retokenizer.merge(doc[ent.start:ent.end])


from spacy.matcher import Matcher
matcher = Matcher(nlp.vocab)
pattern =[{'ENT_TYPE': 'country'}, {'lower': 'won'},{""IS_DIGIT"": True}]
matcher.add('medal', None, pattern)
matches = matcher(doc)


for match_id, start, end in matches:
    span = doc[start:end]
    print(span)

output:

Czech Republic won 5
Slovakia won 0
The above code should get you started. Naturally, you will have to write your own more complex rules so that you can handle cases like: ""Czech Republic unsurprisingly won 5 gold medals at olympics in 1995."" And other more complex sentence structures.",code shared for example,The given code shows an example of how to use EntityRuler and Matcher for matching and extracting information from the given text.,,1,C20230706015315705969,0.744410157,0.666183114,0.72466898,0.501338363,0.437274516,0.391426563,0.590509355,0.308006763,0.532554507,0.547281981,0.527369082,0.480388016,0.706625223,0.644542873,0.553626776,0.433472157,0.806738138,0.362831205,0.59060955,0.37951237,0.423346043,0.665952206,0.444475383,0.342702895,100code shared for example
271,79,Spacy,Feature,dependency parsing,dependency parsing feature,55498881,Vectorized form of cleaning function for NLP,"I made the following function to clean the text notes of my dataset :
Problem is when I want to clean all my dataset text, it take hour and hour. (my dataset is 70k row and between 100 to 5000 words per row)

I tried to use swifter to run the apply method on multiplethread like that : data.note_line_comment.swifter.apply(clean)

But it doesn't made really better as it took almost one hour.

I was wondering if there is any way to make a vectorized form of my function or maybe and other way to speed up the process. Any idea ?","Short answer

This type of problem inherently takes time.

Long answer

Use regular expressions
Change the spacy pipeline
The more information about the strings you need to make a decision, the longer it will take.

Good news is, if your cleaning of the text is relatively simplified, a few regular expressions might do the trick.

Otherwise you are using the spacy pipeline to help remove bits of text which is costly since it does many things by default:

Tokenisation
Lemmatisation
Dependency parsing
NER
Chunking
Alternatively, you can try your task again and turn off the aspects of the spacy pipeline you don't want which may speed it up quite a bit.

For example, maybe turn off named entity recognition, tagging and dependency parsing...

nlp = spacy.load(""en"", disable=[""parser"", ""tagger"", ""ner""])
Then try again, it will speed up.",spacy support,Spacy has good support for dependency parsing feature.,,0,C20230706015100095221,0.626292169,0.553211689,0.494460464,0.941913128,0.926786065,0.935556591,0.579450488,0.5960567,0.664418578,0.654647768,0.683454931,0.875827014,0.724006832,0.556970656,0.537149131,0.567795992,0.706634402,0.504055858,0.555020928,0.572822869,0.346862257,0.852523506,0.649741173,0.647474587,79spacy support
119,34,Spacy,Stability,bug,Stability aspect,42215762,How to get Spacy to tokenize am/pm expressions correctly?,"Spacy seems unable to correctly tokenize am/pm expressions where the number and the am/pm part is not separated by whitespace.

Example: ""Something happened at 9am"" produces an unexpected token set: List of Token objects: [Something, happened, at, LIKE_URL, am]

While ""Something happened at 9 am"" works just fine: List of Token objects: [Something, happened, at, 9, am]

I notice that if you drill down into the Token object, the 'orth' representation of the token is a 9. Likewise, if I try '8am', the token reads 'IS_UPPER' and the 'orth' representation of the token is 8.

In particular this is a problem for me because I need to track token spans accross a wider context, and a token that shows up as ""8"" in the text but ""IS_UPPER"" in token form causes my spans to be off by 7. (IE the actual document-level index (token.idx) of the next token is off by 7)

How can I process a document with spacy that contains am/pm expressions sometimes denoted in the format described above, and retrieve accurate token spans?

I'm using Python 2.7.12 with Spacy 1.4.0","Turns out, this was reported as a bug about a month ago: https://github.com/explosion/spaCy/issues/736

Upgrading to Spacy 1.6.0 resolves the issue.",regular updates,"Spacy is regularly updated, suggesting that it is well-tested and constantly being improved.",,0,C20230706014934106832,0.612386703,0.557871461,0.472837746,0.513325453,0.52865839,0.976925492,0.544194996,0.761937857,0.790867925,0.509404957,0.611391842,0.691410959,0.591596842,0.797424614,0.495407104,0.433354378,0.379867792,0.528183579,0.464202613,0.600947022,0.551128268,0.57868129,0.462623686,0.7232306,34regular updates
282,82,Spacy,Feature,Lemmatization,Lemmatization feature,74175424,"Is Spacy lemmatization not working properly or does it not lemmatize all words ending with ""-ing""?","When I run the spacy lemmatizer, it does not lemmatize the word ""consulting"" and therefore I suspect it is failing.

Here is my code:

nlp = spacy.load('en_core_web_trf', disable=['parser', 'ner'])
lemmatizer = nlp.get_pipe('lemmatizer')
doc = nlp('consulting')
print([token.lemma_ for token in doc])
And my output:

['consulting']","The spaCy lemmatizer is not failing, it's performing as expected. Lemmatization depends heavily on the Part of Speech (PoS) tag assigned to the token, and PoS tagger models are trained on sentences/documents, not single tokens (words). For example, parts-of-speech.info which is based on the Stanford PoS tagger, does not allow you to enter single words.

In your case, the single word ""consulting"" is being tagged as a noun, and the spaCy model you are using deems ""consulting"" to be the appropriate lemma for this case. You'll see if you change your string instead to ""consulting tomorrow"", spaCy will lemmatize ""consulting"" to ""consult"" as it is tagged as a verb (see output from the code below). In short, I recommend not trying to perform lemmatization on single tokens, instead, use the model on sentences/documents as it was intended.",recommendations,It is recommended to use the model on sentences/documents as it was intended to improve the accuracy of the lemmatization feature.,,1,C20230706015139949583,0.599640071,0.683108628,0.791891217,0.737229526,0.664817989,0.821503401,0.769030333,0.814462364,0.723732293,0.735490859,0.709252119,0.825340748,0.767317533,0.682838738,0.814948261,0.685915053,0.825447738,0.735192299,0.656591415,0.653082669,0.700035214,0.581905961,0.660090506,0.730166376,82recommendations
142,41,Spacy,Stability,bug,Stability aspect,68559878,Force 'parser' to not segment sentences?,"Is there an easy way to tell the ""parser"" pipe not to change the value of Token.is_sent_start ?

So, here is the story: I am working with documents that are pre-sentencized (1 line = 1 sentence), this segmentation is all I need. I realized the parser's segmentation is not always the same as in my documents, so I don't want to rely on the segmentation made by it.

I can't change the segmentation after the parser has done it, so I cannot correct it when it makes mistakes (you get an error). And if I segment the text myself and then apply the parser, it overrules the segmentation I've just made, so it doesn't work.

So, to force keeping the original segmentation and still use a pretrained transformer model (fr_dep_news_trf), I either :

disable the parser,
add a custom Pipe to nlp to set Token.is_sent_start how I want,
create the Doc with nlp(""an example"")
or, I simply create a Doc with

doc = Doc(words=[""an"", ""example""], sent_starts=[True, False])
and then I apply every element of the pipeline except the parser.

However, if I still do need the parser at some point (which I do, because I need to know some subtrees), If I simply apply it on my Doc, it overrules the segmentation already in place, so, in some cases, the segmentation is incorrect. So I do the following workaround:

Keep the correct segmentation in a list sentences = list(doc.sents)
Apply the parser on the doc
Work with whatever syntactic information the parser computed
Retrieve whatever sentencial information I need from the list I previously made, as I now cannot trust Token.is_sent_start.
It works, but it doesn't really feel right imho, it feels a bit messy. Is there an easier, cleaner way I missed ?

Something else I am considering is setting a custom extension, so that I would, for instance, use Token._.is_sent_start instead of the default Token.is_sent_start, and a custom Doc._.sents, but I fear it might be more confusing than helpful ...

Some user suggested using span.merge() for a pretty similar topic, but the function doesn't seem to exist in recent releases of spaCy (Preventing spaCy splitting paragraph numbers into sentences)","The parser is supposed to respect sentence boundaries if they are set in advance. There is one outstanding bug where this doesn't happen, but that was only in the case where some tokens had their sentence boundaries left unset.

If you set all the token boundaries to True or False (not None) and then run the parser, does it overwrite your values? If so it'd be great to have a specific example of that, because that sounds like a bug.

Given that, if you use a custom component to set your true sentence boundaries before the parser, it should work.

Regarding some of your other points...

I don't think it makes any sense to keep your sentence boundaries separate from the parser's - if you do that you can end up with subtrees that span multiple sentences, which will just be weird and unhelpful.

You didn't mention this in your question, but is treating each sentence/line as a separate doc an option? (It's not clear if you're combining multiple lines and the sentence boundaries are wrong, or if you're passing in a single line but it's turning into multiple sentences.)

Thanks a million for you answer! It made me go back to my documents and check every output of every element in the pipeline... Well, I feel terribly stupid, but I simply cannot reproduce my observation of a ""deffective parser"", everything seems fine now. I guess after my initial struggle with forcing my own sentence boundaries (which wasn't even actually that complicated ...), I convinced myself somehow it wasn't working even after my own boundaries were set ? Or I fixed something else in my code ? Terribly sorry. I'll keep an eye on it, might post here again if I find a mistake again",no major concerns,"Overall, the conversation does not indicate any major issues or concerns with the stability or reliability of Spacy's parser.",,1,C20230706014948095449,0.652306378,0.60855186,0.650106132,0.732269466,0.592521131,0.650826991,0.792593598,0.51582855,0.758421421,0.742349386,0.862831295,0.625298977,0.454723507,0.4702712,0.546733916,0.547900617,0.403607905,0.51200819,0.353200883,0.330819249,0.349615455,0.85513097,0.779032409,0.777427316,41no major concerns
256,75,Spacy,Feature,POS,POS tagging feature,34102420,POS tagging using spaCy,"I am trying to do POS tagging using the spaCy module in Python.
Here it returns crispy as a noun instead of an adjective. However, if I use a test sentence like

a=""we had crispy fries""
It recognizes that crispy is an adjective. Here is the output:

[(we , u'PRP'), (had , u'VBD'), (crispy , u'JJ'), (fries, u'NNS')]
I think the primary reason why crispy wasn't tagged as an adjective in the first case was because dosa was tagged as 'NN' whereas fries was tagged as 'NNS' in the second case.

Is there any way I can get crispy to be tagged as an adjective in the second case too?","TL;DR: You should accept the occasional error.

Details:

Spacy's tagger is statistical, meaning that the tags you get are its best estimate based on the data it was shown during training. I would guess those data did not contain the word dosa. The tagger had to guess, and guessed wrong. There isn't an easy way to correct its output, because it is not using rules or anything you can modify easily. The model has been trained on a standard corpus of English, which may be quite different to the kind of language you are using it for (domain). If error rate is too high for your purposes, you can re-train the model using domain-specific data. This will be very laborious though. Ask yourself what you are trying to achieve and whether 3% error rate in PoS tagging is the worst of your problems.

In general, you shouldn't judge the performance of a statistical system on a case-by-case basis. The accuracy of modern English PoS taggers is around 97%, which is roughly the same as the average human. You will inevitably get some errors. However, the errors of the model will not be the same as the human errors, as the two have ""learnt"" how to solve the problem in a different way. Sometimes the model will get confused by things you and I consider obvious, e.g. your example. This doesn't mean it is bad overall, or that PoS tagging is your real problem.",spacy's statistical tagger,"Spacy's tagger is a statistical model, meaning that its tags are based on its best estimate from the data it was trained on.",,1,C20230706015050662611,0.718328893,0.642456353,0.58082068,0.80188328,0.65466851,0.652908623,0.655922651,0.608087599,0.50892657,0.564327598,0.838920355,0.602655232,0.692913711,0.606838942,0.397685319,0.468908936,0.866361678,0.374566019,0.481880426,0.478812158,0.496838838,0.718539476,0.752745509,0.917803764,75spacy's statistical tagger
315,92,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,56416641,separate texts into sentences NLTK vs spaCy,"I want to separate texts into sentences.

looking in stack overflow I found:

WITH NLTK

from nltk.tokenize import sent_tokenize
text=""""""Hello Mr. Smith, how are you doing today? The weathe is great, and city is awesome. The sky is pinkish-blue. You shouldn't eat cardboard""""""
tokenized_text=sent_tokenize(text)
print(tokenized_text)
WITH SPACY

from spacy.lang.en import English # updated

raw_text = 'Hello, world. Here are two sentences.'
nlp = English()
nlp.add_pipe(nlp.create_pipe('sentencizer')) # updated
doc = nlp(raw_text)
sentences = [sent.string.strip() for sent in doc.sents]
The question is what in the background for spacy having to do it differently with a so called create_pipe. Sentences are important for training your own word embedings for NLP. There should be a reason why spaCy does not include directly out of the box a sentence tokenizer.

Thanks.

NOTE: Be aware that a simply .split(.) does not work, there are several decimal numbers in the text and other kind of tokens containing '.'","By default, spaCy uses its dependency parser to do sentence segmentation, which requires loading a statistical model. The sentencizer is a rule-based sentence segmenter that you can use to define your own sentence segmentation rules without loading a model.

If you don't mind leaving the parser activated, you can use the following code:

import spacy
nlp = spacy.load('en_core_web_sm') # or whatever model you have installed
raw_text = 'Hello, world. Here are two sentences.'
doc = nlp(raw_text)
sentences = [sent.text.strip() for sent in doc.sents]",spacy's segmentation options,Spacy offers a rule-based sentence segmenter or a dependency parser for sentence segmentation.,,1,C20230706015228707347,0.576699257,0.595228672,0.472713649,0.706716955,0.514328599,0.567900002,0.440391004,0.628670335,0.564530194,0.427312165,0.594870329,0.708980143,0.436933488,0.670237482,0.437013656,0.467397273,0.47897929,0.461588442,0.722679377,0.719256461,0.764494836,0.824323118,0.730629444,0.762842417,92spacy's segmentation options
127,37,Spacy,Stability,bug,Stability aspect,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.",alternative solution provided,The answer provided an alternative approach to using the lemmatizer that did not address the user's question directly.,wrong labeling,1,C20230706014939876069,0.635335803,0.641045272,0.568613231,0.60024029,0.90827322,0.572790384,0.681051373,0.642219365,0.667662382,0.85717994,0.928276241,0.797738194,0.63605231,0.765102267,0.660777509,0.501776993,0.815037131,0.546338499,0.600313425,0.629135013,0.656243443,0.682573438,0.833995402,0.593567848,37alternative solution provided
270,79,Spacy,Feature,dependency parsing,dependency parsing feature,55498881,Vectorized form of cleaning function for NLP,"I made the following function to clean the text notes of my dataset :
Problem is when I want to clean all my dataset text, it take hour and hour. (my dataset is 70k row and between 100 to 5000 words per row)

I tried to use swifter to run the apply method on multiplethread like that : data.note_line_comment.swifter.apply(clean)

But it doesn't made really better as it took almost one hour.

I was wondering if there is any way to make a vectorized form of my function or maybe and other way to speed up the process. Any idea ?","Short answer

This type of problem inherently takes time.

Long answer

Use regular expressions
Change the spacy pipeline
The more information about the strings you need to make a decision, the longer it will take.

Good news is, if your cleaning of the text is relatively simplified, a few regular expressions might do the trick.

Otherwise you are using the spacy pipeline to help remove bits of text which is costly since it does many things by default:

Tokenisation
Lemmatisation
Dependency parsing
NER
Chunking
Alternatively, you can try your task again and turn off the aspects of the spacy pipeline you don't want which may speed it up quite a bit.

For example, maybe turn off named entity recognition, tagging and dependency parsing...

nlp = spacy.load(""en"", disable=[""parser"", ""tagger"", ""ner""])
Then try again, it will speed up.",pipeline optimization,Spacy's pipeline features can be turned off to optimize performance for specific tasks. Dependency parsing along with other unnecessary features can be disabled to speed up the process.,,1,C20230706015101017912,0.595118284,0.741312265,0.53411752,0.599512517,0.746114075,0.653432012,0.797229946,0.736359358,0.564526439,0.790761828,0.605465174,0.614044428,0.541861594,0.542628527,0.661904335,0.353031963,0.579657495,0.650929511,0.662299991,0.801554382,0.816034257,0.792424798,0.795102715,0.86702019,79pipeline optimization
80,23,Spacy,Performance,performance,Performance aspect,72413618,How can I make it so that I process each sentence to look for and replace with a synonym for the words that match?,"I am currently working with spacy and have a corpus (containing 960,256 words) that looks like this:
I have a function that looks for the synonym of a word (using spacy):

Which returns an array of answers like so:
What I want is to grab the corpus, feed it sentence by sentence and word by word to most_similar so I can save the list of words to replace and do so by using replace_wordthe thing is that I'm not sure how to do this. I've tried for a while but it always fails somehow (either won't take batches so I can't do it at once, the words end up being empty vectors if I simply split each sentence by .split("" "") so...could you help me out please?","I hope I understood what you need correctly. I'm guessing you want to:

Iterate over a corpus
Find specific tokens using the matcher
Find synonyms of the matched tokens
Return a new list of sentences but with the replaced tokens.
If that's the case then what you need is a valid similarity function (I tried the one above but it didn't work for me properly) but you can try this:
You also mentioned that you want this to run on a corpus. I recommend that you use the nlp.pipe() method for performance gains combined with the set_extension method. You can do it like this:",optimization with nlp.pipe(),User seeks to optimize the process by using nlp.pipe().,,1,C20230706014911037638,0.770239174,0.727515519,0.738670051,0.68720305,0.696658373,0.765276611,0.574132979,0.59513551,0.600498259,0.795245469,0.604052484,0.637481093,0.907681286,0.65561974,0.817685068,0.643262386,0.720204771,0.646670878,0.630582273,0.659701526,0.67056179,0.779381216,0.602801919,0.674473464,23optimization with nlp.pipe()
264,77,Spacy,Feature,dependency parsing,dependency parsing feature,43397502,Rule-based matcher of entities with spacy,"I want to use the python library spacy for matching tokens in a text (adding a labels as a semantic reference). Then, I want to use the matches to extract relations between the tokens. My first was to make use of the matcher.add and matcher.add_pattern of spacy. The matcher.add is working fine and I can find tokens, my code until now:

I have tried in different ways to make this works but is obviously not, I guess there is something wrong with my understanding of matcher.add_pattern.

Can some please put me in the right direction how to do this with spacy?
Is it possible to add regex here to find patterns, how?
How can I add more than one token with the same label, or somehow create a list of tokens for the same label, eg. ""FINANCE""?
I will appreciate any comments.","Your matcher would identify the tokens, but to find relations between them you will have to do dependency parsing. Here is visual example from spacy :
You can then traverse the tree to find relations between the tokens. https://spacy.io/docs/usage/dependency-parse#navigating

The dep (enum) and dep_ (verbose name) attribute of each token would give you the relationships with its child",no explicit mention of regex,It is not explicitly mentioned whether regex can be used to find patterns.,,1,C20230706015056954946,0.677947938,0.568705022,0.658453465,0.7119627,0.75613755,0.697561085,0.68588835,0.513408184,0.624658287,0.436459303,0.652461171,0.626646638,0.592593372,0.871172309,0.702176094,0.889566362,0.897800326,0.901075959,0.476090431,0.739508569,0.583252788,0.58825326,0.659592092,0.749958575,77no explicit mention of regex
146,42,Spacy,Stability,bug,Stability aspect,62737680,Spacy tagger loss is zero while training,"I use this snippet of code to train a tagger in spacy 2.3.0.
The problem is that the loss value is always zero. What am I doing wrong?","Sorry, this is a bug in v2.3.0. It will be fixed in the upcoming v2.3.1. You can train a tagger with spacy train instead or use v2.2.4 in the meanwhile.

If you'd like to have this fix sooner, you can also install from source in the current master branch (the fix is in commit b7107ac8).",alternative solutions provided,Solutions such as using the previous version or alternative methods to train taggers demonstrate a responsive development team and their attention to user feedback.,,0,C20230706014950030347,0.40375936,0.539758682,0.455025792,0.529723465,0.481694371,0.344030887,0.472584367,0.581813335,0.530990899,0.589743793,0.738630831,0.640899837,0.380647928,0.499992937,0.634758592,0.338212281,0.299013346,0.357967436,0.398439258,0.429505914,0.342371613,0.700596094,0.682259738,0.622248411,42alternative solutions provided
230,69,Spacy,Feature,tokenization,tokenization feature,50719732,Keeping all white spaces as tokens,"I have a question about whether there is a way to keep single white space as an independent token in spaCy tokenization.

For example if I ran:

import spacy

nlp = spacy.load(""en_core_web_sm"")
doc = nlp(""This is easy."")
toks = [w.text for w in doc]
toks
The result is

['This', 'is', 'easy', '.']
Instead, I would like to have something like

['This', ' ', 'is', ' ', 'easy', '.']
Is there are a simple way to do that?","spaCy exposes the token's whitespace as the whitespace_ attribute. So if you only need a list of strings, you could do:

token_texts = []
for token in doc:
   token_texts.append(token.text)
   if token.whitespace_:  # filter out empty strings
       token_texts.append(token.whitespace_)
If you want to create an actual Doc object out of those tokens, that's possible, too. Doc objects can be constructed with a words keyword argument (a list of strings to add as tokens). However, I'm not sure how useful that would be.",use of whitespace_ attribute,The whitespace_ attribute can be used to expose the token's whitespace and create a list of strings that includes white spaces.,wrong labeling,1,C20230706015038195214,0.703727245,0.759553015,0.591314077,0.711676955,0.412192971,0.32594955,0.872202754,0.849597454,0.733067453,0.82161212,0.755885422,0.752926886,0.728240311,0.669052541,0.428423226,0.570808589,0.513084233,0.330200791,0.634970248,0.854178548,0.783847153,0.699547052,0.670313597,0.807498515,69use of whitespace_ attribute
57,17,Spacy,Documentation,documentation,Documentation aspect,61241351,"Install specific version of spacy - working with pip, but not with conda","I am revisiting some code I wrote months ago with Spacy Version 2.1.8. I need this version of spacy. pip install is working but Anaconda does not even show that spacy is installed. And

conda install spacy=2.1.8
gives the PackagesNotFoundError error.","As explained in spaCy documentation, you can take advantage of the conda-forge community repository to install spacy

$ conda install -c conda-forge spacy=2.1.8
This version should be available according to spaCy's page on Conda Forge.",available version,Documentation assures that the required version of Spacy should be available on the conda-forge repository.,,1,C20230706014431142992,0.647736251,0.662246883,0.680185974,0.870259464,0.701866448,0.788247347,0.802557528,0.776307821,0.683608592,0.934614241,0.743664742,0.688764513,0.461159736,0.450588346,0.792370439,0.47432965,0.519674361,0.5997262,0.744119704,0.643224239,0.489364177,0.85788399,0.586651802,0.523537576,17available version
336,99,Spacy,Feature,Rule-based matching,Rule-based matching feature,76011075,"Entity Ruler cannot recognize ""Frankfurt am Main"" as Geo-Political Entity (GPE)","I try to add a new rule in Named Entity Recognition so that Spacy will label the phrase ""Frankfurt am Main"" as GPE.

nlp = spacy.load(""en_core_web_sm"")
ruler = nlp.add_pipe(""entity_ruler"")
patterns = [{""label"": ""ORG"", ""pattern"": ""MyCorp Inc.""},{""label"": ""GPE"", ""pattern"": ""Frankfurt am Main""}]
ruler.add_patterns(patterns)
doc = nlp(""MyCorp Inc. is a company in Frankfurt am Main"")
print([(ent.text, ent.label_) for ent in doc.ents])
But Spacy still label the word ""Frankfurt"" as GPE instead of the whole phrase ""Frankfurt am Main"":

[('MyCorp Inc.', 'ORG'), ('Frankfurt', 'GPE')]
I want to know how I can adjust spacy so that it can label ""Frankfurt am Main"" as GPE.","Put the entity_ruler before ner so that its entity spans have priority over the ner entities.

nlp.add_pipe(""entity_ruler"", before=""ner"")
See: https://spacy.io/usage/rule-based-matching#entityruler-usage",adjusting entity priority,"The suggested solution involves moving the Entity Ruler module before the NER module in the pipeline, so that the Entity Ruler entities take priority over NER entities.",,1,C20230706015242338632,0.760868073,0.722429931,0.736844063,0.550889194,0.571921229,0.55632925,0.798568428,0.743529439,0.77073288,0.722027779,0.683084607,0.672488093,0.595268011,0.790180624,0.632753372,0.611745596,0.565757334,0.501329958,0.758818626,0.693094432,0.76352787,0.718722999,0.882326365,0.690923989,99adjusting entity priority
34,10,Spacy,Documentation,documentation,Documentation aspect,48200524,Named entity recognition in Spacy,"I am trying to find Named entities for a sentence as below

import spacy.lang.en
parser = spacy.lang.en.English()
ParsedSentence = parser(u""Alphabet is a new startup in China"")
for Entity in  ParsedSentence.ents:  
    print (Entity.label, Entity.label_, ' '.join(t.orth_ for t in Entity))
I am expecting to get the result ""Alphabet"",""China"" but I am getting an empty set as result. What am I doing wrong here","As per spacy documentation for Name Entity Recognition here is the way to extract name entity

import spacy
nlp = spacy.load('en') # install 'en' model (python3 -m spacy download en)
doc = nlp(""Alphabet is a new startup in China"")
print('Name Entity: {0}'.format(doc.ents))
Result
Name Entity:  (China,) ",output of name entity recognition,Returns set of named entities in input sentence.,,1,C20230706014346047065,0.542072237,0.62651664,0.571914792,0.54806757,0.46097073,0.65544343,0.46570906,0.592489541,0.462125033,0.772738755,0.718472004,0.721433043,0.639925659,0.638858676,0.599590898,0.6573084,0.643256962,0.5688169,0.45945403,0.309153169,0.504444718,0.498450398,0.638038695,0.336593896,10output of name entity recognition
106,30,Spacy,Performance,speed,Performance aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",spacy documentation,The answerer recommends checking the Spacy documentation for more information on using multiprocessing. This suggests that Spacy has provided resources and support on this topic to help users make the most of the library's capabilities.,,0,C20230706014927289054,0.725352228,0.794446945,0.605910122,0.62051177,0.77955991,0.522471726,0.72340107,0.819840789,0.618370831,0.668856263,0.77772975,0.770165801,0.550313771,0.699467242,0.631261647,0.533050478,0.870145023,0.467615783,0.582436621,0.515718341,0.311203539,0.335749865,0.345906854,0.481797963,30spacy documentation
292,85,Spacy,Feature,NER,NER feature,65220447,Add new named entity to Spacy's en_core_web_sm model?,"I'm following the example here on training a new entity type:

https://spacy.io/usage/training#example-new-entity-type

It works fine when I don't pass an existing model to it, and will correctly create a new model, which recognizes my new named entity e.g.

 python.exe train-new-entity-type.py
It also works fine when I pass an existing model to it (created by running it once before), and will correctly load the model in the dir/my_model dir, which still recognizes my new named entity e.g.

 python.exe train-new-entity-type.py -m dir/my_model
However, I want to train a new entity type, and add that to spacy's existing model, so that spacy will recognize it's own supported named entities as well as my new entity type, so I tried:

 python.exe train-new-entity-type.py -m en_core_web_sm
However, this didn't seem to work. Spacy's own supported named entities were recognized but they were not correct (vs just using the en_core_web_sm on its own without adding my new entity type to it), and my new entity type was no longer recognized at all.

Am I doing something wrong? Is this possible (adding named entities to en_core_web_sm)?","Read about the ""catastrophic forgetting"" problem when updating an existing model: https://spacy.io/usage/training#ner

It can be tricky to update an existing model, so it might be easier to train a separate model for your new entity type and add the NER component to the en_core_web_sm pipeline with a custom name. The main thing to watch out for is that you need to make sure the models are loaded with the same vocab so that you don't run into problems with the string store:

import spacy
nlp = spacy.load(""en_core_web_sm"")
custom_nlp = spacy.load(""my_model"", vocab=nlp.vocab)
nlp.add_pipe(custom_nlp.get_pipe(""ner""), name=""my_ner"", before=""ner"")
Where you add it in the pipeline (before/after the existing ner) will determine which entity spans have priority, since the ner component won't modify existing entity spans.",separate model recommended,It might be easier to train a separate model for a new entity type and add the NER component to the en_core_web_sm pipeline.,,1,C20230706015144437869,0.770515025,0.662150919,0.675203621,0.650317788,0.685183823,0.822674036,0.796918392,0.7479707,0.597225785,0.874311447,0.702334404,0.757232785,0.725643635,0.586995006,0.580847085,0.56352824,0.631945848,0.703305244,0.747976601,0.695336998,0.679228783,0.87854892,0.827045202,0.864557683,85separate model recommended
156,44,Spacy,Stability,backwards,Stability aspect,52598788,spaCy: custom attributes not matching correctly?,"I have been having problems using custom extension attributes with the recently improved Matcher (spaCy 2.012). Even a simple example (mostly copied from here) is not working as I expected:
In other words, the rule correctly matches on the span 'have' (1, 2), but incorrectly matches 'have' (5, 6) and 'had' (6, 7). Furthermore, the callback function is not called. The custom attribute appears to be ignored.
The first rule functions as above. Then the second rule triggers, along with the callback function (which prints the message). There is an additional correct match for the new pattern along with the correct and erroneous matches from the first rule.

So, I have a few questions:

why does pattern1 match incorrectly? (i.e. why does the _ custom attribute constraint not apply?)
why does the callback function not work on the first call?
why does it work upon addition of a new rule?
In my own code, when using custom attributes as constraints in subsequent patterns, these patterns match on ALL tokens. I assume this is related to the behaviour exhibited by the code above.","Sorry if this was confusing ‚Äö√Ñ√∂‚àö√ë‚àö¬® but the GitHub thread you're referring to is still only the spec and proposal, i.e. the planned implementation. The changes will hopefully ship with spaCy v2.1.0 (since some of the changes to the Matcher internals are not fully backwards compatible).

While the custom attribute matching isn't implemented yet, the basic improvements to the Matcher engine are already available on the develop branch and in the alpha version via spacy-nightly (pip install spacy-nightly). Those updates likely also resolve the inconsistent behaviour you observed with the callback function.",updates may not be backwards compatible,"Some of the updates to spaCy may not be fully backwards compatible, indicating that care is being taken to ensure compatibility with existing code.",,1,C20230706014956133774,0.688941956,0.787887096,0.521028459,0.797856331,0.622672915,0.655309796,0.854111135,0.811121523,0.750804842,0.879440546,0.805476427,0.781793296,0.602075815,0.717316687,0.47637108,0.572500408,0.857306004,0.540832818,0.65098089,0.750913322,0.575238168,0.871761143,0.807599425,0.878929913,44updates may not be backwards compatible
244,72,Spacy,Feature,POS,POS tagging feature,42830248,how to write spacy matcher of POS regex,"Spacy has two features I'd like to combine - part-of-speech (POS) and rule-based matching.

How can I combine them in a neat way?

For example - let's say input is a single sentence and I'd like to verify it meets some POS ordering condition - for example the verb is after the noun (something like noun**verb regex). result should be true or false. Is that doable? or the matcher is specific like in the example

Rule-based matching can have POS rules?

If not - here is my current plan - gather everything in one string and apply regex","Sure, simply use the POS attribute.

import spacy
nlp = spacy.load('en')
from spacy.matcher import Matcher
from spacy.attrs import POS
matcher = Matcher(nlp.vocab)
matcher.add_pattern(""Adjective and noun"", [{POS: 'ADJ'}, {POS: 'NOUN'}])

doc = nlp(u'what are the main issues')
matches = matcher(doc)",flexibility,Spacy matcher can easily incorporate POS regex to match patterns.,,1,C20230706015043323359,0.785674334,0.680929661,0.466747999,0.633819938,0.620391965,0.684920192,0.345539868,0.520655513,0.500408292,0.648858666,0.473136902,0.531235456,0.576376259,0.634033561,0.839930475,0.467773229,0.538470924,0.444677919,0.803807318,0.509724617,0.547544539,0.555287957,0.563882291,0.553400338,72flexibility
107,30,Spacy,Performance,speed,Performance aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",speed faq,The answerer also recommends checking the Speed FAQ for more information on using multiprocessing with Spacy. This resource likely provides additional tips and best practices for improving performance with multiprocessing.,,1,C20230706014927822933,0.684434354,0.753140688,0.74349153,0.687617719,0.657514453,0.692439675,0.640383661,0.887847304,0.690303326,0.610514581,0.723613441,0.647226095,0.734104037,0.780202746,0.776213229,0.72161293,0.722639024,0.774698496,0.570172906,0.795452833,0.745378852,0.505635321,0.523751497,0.75378108,30speed faq
115,33,Spacy,Stability,bug,Stability aspect,40595828,"Retrieving the start and end character indices in the original document, for those sentences returned by Spacy","I am using something similar to the following pattern to retrieve the start and end indices of Spacy's sentences in the original document:
This seems to work for those few test docs I used. But worried if I am overlooking any 'gotchas' like spacy sometimes stripping off some characters that I am not aware of . Am I?

PS: If it helps, I need these indices to compare with indices I have from Brat's annotation file.","You should just be able to use the sent.start_char and sent.end_char attributes. These give exactly the indices you're after: https://spacy.io/docs/api/span#attributes

Also doc.text should always equal the original full text. If it doesn't, please submit a bug report.",original full text provided,Spacy is able to provide the original full text which suggests it will preserve important details and is unlikely to strip off any characters.,,1,C20230706014933164049,0.363378555,0.730925381,0.541668713,0.497128695,0.667901695,0.560676634,0.460892349,0.619966686,0.648393154,0.397643298,0.687061787,0.469419867,0.407088906,0.664233685,0.493233174,0.416362792,0.256142944,0.433021039,0.545458376,0.545350134,0.712468028,0.655665517,0.580381513,0.490571499,33original full text provided
29,9,Spacy,Documentation,documentation,Documentation aspect,52855178,Discrepancy documentation and implementation of spaCy vectors for German words?,"According to documentation:

spaCy's small models (all packages that end in sm) don't ship with word vectors, and only include context-sensitive tensors. [...] individual tokens won't have any vectors assigned.
But when I use the de_core_news_sm model, the tokens Do have entries for x.vector and x.has_vector=True.

It looks like these are context_vectors, but as far as I understood the documentation only word vectors are accessible through the vector attribute and sm models should have none. Why does this work for a ""small model""?","has_vector behaves differently than you expect.

This is discussed in the comments on an issue raised on github. The gist is, since vectors are available, it is True, even though those vectors are context vectors. Note that you can still use them, eg to compute similarity.

Quote from spaCy contributor Ines:

We've been going back and forth on how the has_vector should behave in cases like this. There is a vector, so having it return False would be misleading. Similarly, if the model doesn't come with a pre-trained vocab, technically all lexemes are OOV.
Version 2.1.0 has been announced to include German word vectors.",discussions on has_vector,"Contributors have been discussing the behavior of the has_vector attribute in cases like this, where only context vectors are available.",,1,C20230706014343424196,0.809547901,0.490682304,0.773652792,0.487269551,0.417430431,0.809497714,0.373265684,0.476583749,0.77844429,0.335212708,0.388631254,0.681617916,0.445827216,0.539863825,0.427592784,0.496378899,0.514405668,0.540918291,0.565137446,0.48682189,0.531403482,0.569449842,0.794938266,0.580952585,9discussions on has_vector
42,12,Spacy,Documentation,documentation,Documentation aspect,50189238,How to re-train an existing spacy NER model for currency,"I am trying to update an existing spacy model ""en_core_web_sm"" with some different country currency such as ""euro"", ""rupees"", ""eu"", ""Rs."", ""INR"" etc. How can I achieve that ? The spacy tutorial didn't quite help me as training a fixed string such as ""horses"" as ""ANIMAL"" seems different than my requirements. The reason is I can have currency value indifferent formats : ""1 million euros"", ""Rs. 10,000"", ""INR 1 thousand"" etc. My sample dataset contains around 1000 samples with the following format :

TRAIN_DATA = [      
 ("" You have activated International transaction limit for Debit Card ending XXXX1137 on 2017-07-05 12:48:20.0 via NetBanking. The new limit is Rs. 250,000.00"", {'entities' : [(140, 154, 'MONEY')] }),...
]
Can anyone please help me out with this with the data format, training size or any other relevant information ?","The example from the documentation should work for you. I altered it a little to match your variable name.

optimizer = nlp.begin_training()

for itn in range(100):
    random.shuffle(train_data)
    for raw_text, entity_offsets in TRAIN_DATA:
        doc = nlp.make_doc(raw_text)
        gold = GoldParse(doc, entities=entity_offsets)
        nlp.update([doc], [gold], drop=0.5, sgd=optimizer)
nlp.to_disk('/model')
Link to Documentation",training method,"The solution involves iterating over a shuffled training data for 100 iterations, creating a Doc and a GoldParse object for each iteration, and updating the NER model with nlp.update() using a dropout rate of 0.5 and an optimizer.",,1,C20230706014349064239,0.517311275,0.755504251,0.750611484,0.226277158,0.088032469,0.192470253,0.7854532,0.554620385,0.265809208,0.628222048,0.275049776,0.277805865,0.834064126,0.598774374,0.301337689,0.397372812,0.414110154,0.243603751,0.423101842,0.497234583,0.499923617,0.644389987,0.776230156,0.628822207,12training method
340,100,Spacy,Feature,Rule-based matching,Rule-based matching feature,57479028,spaCy NLP custom rule matcher,"I am begginer with NLP. I am using spaCy python library for my NLP project. Here is my requirement,

I have a JSON File with all country names. Now i need to parse and get goldmedal count for the each countries in the document. Given below the sample sentence,

""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics""
I am able to fetch country names but not it medal count. Given below my code. Please help to proceed further.","Spacy provides Rule-based matching which you could use.

They can be used as follows:

import spacy
from spacy.pipeline import EntityRuler
nlp = spacy.load('en_core_web_sm', disable=[""ner"", ""parser""])

countries = ['Czech Republic', 'Slovakia']
ruler = EntityRuler(nlp)
for a in countries:
    ruler.add_patterns([{""label"": ""country"", ""pattern"": a}])
nlp.add_pipe(ruler)


doc = nlp(""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics"")

with doc.retokenize() as retokenizer:
    for ent in doc.ents:
        retokenizer.merge(doc[ent.start:ent.end])


from spacy.matcher import Matcher
matcher = Matcher(nlp.vocab)
pattern =[{'ENT_TYPE': 'country'}, {'lower': 'won'},{""IS_DIGIT"": True}]
matcher.add('medal', None, pattern)
matches = matcher(doc)


for match_id, start, end in matches:
    span = doc[start:end]
    print(span)

output:

Czech Republic won 5
Slovakia won 0
The above code should get you started. Naturally, you will have to write your own more complex rules so that you can handle cases like: ""Czech Republic unsurprisingly won 5 gold medals at olympics in 1995."" And other more complex sentence structures.",matcher for rule matching,Matcher can be used to define complex rules for matching entities in the text based on the defined patterns.,,1,C20230706015243910447,0.81989795,0.689406633,0.448703468,0.639386892,0.493425637,0.534740269,0.608879983,0.706388116,0.417326897,0.490110576,0.292052627,0.46095413,0.674241662,0.662993848,0.689060271,0.663760006,0.658668637,0.8437922,0.652540207,0.662644565,0.709445775,0.446879029,0.546563148,0.777729809,100matcher for rule matching
164,47,Spacy,Stability,version,Stability aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",prodigy tool,"The development of Prodigy, an annotation tool that integrates with Spacy and helps users train and evaluate models faster, is a testament to the stability and sophistication of the library.",,1,C20230706015000849466,0.640536308,0.673318446,0.513036489,0.801997662,0.617865205,0.628414214,0.815238774,0.826457024,0.650989711,0.904535055,0.425083011,0.454378754,0.6047647,0.699525476,0.518267453,0.642522573,0.628096819,0.569866717,0.842748642,0.75882566,0.702412546,0.772474349,0.791074991,0.709355175,47prodigy tool
97,28,Spacy,Performance,fast,Performance aspect,40615717,Spacy.io multithreading with custom pipelines,"I'm trying to use Spacy.io with custom pipelines for language processing, but it seems that when I add a custom function to the pipeline the process runs only on one thread. With default pipeline process uses all the threads specified.

This is how I defined pipeline:

nlp = spacy.load(language, create_pipeline=custom_pipeline)
This is custom_pipeline function:

def custom_pipeline(nlp):
    return (nlp.tagger, score_vocab_pipe)
This is how I run the pipeline:

nlp.pipe(texts, batch_size=1000, n_threads=8)
Are there any requisites for custom pipeline functions to support multithreading with spacy?","This post might give you a better understanding of how the multi-threading is implemented. The multi-threading is described in the docs here.

In short: the tagger doesn't currently release the GIL, so the tagger.pipe() method is just a generator that applies the tagger one-by-one. The tagger should be quite fast for most workloads with one thread per process, especially since it doesn't use much memory. You can see the recipe for multi-processing batch jobs here.

We could release the GIL around the tagger as well, to allow efficient multi-threading. If you'd like to work on this, we can talk about it on the tracker or the spaCy Gitter.",gil not released,"The tagger in Spacy does not currently release the GIL, which means that the tagger.pipe() method applies the tagger one-by-one instead of allowing for efficient multi-threading.",No answer available against the challenge,1,C20230706014921055923,0.598167598,0.686029077,0.67224896,0.668695569,0.657206535,0.575372994,0.500908136,0.903268933,0.813895881,0.551888704,0.611339748,0.933318138,0.728381872,0.535831749,0.644699097,0.4579781,0.565735102,0.514462709,0.80299747,0.777084947,0.844833612,0.905805469,0.87990886,0.842472792,28gil not released
36,11,Spacy,Documentation,documentation,Documentation aspect,58215855,"How to get full list of POS, Tag, and Dep in spaCy?","The POS, TAG, and DEP values used in spaCy are common ones of NLP, but I believe there are some differences depending on the corpus database.

For example, Universal Dependencies Contributors has listed 37 syntactic dependencies. Does spaCy use all of these 37 dependencies? And nothing more?

Is there a command to output all POS, TAG, and DEP values, spaCy may provide?","A specific pipeline component can show its labels:

nlp = spacy.load('en')
nlp.get_pipe(""tagger"").labels
# ('$', ""''"", ',', '-LRB-', '-RRB-', '.', ':', 'ADD', 'AFX', 'CC', 'CD', 'DT', 'EX', 'FW', 'HYPH', 'IN', 'JJ', 'JJR', 'JJS', 'LS', 'MD', 'NFP', 'NN', 'NNP', 'NNPS', 'NNS', 'PDT', 'POS', 'PRP', 'PRP$', 'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB', 'XX', '_SP', '``')
spacy.explain(label) will give a short definition for most labels, e.g.:

spacy.explain(""NN"")
# 'noun, singular or mass'
spacy.explain(""PERSON"")
# 'People, including fictional'
The detailed documentation is here: https://spacy.io/api/annotation",accessing labels,A specific pipeline component can be used to show its labels.,,1,C20230706014346572681,0.635344148,0.706995785,0.588385344,0.684021711,0.676032543,0.786263525,0.680621684,0.560197115,0.509941638,0.470829576,0.751517236,0.48196581,0.482259542,0.718210638,0.575853646,0.407657087,0.415038019,0.620056272,0.646095097,0.585519135,0.67175442,0.779436588,0.735604644,0.805803061,11accessing labels
196,57,Spacy,Active Maintenance,github,Active Maintenance aspect,46765198,Unable to load spacy English model - 'WindowsPath' object has no attribute 'read',"I installed spacy using pip and then downloaded the English model using  
$ python -m spacy download en which after downloading gave me the message

You can now load the model via spacy.load('en')
I have the English model files(en_core_web_sm) downloaded to the working directory, am I missing something? Do I need to set a path variable? Any help is much appreciated, thanks!",If anybody else receives this error : I opened this as an issue with spaCy's developers on Github. I was suggested using Python 3.6 instead of 2.7 for the moment as there is no alternate workaround to the problem. The next spaCy version should cover this bugfix (I'm told).,developer responsiveness,The fact that the developers responded on Github and suggested using a different version of Python for the moment highlights their responsiveness.,wrong labeling,0,C20230706015018261101,0.71857214,0.655788243,0.51870358,0.425982893,0.633132279,0.478513032,0.437201202,0.574245453,0.576066017,0.707610011,0.597829401,0.653918862,0.759334385,0.537432492,0.459436059,0.580669641,0.444732457,0.385058671,0.353874207,0.33281672,0.517966151,0.637043417,0.667741597,0.485152185,57developer responsiveness
61,18,Spacy,Documentation,documentation,Documentation aspect,68083466,How to use spacy train to add entities to an existing custom NER model? (Spacy v3.0),"I am currently implementing a custom NER model interface where a user can interact with a frontend application to add custom entities to train a spacy model.

I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.

For example, let's say I have a model that is already trained for a custom entity of FOOD. (Pizza, Pasta, Bread, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ). Now I want to take this existing model, and train it for a new entity called DRINKS with keywords like Coca-Cola, Pepsi, Juice, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ Using spacy train command for spacy v3.0.

The spacy train command that I am using currently is as follows:

> python -m spacy train config.cfg --output ./output --paths.train ./train.spacy --paths.dev ./train.spacy
I load the model for prediction using:

> nlp1 = spacy.load(R"".\output\model-best"")
As of now, I was training the model for new entities manually. Below is the code to find keywords in my training data and output a JSON format for training data (old format).","""I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.""
What you are describing is called ""online learning"" and the default spaCy models don't support it. Most modern neural NER methods, even outside of spaCy, have no support for it at all.

You cannot fix this by using a custom training loop.

Your options are to use rule-based matching, so you can only match things explicitly in a list, or to retrain models on the fly.

Rule-based matching should be easy to set up but has the obvious issue that it can't learn things not explicitly in the list.

Training things on the fly may sound like it'll take too long, but you can train a small model quite quickly. What you can do is train a small model for a small number of iterations while the user is working interactively, and after they've confirmed the model is more or less working correctly you can use the same training data for a larger model with longer training.",online learning not supported,"The default spaCy models do not support online learning, where an existing model can be updated with new entities without training the whole model again.",,1,C20230706014826555306,0.70974195,0.788011193,0.550995052,0.651245415,0.497059345,0.712668717,0.610212445,0.770489573,0.749617994,0.622661591,0.842081964,0.819767535,0.601974189,0.708221555,0.508537233,0.432406694,0.363630384,0.716270804,0.628221035,0.792324126,0.739857137,0.805998087,0.88709861,0.874017596,18online learning not supported
13,4,Spacy,Ease of use,simple,Ease of use aspect,57199811,Create a Spacy pipeline with my own Tokeniser?,"What puzzles me is that a spacy ""pipeline"" is a sequence of processing steps, but the very first step which converts the original data into a spacy document is ""hidden"". Unlike all the other steps it cannot be accessed from the pipeline, I think. So what if I want to replace it, change it, or create a pipeline with my own Tokenizer, what is the proper way to do this?","The reason the tokenizer isn't part of the regular pipeline is because it's ""special"": There can only really be one, and while all other pipeline components take a Doc and return it, the tokenizer takes a string of text and turns it into a Doc.

However, nlp.tokenizer is writable, so you can either create your own Tokenizer class from scratch, or even replace it with an entirely custom function. Here's a super simple example that shows the idea:
",tokenizer is special,The tokenizer is separate from the regular pipeline because it takes in text as input and converts it into a Doc.,,1,C20230706014332048192,0.65327239,0.518603206,0.692088425,0.469041258,0.574139237,0.58235532,0.823662758,0.74107337,0.715881646,0.736970425,0.746265471,0.75037992,0.644245148,0.387793034,0.789190233,0.449449688,0.514800072,0.608473778,0.668755472,0.297901779,0.461236149,0.476021439,0.72810632,0.478382587,4tokenizer is special
209,62,GSON,Security,Security,Security aspect,13267258,Gson SecurityException: Can not make Class Constructor accessible,"I am using Gson to serialize/deserialize a class that contains a static nested class. The class looks like below.

public class ClassA {
private NestedClass nestedClass;

public NestedClass getNestedClass() {
return nestedClass;
}

public void setNestedClass(NestedClass nestedClass) {
this.nestedClass = nestedClass;
}

public static class NestedClass implements Serializable {

public NestedClass() {
}
}
}
The serialization works fine, but when i am trying to deserialize the json string back into an object i get the following SecurityException.

The exception seems to be coming from Java while trying to reflect the inner class. Has anyone been in that situation before?

Any help appreciated.",It appears you're running Gson on a JVM with a SecurityManager enabled. You'll need to disable the security manager to use Gson.,securityexception reflection,The SecurityException being experienced by the user seems to be related to Java's reflection feature attempting to access the inner class.,No answer available against the challenge,0,C20230706015025687365,0.674876869,0.773094714,0.585480034,0.725794613,0.846912324,0.693018317,0.832192481,0.798444748,0.713335633,0.886362433,0.748197258,0.698839188,0.7060256,0.713322759,0.495569021,0.644178689,0.502566218,0.655941248,0.656649828,0.809954524,0.570533454,0.771107852,0.832022309,0.785526991,62securityexception reflection
219,66,GSON,Security,Security,Security aspect,39176229,Deserializing to a templated class with Gson,"I have a class with a nested subclass
Currently I would like to be able to have a function that takes as a parameter the held class, and returns an appropriate instance of GenericClassHolder, i.e. something like my current code:
But this does not work in my current implementation, with the error

Unable to invoke no-args constructor for GenericClassHolder<T>. Register an InstanceCreator with Gson for this type may fix this problem.
How can I succinctly achieve my aforementioned goal of having a function that takes as input the specification for a class that may change and parses to this object accordingly? If it is not possible to achieve an elegant solution through a function, how can I achieve this goal without one?","I deployed this code in a Google Appengine instance, and due to some security reasons, I could not deserialize the way I was deserializing and replicate the same way on my local machine. The solution was to make the deserialized classes static; they were nested inside of an outer encapsulating class as well",adapting to environment,The solution to the technical issue involved adapting the code to work in a specific environment (Google Appengine).,,1,C20230706015032607177,0.562250137,0.515845716,0.560949147,0.549099386,0.468622416,0.616083503,0.517046809,0.528221667,0.454055786,0.451060683,0.448735207,0.449893206,0.572104275,0.641811788,0.379542887,0.401554585,0.459426314,0.241033182,0.395066619,0.630333245,0.653498828,0.457423598,0.347736537,0.762791455,66adapting to environment
311,91,Spacy,Feature,Entity linking,Entity linking feature,60809394,Can spaCy link only named entities?,"I'd would like to extract important entities and link them to Wikipedia entities. I've trained spaCy on a small sample of Wikipedia/WikiData and run entity linking on the review:

[('Tofu', 'PERSON', 'Q177378'), 
('Nyquil', 'WORK_OF_ART', 'NIL')]
I'd like other entities to be extracted and linked as well, e.g.:

kimchi -> Kimchi
cold -> Common cold
healing -> medicine 
medically -> medicine
It looks like spaCy can link only named entities. I've tried to explicitly list other entities as named (which obviously does not scale well):

ruler = EntityRuler(nlp)
patterns = [{""label"": ""ORG"", ""pattern"": ""kimchi""}, {""label"": ""ORG"", ""pattern"": ""cold""}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, spaCy does not seem to link new entities at all:

[ ('Tofu', 'PERSON', 'Q177378'),
  ('cold', 'ORG', ''),
  ('Nyquil', 'WORK_OF_ART', 'NIL'),
  ('kimchi', 'ORG', '')]
How can I make Spacy recognize also other entities?
Should this be done before training entity linking model or can be done with already trained model?
Is spaCy the right tool for my task at all?","In theory it's possible. First, you'll need to make sure you have a component that tags these kind of entities. You could train an NER model for this, but be aware that its performance might not be as good on things like ""cold"" than it would be for actual named entities like ""London"".

To create the Knowledge Base and the Entity Linker from Wikipedia/Wikidata, the example scripts are not limited to named entities - they attempt to parse anything that appears in an intra-wiki link. If the word ""cold"" gets linked to the page ""Common cold"", it should be able to learn it. The exact entities that are stored in the KB and that are used for training the EL model, depend on which entities are found by your entity recognizer component. So if you adjust that according to your use-case, the entity linking component will follow automatically.",suitability of spacy,"spaCy can be a suitable tool for the task if the entity recognizer component is properly trained, although the performance of the NER model on non-named entities may not be perfect.",,1,C20230706015228182220,0.73489213,0.626418948,0.83539778,0.626846731,0.594208181,0.447002083,0.812146306,0.643256605,0.497111201,0.739019454,0.432024211,0.303708404,0.674341261,0.628435373,0.543318808,0.68095082,0.539209068,0.532845795,0.790356755,0.653090954,0.695488095,0.73037523,0.748654723,0.697179377,91suitability of spacy
341,100,Spacy,Feature,Rule-based matching,Rule-based matching feature,57479028,spaCy NLP custom rule matcher,"I am begginer with NLP. I am using spaCy python library for my NLP project. Here is my requirement,

I have a JSON File with all country names. Now i need to parse and get goldmedal count for the each countries in the document. Given below the sample sentence,

""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics""
I am able to fetch country names but not it medal count. Given below my code. Please help to proceed further.","Spacy provides Rule-based matching which you could use.

They can be used as follows:

import spacy
from spacy.pipeline import EntityRuler
nlp = spacy.load('en_core_web_sm', disable=[""ner"", ""parser""])

countries = ['Czech Republic', 'Slovakia']
ruler = EntityRuler(nlp)
for a in countries:
    ruler.add_patterns([{""label"": ""country"", ""pattern"": a}])
nlp.add_pipe(ruler)


doc = nlp(""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics"")

with doc.retokenize() as retokenizer:
    for ent in doc.ents:
        retokenizer.merge(doc[ent.start:ent.end])


from spacy.matcher import Matcher
matcher = Matcher(nlp.vocab)
pattern =[{'ENT_TYPE': 'country'}, {'lower': 'won'},{""IS_DIGIT"": True}]
matcher.add('medal', None, pattern)
matches = matcher(doc)


for match_id, start, end in matches:
    span = doc[start:end]
    print(span)

output:

Czech Republic won 5
Slovakia won 0
The above code should get you started. Naturally, you will have to write your own more complex rules so that you can handle cases like: ""Czech Republic unsurprisingly won 5 gold medals at olympics in 1995."" And other more complex sentence structures.",spacy supports rule-based matching,Spacy provides the Rule-based matching feature that allows users to create patterns and match them in the given text.,,1,C20230706015242861629,0.708969533,0.614822388,0.633298278,0.558565557,0.683357894,0.574510038,0.589882255,0.488871336,0.500453889,0.548561394,0.365374595,0.392102927,0.644601047,0.663638651,0.560042143,0.480814517,0.868002474,0.491766751,0.668451786,0.489214599,0.572693825,0.485784352,0.61504519,0.703724623,100spacy supports rule-based matching
237,71,Spacy,Feature,tokenization,tokenization feature,50330455,How to detokenize spacy text without doc context?,"I have a sequence to sequence model trained on tokens formed by spacy's tokenization. This is both encoder and decoder.

The output is a stream of tokens from a seq2seq model. I want to detokenize the text to form natural text.

Example:

Input to Seq2Seq: Some text

Output from Seq2Seq: This does n't work .

Is there any API in spacy to reverse tokenization done by rules in its tokenizer?","TL;DR I've written a code that attempts to do it, the snippet is below.

Another approach, with a computational complexity of O(n^2) * would be to use a function I just wrote. The main thought was ""What spaCy splits, shall be rejoined once more!""
Downsides:

In this approach you may easily merge ""do"" and ""nt"", as well as strip space between the dot ""."" and preceding word. This method is not perfect, as there are multiple possible combinations of sentences that lead to specific spaCy tokenization.

I am not sure if there is a method to fully detokenize a sentence when all you have is spaCy separated text, but this is the best I've got.

After having searched for hours on Google, only a few answers came along, with this very stack question being opened on 3 of my tabs on chrome ;), and all it wrote was basically ""don't use spaCy, use revtok"". As I couldn't change the tokenization other researchers chose, I had to develop my own solution. Hope it helps someone ;)",attempted solution,The user presenting the answer attempted to detokenize the text by rejoining the words that Spacy splits.,wrong labeling,1,C20230706015041864245,0.735319853,0.748660326,0.69407481,0.792904675,0.845585465,0.868079782,0.659201741,0.714565217,0.732830167,0.671594739,0.843849301,0.722863674,0.561384976,0.673702896,0.638443828,0.650859237,0.632490635,0.632965684,0.563716471,0.721321642,0.605436027,0.835890412,0.760721803,0.805667877,71attempted solution
198,58,Spacy,Active Maintenance,github,Active Maintenance aspect,53728770,Cannot install es_core_news_sm from Spacy,"When I try to install es_core_news_sm with this commmand

python -m spacy download es_core_news_sm
with conda I get this error

No module name spacy._main_;'spacy'is a package and cannot be directly executed. 
Thank you so much!","This could happen if conda installed an older version of spaCy. See the following issue on spaCy's github.

The fix as stated in the issue is as follows:

Find the most recent version of spaCy on conda:conda search -f spacy
Then run: conda install spacy=NEWEST_VERSION
The newest version of spaCy on Conda is 2.0.18",compatibility issue,"The issue faced by the user is related to compatibility rather than maintenance, as the user is trying to install a model using an older version of spaCy which causes an error.",,1,C20230706015019714783,0.602291584,0.703878641,0.641854405,0.507886589,0.451108903,0.242206916,0.551015437,0.733892024,0.686863303,0.567538381,0.51495558,0.620559335,0.469001383,0.694530606,0.638706923,0.40197742,0.501372874,0.440199137,0.580944955,0.401443124,0.65238905,0.270270288,0.560973525,0.26424697,58compatibility issue
253,75,Spacy,Feature,POS,POS tagging feature,34102420,POS tagging using spaCy,"I am trying to do POS tagging using the spaCy module in Python.
Here it returns crispy as a noun instead of an adjective. However, if I use a test sentence like

a=""we had crispy fries""
It recognizes that crispy is an adjective. Here is the output:

[(we , u'PRP'), (had , u'VBD'), (crispy , u'JJ'), (fries, u'NNS')]
I think the primary reason why crispy wasn't tagged as an adjective in the first case was because dosa was tagged as 'NN' whereas fries was tagged as 'NNS' in the second case.

Is there any way I can get crispy to be tagged as an adjective in the second case too?","TL;DR: You should accept the occasional error.

Details:

Spacy's tagger is statistical, meaning that the tags you get are its best estimate based on the data it was shown during training. I would guess those data did not contain the word dosa. The tagger had to guess, and guessed wrong. There isn't an easy way to correct its output, because it is not using rules or anything you can modify easily. The model has been trained on a standard corpus of English, which may be quite different to the kind of language you are using it for (domain). If error rate is too high for your purposes, you can re-train the model using domain-specific data. This will be very laborious though. Ask yourself what you are trying to achieve and whether 3% error rate in PoS tagging is the worst of your problems.

In general, you shouldn't judge the performance of a statistical system on a case-by-case basis. The accuracy of modern English PoS taggers is around 97%, which is roughly the same as the average human. You will inevitably get some errors. However, the errors of the model will not be the same as the human errors, as the two have ""learnt"" how to solve the problem in a different way. Sometimes the model will get confused by things you and I consider obvious, e.g. your example. This doesn't mean it is bad overall, or that PoS tagging is your real problem.",97% accuracy,"The accuracy of modern English PoS taggers, including Spacy, is around 97%, which is comparable to the average human performance.",,1,C20230706015051783880,0.869606793,0.693510413,0.435518056,0.845432699,0.324262649,0.341010153,0.647270799,0.648185313,0.885594964,0.594642162,0.614385307,0.747486353,0.594252765,0.592414975,0.536809862,0.563554645,0.373947114,0.439722002,0.6797539,0.606288254,0.714691103,0.781668007,0.927322805,0.756994963,7597% accuracy
182,52,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,55852115,Token extension versus matcher versus phrase matcher vs entity ruler in spaCy,"I am trying to figure out the best way (fast) to extract entities, e.g. a month. I have come up with 5 different approaches using spaCy.

Initial setup

For each solution I start with an initial setup
Conclusion

The custom attributes with is limited to single token matching and the token matcher seems to be faster so that seems to be preferable. The EntityRuler seems to be the slowest which isn't surprising since it is changing the Doc.ents. It is however quite convenient that you have your matches in Doc.ents so you might want to consider this method still.

I was quite surprised that the token matcher outperforms the phrase matcher. I thought it would be opposite:

If you need to match large terminology lists, you can also use the PhraseMatcher and create Doc objects instead of token patterns, which is much more efficient overall
Question

Am I missing something important here or can I trust this analysis on a larger scale?","I think ultimately, it all comes down to finding the optimal tradeoff between speed, maintainability of the code and the way this piece of logic fits into the larger picture of your application. Finding a few strings in a text is unlikely to be the end goal of what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® otherwise, you probably wouldn't be using spaCy and would stick to regular expressions. How your application needs to ""consume"" the result of the matching and what the matches mean in the larger context should motivate the approach you choose.

As you mention in the conclusion, if your matches are ""named entities"" by definition, adding them to the doc.ents makes a lot of sense and will even give you an easy way to combine your logic with statistical predictions. Even if it adds slightly more overhead, it'll likely still outperform any scaffolding you'd otherwise have to write around it yourself.",usage in conversation,The fact that Spacy is still being discussed suggests it is relevant and widely used in natural language processing.,,0,C20230706015010038375,0.573314428,0.550584972,0.451086134,0.800183415,0.667810738,0.741568208,0.757966459,0.754445076,0.700012684,0.86116749,0.773306608,0.871070385,0.470868796,0.541005373,0.587357104,0.684123933,0.509038985,0.636155009,0.463491827,0.781158268,0.534503579,0.574042857,0.754923761,0.483253568,52usage in conversation
131,38,Spacy,Stability,bug,Stability aspect,64164360,How can I add a specific substring to tokenize on in spaCy?,"I am using spaCy to tokenize a string, and the string is likely to contain a specific substring. If the substring is present, I would like spaCy to treat the substring as a token, regardless of any other rules it has. I would like to keep all other rules intact. Is this possible?

To provide a concrete example, suppose the substring of interest is 'banana'; I want 'I like bananabread.' to be tokenized as ['I', 'like', 'banana', 'bread', '.'].

Where do I go from here (keeping in mind that I would like to keep the rest of the tokenizer rules intact)? I have tried adding 'banana' to the prefixes, suffixes, and infixes, with no success.","Adding the string as a prefix, suffix, and infix should work, but depending on which version of spacy you're using, you may have run into a caching bug while testing. This bug is fixed in v2.2+.

With spacy v2.3.2:

(In v2.1 or earlier, the tokenizer customization still works on a newly loaded nlp, but if you've already processed some texts with the nlp pipeline and then modify the settings, the bug was that it would use the stored tokenization from the cache rather than the new settings.)",active developer community,The clear and helpful answer suggests an active developer community that is knowledgeable about the library and eager to help with issues.,,1,C20230706014942549445,0.587240815,0.430591732,0.555307984,0.430601418,0.467771173,0.706026018,0.771749616,0.690870225,0.620515823,0.86249733,0.826892018,0.807093203,0.606476128,0.588552475,0.598643482,0.378699899,0.430814326,0.526619077,0.832898796,0.592925489,0.586359859,0.662604094,0.611985981,0.767851651,38active developer community
95,27,Spacy,Performance,fast,Performance aspect,48199353,How to use spacy in large dataset with short sentences efficiently?,"I choose spacy to process kinds of text because of the performance of it's lemmatation compared with nltk. But When I process millions short text, it always consumed all of my memory(32G) and crashed. Without it just a few minutes and less than 10G mem is consumed.

Is something wrong with the usage of this method? is there any better solution to improve the performance? Thanks!","You can use multithreading in spacy to create a fast tokenization and data ingestion pipeline.

Rewriting your code block and functionality using the nlp.pipe method would look something like this:
This way puts all your filtering into the token_filter function, which takes in a spacy token and returns True only if it is not punctuation, a space, a stopword, and 4 or less characters. Then, you use this function as you pass through each token in each document, where it will return the lemma only if it meets all of those conditions. Then, filtered_tokens is a list of your tokenized documents.

Some helpful references for customizing this pipeline would be:

Token attributes
Language.pipe",spacy performance issues,"Spacy struggles with large datasets of short sentences, causing high memory consumption and system crashes.",,1,C20230706014918530804,0.757725179,0.769643426,0.844342053,0.707932591,0.596286178,0.666839778,0.425871581,0.575817406,0.785776138,0.658035278,0.606541812,0.69699806,0.722227931,0.795874298,0.705670238,0.721513152,0.514593065,0.553928733,0.581094682,0.541630268,0.742665708,0.684769928,0.651398182,0.448450804,27spacy performance issues
301,89,Spacy,Feature,Entity linking,Entity linking feature,59050554,Error running Spacy entity linking example,"I was trying the entity linking example in spacy.
Using this example to train the entity linker and generating the knowledge base for the same with this example.

I can create a knowledge base with the available en_core_web_md, this is the output for the same.
When I try to train the entity linker with the knowledge base from above, I get this error.
File ""pipes.pyx"", line 1219, in spacy.pipeline.pipes.EntityLinker.update
I did follow the instructions specified here. I used the en_core_web_md to create the knowledge base since I do not have a pre-trained model.

I did not write any custom code just trying to run this example, Can someone point me to the right direction.
","This was asked and answered in the following issue on spaCy's GitHub.

It looks like the script no longer worked after a refactor of the entity linking pipeline as it now expects either a statistical or rule-based NER component in the pipeline.

The new script adds such an EntityRuler to the pipeline as an example. I.e.,

# Add a custom component to recognize ""Russ Cochran"" as an entity for the example training data.
# Note that in a realistic application, an actual NER algorithm should be used instead.
ruler = EntityRuler(nlp)
patterns = [{""label"": ""PERSON"", ""pattern"": [{""LOWER"": ""russ""}, {""LOWER"": ""cochran""}]}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, this can be replaced with your own statistical NER model.",customization may be needed,"To use entity linking in Spacy, users may need to customize the pipeline according to their specific needs.",,1,C20230706015223129651,0.704536676,0.726608098,0.58768779,0.823537111,0.426986724,0.45866856,0.721870303,0.6958161,0.713275731,0.843024254,0.744264066,0.798080564,0.752450824,0.742765486,0.547482729,0.952175021,0.476020694,0.474806905,0.630620241,0.640015662,0.552336395,0.805412233,0.609128714,0.636022151,89customization may be needed
46,13,Spacy,Documentation,documentation,Documentation aspect,74550422,Concatenate two spacy docs together?,"How do I concatenate two spacy docs together? To merge them into one?

import spacy

nlp = spacy.load('en')
doc1 = nlp(u'This is the doc number one.')
doc2 = nlp(u'And this is the doc number two.')
new_doc = doc1+doc2
Of course that will return an error as a doc object is not concatenable by default. Is there a straightforward solution to do that?

I looked at this: https://github.com/explosion/spaCy/issues/2229 The issue seems closed so it sounds like they have implemented a solution but I cannot find a simple example of that being used.","What about this:
For ""a lot"" of different sentences, it might be better to use nlp.pipe as shown in the documentation.

Hope it helps.",suggestion for official documentation,The answer suggests that the official Spacy documentation might contain more comprehensive information on the topic of concatenating Spacy docs.,No answer available against the challenge,0,C20230706014423300535,0.359941274,0.78744626,0.725637197,0.733984768,0.77613622,0.928123772,0.361223817,0.593065917,0.517407835,0.329451233,0.359576702,0.85444361,0.467862099,0.498177886,0.571873009,0.3031829,0.382215321,0.581769109,0.585220814,0.632208347,0.608088851,0.568300009,0.593360901,0.895882249,13suggestion for official documentation
63,18,Spacy,Documentation,documentation,Documentation aspect,68083466,How to use spacy train to add entities to an existing custom NER model? (Spacy v3.0),"I am currently implementing a custom NER model interface where a user can interact with a frontend application to add custom entities to train a spacy model.

I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.

For example, let's say I have a model that is already trained for a custom entity of FOOD. (Pizza, Pasta, Bread, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ). Now I want to take this existing model, and train it for a new entity called DRINKS with keywords like Coca-Cola, Pepsi, Juice, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ Using spacy train command for spacy v3.0.

The spacy train command that I am using currently is as follows:

> python -m spacy train config.cfg --output ./output --paths.train ./train.spacy --paths.dev ./train.spacy
I load the model for prediction using:

> nlp1 = spacy.load(R"".\output\model-best"")
As of now, I was training the model for new entities manually. Below is the code to find keywords in my training data and output a JSON format for training data (old format).","""I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.""
What you are describing is called ""online learning"" and the default spaCy models don't support it. Most modern neural NER methods, even outside of spaCy, have no support for it at all.

You cannot fix this by using a custom training loop.

Your options are to use rule-based matching, so you can only match things explicitly in a list, or to retrain models on the fly.

Rule-based matching should be easy to set up but has the obvious issue that it can't learn things not explicitly in the list.

Training things on the fly may sound like it'll take too long, but you can train a small model quite quickly. What you can do is train a small model for a small number of iterations while the user is working interactively, and after they've confirmed the model is more or less working correctly you can use the same training data for a larger model with longer training.",options: rule-based matching,Rule-based matching is an option for adding new entities by explicitly matching things in a predefined list.,wrong labeling,1,C20230706014827071956,0.564762473,0.708443105,0.605461061,0.702205718,0.684631705,0.778687775,0.733139932,0.70988214,0.629095078,0.902512789,0.662691414,0.713121057,0.577622235,0.517186284,0.642175615,0.650611162,0.593811929,0.620251179,0.601399004,0.557576954,0.670248151,0.818805158,0.791850209,0.857404649,18options: rule-based matching
73,21,Spacy,Performance,performance,Performance aspect,48169545,Does spacy take as input a list of tokens?,"I would like to use spacy's POS tagging, NER, and dependency parsing without using word tokenization. Indeed, my input is a list of tokens representing a sentence, and I would like to respect the user's tokenization. Is this possible at all, either with spacy or any other NLP package ?

For now, I am using this spacy-based function to put a sentence (a unicode string) in the Conll format:
I would like to do the same while having as input a list of tokens...","You can run Spacy's processing pipeline against already tokenised text. You need to understand, though, that the underlying statistical models have been trained on a reference corpus that has been tokenised using some strategy and if your tokenisation strategy is significantly different, you may expect some performance degradation.

Here's how to go about it using Spacy 2.0.5 and Python 3. If using Python 2, you may need to use unicode literals.",processing pipeline,The processing pipeline can be run against already tokenized text in Spacy.,wrong labeling,1,C20230706014905472280,0.740854919,0.607114553,0.753833115,0.790928245,0.735553503,0.79493016,0.584652841,0.673478007,0.632063389,0.865280807,0.851271033,0.826594889,0.571770489,0.505580544,0.586582541,0.696764231,0.660787761,0.884200871,0.451577693,0.572967947,0.559817612,0.509741426,0.540001929,0.908578813,21processing pipeline
78,23,Spacy,Performance,performance,Performance aspect,72413618,How can I make it so that I process each sentence to look for and replace with a synonym for the words that match?,"I am currently working with spacy and have a corpus (containing 960,256 words) that looks like this:
I have a function that looks for the synonym of a word (using spacy):

Which returns an array of answers like so:
What I want is to grab the corpus, feed it sentence by sentence and word by word to most_similar so I can save the list of words to replace and do so by using replace_wordthe thing is that I'm not sure how to do this. I've tried for a while but it always fails somehow (either won't take batches so I can't do it at once, the words end up being empty vectors if I simply split each sentence by .split("" "") so...could you help me out please?","I hope I understood what you need correctly. I'm guessing you want to:

Iterate over a corpus
Find specific tokens using the matcher
Find synonyms of the matched tokens
Return a new list of sentences but with the replaced tokens.
If that's the case then what you need is a valid similarity function (I tried the one above but it didn't work for me properly) but you can try this:
You also mentioned that you want this to run on a corpus. I recommend that you use the nlp.pipe() method for performance gains combined with the set_extension method. You can do it like this:",extension with set_extension,User mentions using set_extension to further optimize the nlp.pipe() method.,,1,C20230706014911568190,0.708173513,0.570922136,0.478185713,0.928805232,0.582760394,0.58793205,0.754192412,0.612793267,0.64231807,0.801876724,0.781664491,0.760026753,0.681394815,0.558779478,0.657638371,0.697540641,0.581225097,0.725529552,0.697067022,0.659119487,0.611524701,0.768809497,0.672315001,0.770273268,23extension with set_extension
117,34,Spacy,Stability,bug,Stability aspect,42215762,How to get Spacy to tokenize am/pm expressions correctly?,"Spacy seems unable to correctly tokenize am/pm expressions where the number and the am/pm part is not separated by whitespace.

Example: ""Something happened at 9am"" produces an unexpected token set: List of Token objects: [Something, happened, at, LIKE_URL, am]

While ""Something happened at 9 am"" works just fine: List of Token objects: [Something, happened, at, 9, am]

I notice that if you drill down into the Token object, the 'orth' representation of the token is a 9. Likewise, if I try '8am', the token reads 'IS_UPPER' and the 'orth' representation of the token is 8.

In particular this is a problem for me because I need to track token spans accross a wider context, and a token that shows up as ""8"" in the text but ""IS_UPPER"" in token form causes my spans to be off by 7. (IE the actual document-level index (token.idx) of the next token is off by 7)

How can I process a document with spacy that contains am/pm expressions sometimes denoted in the format described above, and retrieve accurate token spans?

I'm using Python 2.7.12 with Spacy 1.4.0","Turns out, this was reported as a bug about a month ago: https://github.com/explosion/spaCy/issues/736

Upgrading to Spacy 1.6.0 resolves the issue.",active community,"The bug was reported and fixed within a month, indicating an engaged user base.",,0,C20230706014933601721,0.671123326,0.661594391,0.424308211,0.76315248,0.71113807,0.874554336,0.746521831,0.675643921,0.631561816,0.750604808,0.653744698,0.649666071,0.484241217,0.72927314,0.496967614,0.465145677,0.551786959,0.618231595,0.640081227,0.587982178,0.712161481,0.6797176,0.754014611,0.555563331,34active community
328,97,Spacy,Feature,Text classification,Text classification feature,62092445,Is it possible to improve spaCy's similarity results with custom named entities?,"I've found that spaCy's similarity does a decent job of comparing my documents using ""en_core_web_lg"" out-of-the-box.

I'd like to tighten up relationships in some areas and thought adding custom NER labels to the model would help, but my results before and after show no improvements, even though I've been able to create a test set of custom entities.

Now I'm wondering, was my theory completely wrong, or could I simply be missing something in my pipeline?

If I was wrong, what's the best approach to improve results? Seems like some sort of custom labeling should help.","I found my solution was nestled in this tutorial: Text Classification in Python Using spaCy, which generates a BoW matrix for spaCy's text data by using SciKit-Learn's CountVectorizer.

I avoided sentiment analysis tutorials, due to binary classification, since I need support for multiple categories. The trick was to set multi_class='auto' on the LogisticRegression linear model, and to use average='micro' on the precision score and precision recall, so all my text data, like entities, were leveraged:

classifier = LogisticRegression(solver='lbfgs', multi_class='auto')
and...

print(""Logistic Regression Accuracy:"",metrics.accuracy_score(y_test, predicted))
print(""Logistic Regression Precision:"",metrics.precision_score(y_test, predicted,average='micro'))
print(""Logistic Regression Recall:"",metrics.recall_score(y_test, predicted,average='micro'))
Hope this helps save someone some time!",custom named entities,SpaCy supports custom named entities for text classification.,,1,C20230706015236572187,0.533026755,0.429081231,0.527006626,0.837372243,0.731356621,0.722216964,0.353848666,0.380964339,0.334915191,0.706344724,0.814393401,0.725834131,0.622773767,0.547469258,0.631599486,0.396798551,0.921659172,0.436547101,0.417722195,0.385008514,0.33041358,0.807996869,0.782705247,0.835549891,97custom named entities
163,47,Spacy,Stability,version,Stability aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",community involvement,"The existence of a community of Spacy users who are active in developing and improving its functionality indicates that it is a reliable, stable, and efficient library for natural language processing.",Confidently wrong inference,0,C20230706015001398195,0.666873157,0.614232779,0.519325316,0.819883823,0.701556981,0.633924961,0.965121329,0.860559464,0.798169196,0.834578395,0.769258916,0.740080297,0.559396625,0.693784952,0.567075014,0.717707574,0.889777958,0.692594111,0.747604728,0.830834627,0.629788816,0.880695164,0.708969533,0.717582643,47community involvement
318,93,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,51725599,training sentence tokenizer in spaCy,"I'm trying to tokenize sentences using spacy.

The text includes lots of abbreviations and comments which ends with a period. Also, the text was obtained with OCR and sometimes there are line breaks in the middle of sentences. Spacy doesn't seem to be performing so well in these situations.

I have extracted some examples of how I want these sentences to be split. Is there any way to train spacy's sentence tokenizer?","Spacy is a little unusual in that the default sentence segmentation comes from the dependency parser, so you can't train a sentence boundary detector directly as such, but you can add your own custom component to the pipeline or pre-insert some boundaries that the parser will respect. See their documentation with examples: Spacy Sentence Segmentation

For the cases you're describing it would potentially be useful also be able to specify that a particular position is NOT a sentence boundary, but as far as I can tell that's not currently possible.",no specific non-boundary option,There is no current support for specifying a position as NOT a sentence boundary.,No answer available against the challenge,1,C20230706015231327911,0.776418388,0.731219113,0.753874898,0.783282042,0.816635549,0.896312952,0.522184491,0.737882972,0.597798347,0.601218224,0.589198709,0.787937164,0.743093133,0.691150427,0.494791448,0.481196463,0.655786753,0.621386766,0.483323872,0.498352587,0.511651039,0.619889021,0.633697748,0.809581637,93no specific non-boundary option
151,43,Spacy,Stability,backwards compatibility,Stability aspect,54201004,Multithreading with spacy: Is joblib necessary?,"In this part of the documentation, it is mentioned that nlp.pipe() works in parallel and the following example is given:

for doc in nlp.pipe(texts, batch_size=10000, n_threads=3):
    pass
After that, another, longer example is given that makes use of joblib. I don't quite understand the relationship between the two. As I understand the documentation, if I simply want to parallelize the tokenisation of many documents, the above, simple for loop will work and I do not have to use joblib, right?

My pipeline looks like this:

nlp = spacy.load('en', disable=['parser', 'ner', 'textcat'])
When would I need to use joblib?","Based on an answer in Spacy github issues:

We kept the n_threads argument to avoid breaking people's code, but unfortunately the implementation doesn't currently release the GIL, the way we did in v1. In v2 the neural network model is more complicated and more subject to change, so we haven't implemented it in Cython. We might at a later date.

In v2.1.0 (you can get an alpha by installing spacy-nightly, the matrix multiplications are now single-threaded. This makes it safe to launch multiple processes for the pipeline, so we can look at doing that internally. In the meantime, the n_threads argument sits idle...Which I agree is confusing, but removing it and breaking backwards compatibility seems worse.
Thus, to summarize: n_threads doesn't work in v2.1. What I'm doing now is using Spacy with joblib to read a dataset in minibatches.

Spacy released an example for that: Spacy Multiprocessing, and it works perfectly.

I have a dataset with almost ~4M short text. Without using the example they released, it took almost 23 hours to finish parsing them, but using joblib with spacy, it took 1 hour and half to finish!

To reference the readers of this question to Spacy Multiprocessing example: Spacy Multiprocessing",limited stability,"Spacy's multithreading functionality is not as stable as it could be, with the n_threads argument not releasing the GIL in version 2.",Question not focused on main topic,0,C20230706014951416605,0.436163068,0.406471312,0.336870998,0.606069565,0.695515752,0.710232437,0.48575893,0.527407587,0.674363017,0.52514708,0.546492994,0.776329339,0.543247581,0.557943702,0.338283569,0.773750305,0.810886264,0.853554606,0.442082494,0.663193941,0.507034838,0.667664468,0.511382163,0.685447991,43limited stability
113,32,Spacy,Performance,speed,Performance aspect,57697374,List most similar words in spaCy in pretrained model,"With Gensim, after I've trained my own model, I can use model.wv.most_similar('cat', topn=5) and get a list of the 5 words that are closest to cat in the vector space. For example:

With spaCy, as per the documentation, I can do:

which gives similarity for tokens in a specified string. But combing through the docs and searching, I can't figure out if there is a gensim-type way of listing all similar words for a preloaded model with either nlp = spacy.load('en_core_web_lg') or nlp = spacy.load('en_vectors_web_lg'). Is there a way to do this?","I used Andy's response and it worked correctly but slowly. To resolve that I took the approach below.

SpaCy uses the cosine similarity, in the backend, to compute .similarity. Therefore, I decided to replace word.similarity(w) with its optimized counterpart. The optimized method that I worked with was cosine_similarity_numba(w.vector, word.vector), shown below, that uses the Numba library to speed up computations. You should replace line 12 in the most_similar method with the line below.
The method became 2-3 times faster which was essential for me.
I explained it in more details in this article: How to Build a Fast ‚Äö√Ñ√∂‚àö√ë‚àö‚à´Most-Similar Words‚Äö√Ñ√∂‚àö√ë‚àöœÄ Method in SpaCy",optimization method suggested,The respondent suggests using a faster optimization method for the cosine similarity calculation to improve the speed of similarity computation.,,1,C20230706014930968323,0.553614438,0.483640641,0.548687816,0.626941085,0.600786865,0.486811191,0.581592262,0.664209962,0.584901989,0.868391931,0.527321756,0.588765621,0.704960287,0.643181264,0.488505185,0.521199763,0.59164983,0.469443947,0.669839859,0.624937236,0.643444896,0.669648468,0.755248666,0.716442645,32optimization method suggested
31,9,Spacy,Documentation,documentation,Documentation aspect,52855178,Discrepancy documentation and implementation of spaCy vectors for German words?,"According to documentation:

spaCy's small models (all packages that end in sm) don't ship with word vectors, and only include context-sensitive tensors. [...] individual tokens won't have any vectors assigned.
But when I use the de_core_news_sm model, the tokens Do have entries for x.vector and x.has_vector=True.

It looks like these are context_vectors, but as far as I understood the documentation only word vectors are accessible through the vector attribute and sm models should have none. Why does this work for a ""small model""?","has_vector behaves differently than you expect.

This is discussed in the comments on an issue raised on github. The gist is, since vectors are available, it is True, even though those vectors are context vectors. Note that you can still use them, eg to compute similarity.

Quote from spaCy contributor Ines:

We've been going back and forth on how the has_vector should behave in cases like this. There is a vector, so having it return False would be misleading. Similarly, if the model doesn't come with a pre-trained vocab, technically all lexemes are OOV.
Version 2.1.0 has been announced to include German word vectors.",inclusion of german word vectors,"Beginning with version 2.1.0, Spacy will include German word vectors.",No answer available against the challenge,1,C20230706014343950832,0.754253864,0.79442209,0.695829868,0.6580652,0.721414208,0.783801258,0.668114364,0.464597076,0.933892012,0.421160281,0.673312962,0.548621535,0.660676956,0.601278126,0.675488949,0.749773204,0.740022779,0.89824748,0.70330745,0.555008113,0.599844098,0.625864387,0.62568152,0.656398714,9inclusion of german word vectors
67,19,Spacy,Performance,performance,Performance aspect,58724562,When creating a Doc using the standard constructor the model is not loaded ,"I'm trying to use SpaCY and instantiate the Doc object using the constructor:
but when I do that, if I try to use the dependency parser:
I get the error:

ValueError: [E029] noun_chunks requires the dependency parse, which requires a statistical model to be installed and loaded. For more info, see the documentation:
While if I use the method nlp(""Hello world!"") that does not happens.

The reason I do that, is because I use the entity extraction from a third party application I want to supply to SpaCy my tokenisation and my entities.
What should I do? load the pipeline by myself in the document, and exclude the tokeniser for example?","nlp() returns a Doc where the tokenizer and all the pipeline components in nlp.pipeline have been applied to the document.

If you create a Doc by hand, the tokenizer and the pipeline components are not loaded or applied at any point.

After creating a Doc by hand, you can still apply individual pipeline components from a loaded model:

nlp = spacy.load('en_core_web_sm')
nlp.tagger(doc)
nlp.parser(doc)
Then you can add your own entities to the document. (Note that if your tokenizer is very different from the default tokenizer used when training a model, the performance may not be as good.)",tokenizer differences can affect performance,"If the tokenizer used to create a Doc object in Spacy differs significantly from the default tokenizer used when training the model, its performance may be negatively affected, resulting in suboptimal performance.",,0,C20230706014830146637,0.710862517,0.764825404,0.779893458,0.738938808,0.817379236,0.744529724,0.799117863,0.846096516,0.712542474,0.737699509,0.834088206,0.71747148,0.571836054,0.56914717,0.712364972,0.532023847,0.614634752,0.819832563,0.649184585,0.779569387,0.675546646,0.515133262,0.877386212,0.567093015,19tokenizer differences can affect performance
289,85,Spacy,Feature,NER,NER feature,65220447,Add new named entity to Spacy's en_core_web_sm model?,"I'm following the example here on training a new entity type:

https://spacy.io/usage/training#example-new-entity-type

It works fine when I don't pass an existing model to it, and will correctly create a new model, which recognizes my new named entity e.g.

 python.exe train-new-entity-type.py
It also works fine when I pass an existing model to it (created by running it once before), and will correctly load the model in the dir/my_model dir, which still recognizes my new named entity e.g.

 python.exe train-new-entity-type.py -m dir/my_model
However, I want to train a new entity type, and add that to spacy's existing model, so that spacy will recognize it's own supported named entities as well as my new entity type, so I tried:

 python.exe train-new-entity-type.py -m en_core_web_sm
However, this didn't seem to work. Spacy's own supported named entities were recognized but they were not correct (vs just using the en_core_web_sm on its own without adding my new entity type to it), and my new entity type was no longer recognized at all.

Am I doing something wrong? Is this possible (adding named entities to en_core_web_sm)?","Read about the ""catastrophic forgetting"" problem when updating an existing model: https://spacy.io/usage/training#ner

It can be tricky to update an existing model, so it might be easier to train a separate model for your new entity type and add the NER component to the en_core_web_sm pipeline with a custom name. The main thing to watch out for is that you need to make sure the models are loaded with the same vocab so that you don't run into problems with the string store:

import spacy
nlp = spacy.load(""en_core_web_sm"")
custom_nlp = spacy.load(""my_model"", vocab=nlp.vocab)
nlp.add_pipe(custom_nlp.get_pipe(""ner""), name=""my_ner"", before=""ner"")
Where you add it in the pipeline (before/after the existing ner) will determine which entity spans have priority, since the ner component won't modify existing entity spans.",catastrophic forgetting problem,Updating an existing model can be difficult due to the 'catastrophic forgetting' problem.,ChatGPT giving out of context response,0,C20230706015143914143,0.437319756,0.713798165,0.347061276,0.738799691,0.642317355,0.775204718,0.354549527,0.803850412,0.526668787,0.573663473,0.836923361,0.671984076,0.330206007,0.563184738,0.518710732,0.458994061,0.442231387,0.571228921,0.379559547,0.579137743,0.471996695,0.817750692,0.902971327,0.800006568,85catastrophic forgetting problem
180,52,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,55852115,Token extension versus matcher versus phrase matcher vs entity ruler in spaCy,"I am trying to figure out the best way (fast) to extract entities, e.g. a month. I have come up with 5 different approaches using spaCy.

Initial setup

For each solution I start with an initial setup
Conclusion

The custom attributes with is limited to single token matching and the token matcher seems to be faster so that seems to be preferable. The EntityRuler seems to be the slowest which isn't surprising since it is changing the Doc.ents. It is however quite convenient that you have your matches in Doc.ents so you might want to consider this method still.

I was quite surprised that the token matcher outperforms the phrase matcher. I thought it would be opposite:

If you need to match large terminology lists, you can also use the PhraseMatcher and create Doc objects instead of token patterns, which is much more efficient overall
Question

Am I missing something important here or can I trust this analysis on a larger scale?","I think ultimately, it all comes down to finding the optimal tradeoff between speed, maintainability of the code and the way this piece of logic fits into the larger picture of your application. Finding a few strings in a text is unlikely to be the end goal of what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® otherwise, you probably wouldn't be using spaCy and would stick to regular expressions. How your application needs to ""consume"" the result of the matching and what the matches mean in the larger context should motivate the approach you choose.

As you mention in the conclusion, if your matches are ""named entities"" by definition, adding them to the doc.ents makes a lot of sense and will even give you an easy way to combine your logic with statistical predictions. Even if it adds slightly more overhead, it'll likely still outperform any scaffolding you'd otherwise have to write around it yourself.",community engagement,"Users seeking guidance on best practices and sharing experiences show a level of community engagement, which can be an indicator of an active and supportive developer community.",Confidently wrong inference,0,C20230706015010684020,0.538580298,0.665333688,0.431467384,0.600604951,0.323555768,0.275001258,0.863184094,0.64219296,0.238231972,0.75919944,0.298948228,0.449712753,0.344230086,0.432304412,0.597661853,0.44938758,0.49596262,0.271807343,0.180880308,0.705842078,0.231656894,0.40616864,0.771442354,0.485289067,52community engagement
147,42,Spacy,Stability,bug,Stability aspect,62737680,Spacy tagger loss is zero while training,"I use this snippet of code to train a tagger in spacy 2.3.0.
The problem is that the loss value is always zero. What am I doing wrong?","Sorry, this is a bug in v2.3.0. It will be fixed in the upcoming v2.3.1. You can train a tagger with spacy train instead or use v2.2.4 in the meanwhile.

If you'd like to have this fix sooner, you can also install from source in the current master branch (the fix is in commit b7107ac8).",bug in v2.3.0,The conversation highlights a specific bug that affects Spacy 2.3.0 and its tagger training functionality.,,1,C20230706014948661418,0.579403818,0.851313353,0.652336478,0.611016631,0.484289497,0.437531501,0.680533409,0.585946441,0.566825509,0.585728884,0.573629797,0.587173939,0.569194496,0.508868754,0.483864933,0.559847295,0.556013167,0.5876894,0.568138182,0.575062752,0.524335265,0.795235634,0.512136757,0.292890668,42bug in v2.3.0
5,2,Spacy,Ease of use,easy,Ease of use aspect,56694713,In spaCy is there a way to extract the sentence the entity has been extracted from?,"considering the following sentence:

""the quick brown fox jumps over the lazy dog""
and if I want to extract brown, extracting only brown is fairly easy to do however I want the following output:

""brown"" , ""the quick brown fox jumps over the lazy dog""","Yes, there is a way to do this in Spacy. You have to iterate over the entity Span objects and extract the sentence from each Span object. Here is an example:

    doc = nlp(""John and Claire live in London. They have a dog. Claire walks her 
    dog everyday."")
    for entity in doc.ents:
       print('Entity extracted : ', entity.text)
       print('Sentence extracted from : ', entity.sent)",not easy for non-programmer,"For someone with limited technical skills or no programming experience, using Spacy for entity and sentence extraction may not be easy.",,0,C20230706014106660748,0.655309439,0.669548333,0.640953779,0.544702768,0.402529448,0.805120289,0.588023245,0.75830245,0.780868709,0.526802957,0.599709809,0.869016469,0.658561587,0.777441859,0.640246451,0.483687162,0.407248914,0.74348402,0.564213932,0.661076307,0.502613902,0.602386773,0.704692066,0.586179852,2not easy for non-programmer
335,98,Spacy,Feature,Rule-based matching,Rule-based matching feature,72346631,Highlight text parts based on labels,"thanks to fellow stackoverflowrians I have data labels that I would like to high light in the text:

eg. I have product description

Description: Tampered black round grey/natural swing with yellow load-bearing left hook
Features were extracted as

colors=['black','grey','natural','yellow']
shape = ['round']
direction= ['left']
In Spacy it is possible to highlight the features like this

enter image description here

Is there any possibility to highlight it also like this from the data I have as labels? So that I have labels shown in the text too? I dont know if Spacy is the good tool or any other is better?
","I'm not entirely sure what you're asking, but you can put entities of your own on the spaCy Doc object and pass them to Displacy.

To simply set entities manually, you can do this:

doc = nlp(...)
span = doc[0:1] # whatever span of the doc you want to highlight
span.ent_label_ = ""COLOR"" # the label you want
ents = [span] # in reality you could do more than one
doc.ents = ents
If you have word list and need to look for words, you can use rule-based matching with an EntityRuler. Check the rule-based matching guide.",using an entityruler,"An EntityRuler can be used with rule-based matching to look for specific words in the text, according to the answer.",Question not focused on main topic,1,C20230706015239715046,0.817878187,0.686148465,0.766193628,0.741952479,0.594452858,0.547411144,0.829679072,0.696631551,0.616049767,0.71574986,0.643273711,0.707207143,0.537780046,0.606531501,0.70868063,0.910605907,0.465464145,0.483840197,0.686812341,0.643161952,0.604890585,0.794109166,0.540156007,0.651623011,98using an entityruler
124,36,Spacy,Stability,bug,Stability aspect,62796437,Spacy French langage gives NoneType error,"Here is the code :

import spacy
nlp = spacy.load('fr_core_news_sm')
doc = nlp('Demain je travaille ‚Äö√†√∂‚Äö√Ñ‚Ä† la maison')
for token in doc:
    print(token.text)
It gives the error :

File ""c:\users\ab\appdata\local\programs\python\python37\lib\site-packages\spacy\lang\fr\lemmatizer.py"", line 49, in call if self.is_base_form(univ_pos, morphology): TypeError: 'NoneType' object is not callable
If I change 'fr_core_news_sm' to 'en_core_web_sm', it works well.

My python version is 3.7.7. And Spacy version is 2.3.1.","This seems to be a bug at spaCy 2.3.1: https://github.com/explosion/spaCy/issues/5728

Downgrade to 2.3.0 and it should work: pip install spacy==2.3.0",buggy version,The issue with spaCy French language module that resulted in a NoneType error indicates that the library is not entirely free from bugs.,,1,C20230706014936732650,0.62474227,0.656143129,0.538960755,0.302289963,0.643255234,0.428082585,0.373864055,0.569784939,0.682218671,0.547677159,0.44993335,0.450838059,0.84408778,0.617500186,0.421348155,0.415990353,0.392079353,0.263523191,0.433708727,0.530623198,0.598755419,0.318819284,0.457344919,0.777401984,36buggy version
47,14,Spacy,Documentation,documentation,Documentation aspect,57206701,Spacy tokenizer rule for exceptions that contain whitespace?,"When I create a pipeline with the default tokenizer for say English, I can then call the method for adding a special case:

tokenizer.add_special_case(""don't"", case)
The tokenizer will happily accept a special case that contains whitespace:

tokenizer.add_special_case(""some odd case"", case)
but it appears that does not actually change the behavior of the tokenizer or will never match?

More generally, what is the best way of extending an existing tokenizer so that the some patterns which normally would result in multiple tokens only create one token? For example something like [A-Za-z]+\([A-Za-z0-9]+\)[A-Za-z]+ should not result in three tokens because of the parentheses but in a single token, e.g. for asdf(a33b)xyz while the normal English rules should still apply if that pattern does not match.

Is this something that can be done somehow by augmenting an existing tokenizer or would I have to first tokenize, then find entities that match the corresponding token patterns and then merge the entity tokens?","As you found, Tokenizer.add_special_case() doesn't work for handling tokens that contain whitespace. That's for adding strings like ""o'clock"" and "":-)"", or expanding e.g. ""don't"" to ""do not"".

Modifying the prefix, suffix and infix rules (either by setting them on an existing tokenizer or creating a new tokenizer with custom parameters) also doesn't work since those are applied after whitespace splitting.

To override the whitespace splitting behavior, you have four options:

Merge after tokenization. You use Retokenizer.merge(), or possibly merge_entities or merge_noun_chunks. The relevant documentation is here: https://spacy.io/usage/linguistic-features#retokenization and https://spacy.io/api/pipeline-functions#merge_entities and https://spacy.io/api/pipeline-functions#merge_noun_chunks

This is your best bet for keeping as much of the default behavior as possible.
Subclass Tokenizer and override __call__. Sample code:

Implement a completely new tokenizer (without subclassing Tokenizer). Relevant docs here: https://spacy.io/usage/linguistic-features#custom-tokenizer-example
Tokenize externally and instantiate Doc with words. Relevant docs here: https://spacy.io/usage/linguistic-features#own-annotations
To answer the second part of your question, if you don't need to change whitespace splitting behavior, you have two other options:

Add to the default prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizer-additions

Note from https://stackoverflow.com/a/58112065/594211: ""You can add new patterns without defining a custom tokenizer, but there's no way to remove a pattern without defining a custom tokenizer.""
Instantiate Tokenizer with custom prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizers

To get the default rules, you read the existing tokenizer's attributes (as shown above) or use the nlp object‚Äö√Ñ√∂‚àö√ë‚àö¬•s Defaults. There are code samples for the latter approach in https://stackoverflow.com/a/47502839/594211 and https://stackoverflow.com/a/58112065/594211.",modify rules for patterns,"The answer suggests to add to the default prefix, suffix, and infix rules or instantiate the tokenizer with custom rules to handle cases where multiple tokens are generated from a pattern.",Too large question and answer,1,C20230706014426412517,0.569619775,0.819837451,0.69175142,0.657937944,0.731151938,0.826257527,0.565978944,0.833004236,0.794119954,0.584796846,0.484558046,0.678813696,0.439596623,0.629852057,0.568366945,0.530111551,0.893534958,0.534260869,0.624566615,0.756391108,0.755908608,0.78205204,0.684614241,0.808612406,14modify rules for patterns
51,15,Spacy,Documentation,documentation,Documentation aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",example code provided,The documentation provides an example code that shows how to load a Spacy model and process multiple documents in parallel.,,0,C20230706014427470367,0.700230896,0.627308607,0.626261175,0.604892135,0.554026604,0.691924572,0.489608407,0.735627413,0.718611896,0.517550349,0.568409979,0.73161906,0.585157037,0.682086766,0.932015419,0.424244165,0.570921242,0.593967199,0.32912758,0.680700243,0.660764813,0.598448157,0.394713044,0.601005137,15example code provided
77,22,Spacy,Performance,performance,Performance aspect,57049798,Can we find sentences around an entity tagged via NER?,"We have a model ready which identifies a custom named entity. The problem is if the whole doc is given then the model does not work as per expecation if only a few sentences are given, it is giving amazing results.

I want to select two sentences before and after a tagged entity.

eg. If a part of the doc has world Colombo(which is tagged as GPE), I need to select two sentences before the tag and 2 sentences after the tag. I tried a couple of approaches but the complexity is too high.

Is there a built-in way in spacy with which we can address this problem?

I am using python and spacy.

I have tried parsing the doc by identifying the index of the tag. But that approach is really slow.","It might be worth it to see if you can improve the custom named entity recognizer, because it should be unusual for extra context to hurt performance and potentially if you fix that issue it will work better overall.

However, regarding your concrete question about surrounding sentences:

A Token or a Span (an entity is a Span) has a .sent attribute that gives you the covering sentence as a Span. If you look at the tokens right before/after a given sentence's start/end tokens, you can get the previous/next sentences for any token in a document.",previous approach slow,The previous approach of parsing the document by identifying the index of tags is slow.,,0,C20230706014908964762,0.777076662,0.742330968,0.854877055,0.643206358,0.716130555,0.870096624,0.77225095,0.634418845,0.744365871,0.744085312,0.860674143,0.862902284,0.679079294,0.442108393,0.564708114,0.610814989,0.557429552,0.472810417,0.72772181,0.687285185,0.744330466,0.621952355,0.772484422,0.507593453,22previous approach slow
314,92,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,56416641,separate texts into sentences NLTK vs spaCy,"I want to separate texts into sentences.

looking in stack overflow I found:

WITH NLTK

from nltk.tokenize import sent_tokenize
text=""""""Hello Mr. Smith, how are you doing today? The weathe is great, and city is awesome. The sky is pinkish-blue. You shouldn't eat cardboard""""""
tokenized_text=sent_tokenize(text)
print(tokenized_text)
WITH SPACY

from spacy.lang.en import English # updated

raw_text = 'Hello, world. Here are two sentences.'
nlp = English()
nlp.add_pipe(nlp.create_pipe('sentencizer')) # updated
doc = nlp(raw_text)
sentences = [sent.string.strip() for sent in doc.sents]
The question is what in the background for spacy having to do it differently with a so called create_pipe. Sentences are important for training your own word embedings for NLP. There should be a reason why spaCy does not include directly out of the box a sentence tokenizer.

Thanks.

NOTE: Be aware that a simply .split(.) does not work, there are several decimal numbers in the text and other kind of tokens containing '.'","By default, spaCy uses its dependency parser to do sentence segmentation, which requires loading a statistical model. The sentencizer is a rule-based sentence segmenter that you can use to define your own sentence segmentation rules without loading a model.

If you don't mind leaving the parser activated, you can use the following code:

import spacy
nlp = spacy.load('en_core_web_sm') # or whatever model you have installed
raw_text = 'Hello, world. Here are two sentences.'
doc = nlp(raw_text)
sentences = [sent.text.strip() for sent in doc.sents]",reasons for lack of direct tokenizer,Spacy is designed for more advanced NLP tasks and assumed users could create a tokenizer using sentencizer or external tools like NLTK.,,0,C20230706015229757819,0.53509587,0.656248629,0.45127967,0.642290115,0.664255679,0.569483578,0.583558083,0.76389581,0.626372516,0.753756166,0.771502137,0.73724705,0.600690544,0.710563004,0.540803909,0.797782362,0.625760198,0.452282697,0.559668481,0.596491396,0.558159471,0.735075772,0.7585814,0.845615625,92reasons for lack of direct tokenizer
118,34,Spacy,Stability,bug,Stability aspect,42215762,How to get Spacy to tokenize am/pm expressions correctly?,"Spacy seems unable to correctly tokenize am/pm expressions where the number and the am/pm part is not separated by whitespace.

Example: ""Something happened at 9am"" produces an unexpected token set: List of Token objects: [Something, happened, at, LIKE_URL, am]

While ""Something happened at 9 am"" works just fine: List of Token objects: [Something, happened, at, 9, am]

I notice that if you drill down into the Token object, the 'orth' representation of the token is a 9. Likewise, if I try '8am', the token reads 'IS_UPPER' and the 'orth' representation of the token is 8.

In particular this is a problem for me because I need to track token spans accross a wider context, and a token that shows up as ""8"" in the text but ""IS_UPPER"" in token form causes my spans to be off by 7. (IE the actual document-level index (token.idx) of the next token is off by 7)

How can I process a document with spacy that contains am/pm expressions sometimes denoted in the format described above, and retrieve accurate token spans?

I'm using Python 2.7.12 with Spacy 1.4.0","Turns out, this was reported as a bug about a month ago: https://github.com/explosion/spaCy/issues/736

Upgrading to Spacy 1.6.0 resolves the issue.",limitations and bugs,It's important to thoroughly test and evaluate Spacy or any software before using it in critical applications.,ChatGPT giving out of context response,0,C20230706014934625308,0.721666753,0.711137772,0.660055637,0.395961821,0.537893951,0.521307409,0.575908542,0.617607355,0.763870895,0.450656354,0.654366493,0.623163521,0.431778759,0.682428122,0.458556473,0.283446789,0.518436909,0.293722808,0.570379794,0.515073895,0.658306062,0.600830317,0.610711277,0.593543231,34limitations and bugs
4,2,Spacy,Ease of use,easy,Ease of use aspect,56694713,In spaCy is there a way to extract the sentence the entity has been extracted from?,"considering the following sentence:

""the quick brown fox jumps over the lazy dog""
and if I want to extract brown, extracting only brown is fairly easy to do however I want the following output:

""brown"" , ""the quick brown fox jumps over the lazy dog""","Yes, there is a way to do this in Spacy. You have to iterate over the entity Span objects and extract the sentence from each Span object. Here is an example:

    doc = nlp(""John and Claire live in London. They have a dog. Claire walks her 
    dog everyday."")
    for entity in doc.ents:
       print('Entity extracted : ', entity.text)
       print('Sentence extracted from : ', entity.sent)",iterating over entity spans,"To extract the sentence an entity has been extracted from, one needs to iterate over entity Span objects and extract each sentence from them.",,1,C20230706014106131529,0.730259657,0.81566596,0.747686028,0.781835735,0.740851343,0.897550464,0.846983373,0.833966255,0.77066642,0.802804708,0.784287393,0.795430481,0.602903664,0.705096185,0.802796781,0.566568971,0.730570674,0.563751936,0.778020918,0.758646905,0.566132128,0.709871948,0.576652646,0.634527385,2iterating over entity spans
205,61,Spacy,Security,leak,Security aspect,58956171,"Dataflow job failed after more than 6 hours with ""The worker lost contact with the service""?","I am using Dataflow to read data from BigQuery and then do NLP preprocessing using python. I am using Python 3 and SDK 2.16.0. I am using 100 workers (provite IP, private access and Cloud NAT) with workers in europe-west6 and endpoint in europe-west1. The BigQuery tables are in US. Test jobs were working without any issue but when trying to process the full table (32 GB), the job failed after 6h 40 min and it is hard to fully understand what is the underlying error.","After some test and after few plots for monitoring, it was clear that even if the length of the text was the sime the processing time started to augment rapidly (botton right plot)
Then it became clear that the issue was with SpaCy 2.1.8 (memory leak).

Using Spacy 2.2.3 fix the issue. Now the 32 Gb of data are processed in 4h30 without any issue.",cloud nat,Using Cloud NAT further enhances the security by providing a single gateway for internet access from private instances.,,1,C20230706015024313870,0.845419109,0.73971051,0.778003454,0.963341355,0.990486026,0.972201288,0.909409642,0.810473979,0.859942853,0.852231443,0.908038557,0.832445502,0.325822234,0.282676756,0.326146871,0.955147207,0.973213077,0.962215066,0.311436802,0.290950567,0.303009242,0.861662209,0.896805584,0.89973098,61cloud nat
295,86,Spacy,Feature,NER,NER feature,68682465,pattern match issue with SpaCy,"I have the following script using a pattern to match the postcode. However, depending on how I supply the postcode string seems to affect how it is matched.

It would appear that for some reason the first postcode is never matched. In the last example both ""RH5 0XE"" & ""PO01 0IO"" should match, as you can see ""RH5 0XE"" matched in the previous run.

Any ideas on how I can improve the match rate?","Put the entity_ruler before ner in the pipeline so that its matches have priority over the CARDINAL spans from ner, or alternatively you can set it to overwrite overlapping entities with the overwrite_ents setting.",overwrite overlapping entities,Spacy also provides an option to overwrite overlapping entities with the overwrite_ents setting.,,1,C20230706015217693697,0.68842274,0.617504895,0.588353515,0.617179632,0.639771044,0.648310959,0.644759119,0.396955609,0.634232044,0.590120554,0.659974754,0.711092472,0.812107027,0.534944952,0.292585135,0.680982292,0.434883773,0.465650499,0.63545531,0.641706944,0.522777617,0.64137125,0.567594349,0.644308984,86overwrite overlapping entities
246,73,Spacy,Feature,POS,POS tagging feature,47856247,Extract verb phrases using Spacy,I have been using Spacy for noun chunks extraction using Doc.noun_chunks property provided by Spacy. How could I extract verb phrases from input text using Spacy library (of the form 'VERB ? ADV * VERB +' )?,"This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
On how to highlight the verb phrases do check the link below.

Highlight verb phrases using spacy and html

Another Approach:

Recently observed Textacy has made some changes to regex matches. Based on that approach i tried this way.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The cat sat on the mat. He dog jumped into the water. The author is writing a book.'
pattern = [{'POS': 'VERB', 'OP': '?'},
           {'POS': 'ADV', 'OP': '*'},
           {'POS': 'VERB', 'OP': '+'}]
doc = textacy.make_spacy_doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

sat
jumped
writing
I checked the POS matches in this links seems the result is not the intended one.

[https://explosion.ai/demos/matcher][1]

Did anybody try framing POS tags instead of Regexp pattern for finding Verb phrases?",pos tags may be more reliable,"As noted in the answer, using POS tags instead of regex patterns for finding verb phrases may be more reliable and accurate.",,1,C20230706015048042149,0.574157894,0.784361184,0.713164687,0.733469665,0.676855147,0.829772174,0.739233911,0.807999074,0.735847116,0.718148291,0.807362139,0.741288543,0.674880624,0.65557766,0.664839745,0.666934013,0.625145614,0.629380703,0.747091651,0.779024422,0.697817862,0.796272814,0.776538551,0.855199456,73pos tags may be more reliable
169,49,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",active issue tracker,The presence of an issue tracker indicates an active approach to addressing reported issues and ensuring the library operates efficiently.,,0,C20230706015005062066,0.734456301,0.498911887,0.65117979,0.674253345,0.437575281,0.526615262,0.805249393,0.807811677,0.466995418,0.943824172,0.64398253,0.645402431,0.532231629,0.373164415,0.75956136,0.448491633,0.64089644,0.324466258,0.781408727,0.691499174,0.325068057,0.754158378,0.351502359,0.402094007,49active issue tracker
137,39,Spacy,Stability,bug,Stability aspect,75724665,How to maximize performance of spaCy on an M1 Mac (currently much slower than Intel),"I've observed that nlp.pipe is 30-40% slower on my almost brand new M1 Pro Macbook than on my old Macbook Pro from 2017. Most other functions are faster on the M1 by a similar margin, so this is not the performance I would expect.

For a benchmark, I'm running the following code (with scispacy):

My M1 Mac takes over 75 seconds to complete the task, while my 2017 Intel Mac can do it in 46 seconds.

I don't know whether spacy uses numpy, but I installed a fast version of numpy using ABarrier's answer to this question. That made numpy faster, but made no difference for spacy. I'm assuming that somewhere there is an unoptimized binary being used, but I don't know how to figure out what it is.
","Install the package thinc-apple-ops:

pip install thinc-apple-ops
Or through the spacy extra:

pip install 'spacy[apple]'
(The unoptimized package is blis. We'd like to be able to switch to a newer version of BLIS with M1 support, but there are still some open bugs.)",reliability of spacy,The fact that the user is able to run the code successfully on both machines suggests that Spacy is generally reliable.,No answer available against the challenge,0,C20230706014943551055,0.69139576,0.275044233,0.757094622,0.717394412,0.548761129,0.468040317,0.298488796,0.397778243,0.633201122,0.389454514,0.583185017,0.627351165,0.427304149,0.439699769,0.482165903,0.544397891,0.437767029,0.394700766,0.332076669,0.376225501,0.300902933,0.870422363,0.780427217,0.7149629,39reliability of spacy
200,59,Spacy,Active Maintenance,github,Active Maintenance aspect,61943409,Spacy's BERT model doesn't learn,"I've been trying to use spaCy's pretrained BERT model de_trf_bertbasecased_lg to increase accuracy in my classification project. I used to build a model from scratch using de_core_news_sm and everything worked fine: I had an accuracy around 70%. But now I am using BERT pretrained model instead and I'm getting 0% accuracy. I don't believe that it's working so bad, so I'm assuming that there is just a problem with my code. I might have missed something important but I can't figure out what. I used the code in this article as an example.

Function get_data() opens files with different categories, creates a tuple like this one (text, {'cats' : {'category1': 0, 'category2':1, ...}}), gathers all these tuples into one array, which is then being returned to the main function.

Function test(nlp) opens the file with test data, predicts categories for each line in the file and checks, whether the prediction was correct.

Again, everything worked just fine with de_core_news_sm, so I'm pretty sure that functions get_data() and test(nlp) are working fine. Code above looks like in example but still 0% accuracy.I don't understand what I'm doing wrong.","Received an answer to my question on GitHub and it looks like there must be some optimizer parameters specified, just like in this example.",community support,The fact that the user received an answer to their question on GitHub suggests that there is a community of developers and users actively engaged with the library and providing support to each other.,,1,C20230706015020776228,0.678579032,0.765282929,0.877562881,0.526116252,0.428365171,0.752045453,0.682196617,0.643075347,0.562693715,0.521083295,0.438035667,0.820879698,0.52140373,0.616137922,0.76185137,0.407303572,0.33432427,0.864037991,0.777796984,0.71272558,0.586163044,0.588778675,0.4255476,0.615729809,59community support
208,62,GSON,Security,Security,Security aspect,13267258,Gson SecurityException: Can not make Class Constructor accessible,"I am using Gson to serialize/deserialize a class that contains a static nested class. The class looks like below.

public class ClassA {
private NestedClass nestedClass;

public NestedClass getNestedClass() {
return nestedClass;
}

public void setNestedClass(NestedClass nestedClass) {
this.nestedClass = nestedClass;
}

public static class NestedClass implements Serializable {

public NestedClass() {
}
}
}
The serialization works fine, but when i am trying to deserialize the json string back into an object i get the following SecurityException.

The exception seems to be coming from Java while trying to reflect the inner class. Has anyone been in that situation before?

Any help appreciated.",It appears you're running Gson on a JVM with a SecurityManager enabled. You'll need to disable the security manager to use Gson.,gson reliance on reflection,"The conversation suggests that GSON may rely on reflective mechanisms to deserialize JSON strings, which could present security risks in certain contexts.",No answer available against the challenge,0,C20230706015026208106,0.749260247,0.744690359,0.754930317,0.948392808,0.596827328,0.596253157,0.734756291,0.783268154,0.413503587,0.712180555,0.435017288,0.465155542,0.599482954,0.684685946,0.479808271,0.777506173,0.489023119,0.451061785,0.619066775,0.848328829,0.54611069,0.59591651,0.588996291,0.675259054,62gson reliance on reflection
247,73,Spacy,Feature,POS,POS tagging feature,47856247,Extract verb phrases using Spacy,I have been using Spacy for noun chunks extraction using Doc.noun_chunks property provided by Spacy. How could I extract verb phrases from input text using Spacy library (of the form 'VERB ? ADV * VERB +' )?,"This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
On how to highlight the verb phrases do check the link below.

Highlight verb phrases using spacy and html

Another Approach:

Recently observed Textacy has made some changes to regex matches. Based on that approach i tried this way.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The cat sat on the mat. He dog jumped into the water. The author is writing a book.'
pattern = [{'POS': 'VERB', 'OP': '?'},
           {'POS': 'ADV', 'OP': '*'},
           {'POS': 'VERB', 'OP': '+'}]
doc = textacy.make_spacy_doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

sat
jumped
writing
I checked the POS matches in this links seems the result is not the intended one.

[https://explosion.ai/demos/matcher][1]

Did anybody try framing POS tags instead of Regexp pattern for finding Verb phrases?",regex pattern may not be accurate,"While the regex pattern approach described in the answer can be used to extract verb phrases, it may not always produce accurate results.",No answer available against the challenge,1,C20230706015046508182,0.845876694,0.777536988,0.710152507,0.912185669,0.625444949,0.4966169,0.862525642,0.830848932,0.620511234,0.831112981,0.627302289,0.641631544,0.654895365,0.559779346,0.622645855,0.707739413,0.484297574,0.424368054,0.840318501,0.805328965,0.674904883,0.880376995,0.723095655,0.776406527,73regex pattern may not be accurate
68,20,Spacy,Performance,performance,Performance aspect,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",entity description output,Use intermediary file for displaying entity descriptions.,,1,C20230706014831193636,0.664835036,0.760690987,0.655008078,0.861023605,0.7658059,0.798306942,0.51682353,0.639631689,0.5551247,0.648676574,0.758369207,0.66368556,0.642675281,0.616007864,0.701849639,0.874756753,0.697262645,0.662721515,0.665171504,0.586019754,0.356302649,0.830228567,0.696312726,0.764886737,20entity description output
281,82,Spacy,Feature,Lemmatization,Lemmatization feature,74175424,"Is Spacy lemmatization not working properly or does it not lemmatize all words ending with ""-ing""?","When I run the spacy lemmatizer, it does not lemmatize the word ""consulting"" and therefore I suspect it is failing.

Here is my code:

nlp = spacy.load('en_core_web_trf', disable=['parser', 'ner'])
lemmatizer = nlp.get_pipe('lemmatizer')
doc = nlp('consulting')
print([token.lemma_ for token in doc])
And my output:

['consulting']","The spaCy lemmatizer is not failing, it's performing as expected. Lemmatization depends heavily on the Part of Speech (PoS) tag assigned to the token, and PoS tagger models are trained on sentences/documents, not single tokens (words). For example, parts-of-speech.info which is based on the Stanford PoS tagger, does not allow you to enter single words.

In your case, the single word ""consulting"" is being tagged as a noun, and the spaCy model you are using deems ""consulting"" to be the appropriate lemma for this case. You'll see if you change your string instead to ""consulting tomorrow"", spaCy will lemmatize ""consulting"" to ""consult"" as it is tagged as a verb (see output from the code below). In short, I recommend not trying to perform lemmatization on single tokens, instead, use the model on sentences/documents as it was intended.",proper lemmatization,"In the given code snippet, the lemmatizer correctly identifies 'consulting' as a noun and therefore lemmatizes it to 'consulting'.",Diversified question and answers,1,C20230706015138586906,0.701041222,0.632330954,0.673228443,0.540341973,0.60199368,0.797468305,0.498829722,0.837248623,0.936658204,0.492729455,0.529233098,0.871388674,0.431784898,0.710842848,0.534584045,0.418688029,0.393667459,0.77860713,0.590300739,0.752893686,0.65657568,0.816563666,0.677908659,0.720741749,82proper lemmatization
213,64,GSON,Security,Security,Security aspect,8403277,GSON vulnerabilities or exploits on deserialization to avoid,"I am planning to use gson's fromJson() method to parse a string coming from the browser. Are there any potential vulnerabilities associated with doing that? The data type I am converting to is relatively simple, a List and a boolean. But since gson uses reflection, is there something for me to watch out for?

For example, with older jvm (pre 6.24), a DOS attack could have been used against integers, where the integer parser would hang.

Can some clever json cause gson to start loading classes it should be?","The thing to watch with Gson is what type of builder you are using (see custom deserializer / serializer)

Gson has another weakness, when you are deserializing, (let's say using a custom one) you better check for the type of object you are passing (use instanceof).

Other main point: Gson will automatically convert the variable based on the type being passed.

ie. { ""var1"":1 , ""var2"":""1""} The first one will be converted into an integer, the second based to a string, therefore I would watch out on your objects transformation.",automatic variable conversion,"Gson will automatically convert variables based on their type, which could lead to unintended transformations and potential vulnerabilities.",Limitation of similarity calculation (large text),1,C20230706015030259230,0.775166094,0.757160485,0.705376685,0.890381217,0.899083972,0.932691336,0.780021071,0.69107002,0.86741209,0.822224677,0.784021556,0.750623465,0.627461493,0.61765641,0.626458585,0.913030446,0.909097016,0.932884455,0.743818402,0.687394261,0.718373239,0.854855418,0.906145513,0.786531806,64automatic variable conversion
112,32,Spacy,Performance,speed,Performance aspect,57697374,List most similar words in spaCy in pretrained model,"With Gensim, after I've trained my own model, I can use model.wv.most_similar('cat', topn=5) and get a list of the 5 words that are closest to cat in the vector space. For example:

With spaCy, as per the documentation, I can do:

which gives similarity for tokens in a specified string. But combing through the docs and searching, I can't figure out if there is a gensim-type way of listing all similar words for a preloaded model with either nlp = spacy.load('en_core_web_lg') or nlp = spacy.load('en_vectors_web_lg'). Is there a way to do this?","I used Andy's response and it worked correctly but slowly. To resolve that I took the approach below.

SpaCy uses the cosine similarity, in the backend, to compute .similarity. Therefore, I decided to replace word.similarity(w) with its optimized counterpart. The optimized method that I worked with was cosine_similarity_numba(w.vector, word.vector), shown below, that uses the Numba library to speed up computations. You should replace line 12 in the most_similar method with the line below.
The method became 2-3 times faster which was essential for me.
I explained it in more details in this article: How to Build a Fast ‚Äö√Ñ√∂‚àö√ë‚àö‚à´Most-Similar Words‚Äö√Ñ√∂‚àö√ë‚àöœÄ Method in SpaCy",limited functionality discussed,The conversation is centered around a specific functionality of the library: finding the most similar words in a preloaded model.,,1,C20230706014930474349,0.738289118,0.645183325,0.401776344,0.435662359,0.635696948,0.370761752,0.455954522,0.564147294,0.610780239,0.471087068,0.634939253,0.3096039,0.562669575,0.546385467,0.339277655,0.611643255,0.467104942,0.411785156,0.417815,0.612601995,0.617482245,0.645146549,0.444260389,0.568404734,32limited functionality discussed
216,65,GSON,Security,Security,Security aspect,4981101,Gson Security concerns,I plan to use Gson (http://code.google.com/p/google-gson/) on my server and transfer JavaScript objects from the browser to Java objects on the server. I will use Ajax to POST the request. I am a little concerned that everybody will be able to post Java objects to my server VM. A Java object that runs in the server process will have the potential to do whatever it wants. How does Gson address that?,"gson/json is data only, not code. So noone can post code to your server, just data.

When you're deserializing json, you specify which class (or you just extract primitives or collections of primitives directly) to populate with data - noone can send you json that aribtarly instantiate any of your classes living on the server.",data-oriented approach,"Gson strictly deals with data, not code. This eliminates the possibility of posting Java objects that could potentially run arbitrary code on the server.",,1,C20230706015030804084,0.628269792,0.764174223,0.524845421,0.689352393,0.818736553,0.617499173,0.682036281,0.76163727,0.698745966,0.733743787,0.698551655,0.886419773,0.683751047,0.801642656,0.58326,0.854440391,0.65566951,0.693315804,0.806558847,0.820761204,0.816384971,0.82205385,0.88361913,0.861672401,65data-oriented approach
307,90,Spacy,Feature,Entity linking,Entity linking feature,60922171,Spacy - entity linker - why is the predict score a combination of prob and cosine sim?,"I was going through the predict method for the entity linker pipe under spacy, and for some reason the score is defined as the following :

scores = prior_probs + sims - (prior_probs*sims)

Link here

Anybody has experience with this / knows where this formula comes from?

Thanks!","It is taken from Entity Linking via Joint Encoding of Types, Descriptions, and Context section 4 equation 2.

I don't feel confident enough though in explaining the formula in detail, on overall the purpose is to combine probability scores for entitiy candidates derived from external knowledge based resources (KB in the paper), which are the prior probabilities, and scores estimated with a sentence encoder, used to encode the mention to link along with its context, sims in the formula because they compute cosine similarity between the encoded mention vector and all entity candidates (which is why this formula is used only if ""incl_context"" is true).",probability score,"The formula combines scores derived from external knowledge based resources, which are the prior probabilities.",,1,C20230706015225137093,0.656463087,0.654149354,0.741417885,0.72747761,0.521446705,0.478246391,0.713665605,0.72928071,0.552186847,0.86498636,0.782340467,0.804506123,0.564269185,0.528607666,0.890472114,0.604454637,0.608395755,0.537194967,0.744735599,0.679704905,0.612513244,0.670197129,0.761150539,0.709213138,90probability score
140,40,Spacy,Stability,bug,Stability aspect,57109492,PhraseMatcher to match in a different token attribute,"We would like to match a set of phrases using PhraseMatcher. However we whould like to match not only on the verbatim text, but a normalized version of the input. For instance, lower case, with the accents removed, etc.

We have tried to add a custom attibute to the Token, and use it in the init of the PhraseMatcher to match it but, it did not work.

We could transform the text using a custom pipeline but we want to keep the original text to be able to use other components of spacy.
What is the way to do this?","Since EntityRuler is based on PhraseMatcher, I copy here a working example with Spacy v2.2.0. Follow the comments to understand how to work with ""NORM"" attribute from tokens.

At the end, you can see how the word ""F‚Äö√†√∂‚àö√ñCIL"" matches the pattern ""facil"", since it has been normalized.
This bug was fixed in release v2.1.8 https://github.com/explosion/spaCy/issues/4002",user experience,The user has already been experimenting with Spacy.,,1,C20230706014944830206,0.495251,0.769889832,0.68072778,0.573112309,0.852080345,0.756106794,0.310384512,0.460287333,0.372845858,0.561194003,0.834743798,0.635280609,0.639661193,0.627990663,0.60950911,0.644072592,0.621619523,0.577856243,0.425023854,0.387494326,0.519620299,0.427315116,0.599195123,0.651358008,40user experience
266,78,Spacy,Feature,dependency parsing,dependency parsing feature,39258476,Collocations with spaCy,"I've been using NLTK for finding collocations, or n-grams, and have recently discovered the spaCy module for NLP. I've only just begun familiarizing myself with it and have, thus far, seen little mention for supported collocation functions.

Can spaCy be used to find collocations directly?

I have read through the documentation, but haven't seen mention.","Collocations detection also can be based on dependency parsing, but spaCy do not have support to do it. You can use spaCy as part of an approach, but not directly.

may you also consider gensim: https://radimrehurek.com/gensim/models/phrases.html

I hope it can help you",consider gensim library,The answer suggests considering the alternative library gensim for supported collocation functions.,,1,C20230706015058794289,0.625016153,0.637090743,0.815471649,0.672788084,0.633512437,0.642119229,0.529182136,0.539003968,0.617672741,0.667639852,0.728972316,0.578056276,0.592535496,0.614538968,0.749441862,0.918718755,0.499600351,0.524067283,0.638270497,0.481582314,0.595671296,0.726526022,0.615778804,0.55868876,78consider gensim library
320,94,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,50742516,How to get the index of a token in a sentence in spaCy?,"Is there an elegant way to get the index of a word/token in its sentence? I am aware of the attributes for tokens https://spacy.io/api/token#attributes The i attribute returns the index within the whole parent document. But the parent document can contain multiple sentences.

Example:

""This is an example. This is another example.""
What I need is both ""This"" to be returned as index 0, both ""is"" to be returned as index 1 etc...","A spaCy Doc object also lets you iterate over the doc.sents, which are Span objects of the individual sentence. To get a span's start and end index in the parent document you can look at the start and end attribute. So if you iterate over the sentences and subtract the sentence start index from the token.i, you get the token's relative index within the sentence:

for sent in doc.sents:
    for token in sent:
        print(token.text, token.i - sent.start)
The default sentence segmentation uses the dependency parse, which is usually more accurate. However, you can also plug in a rule-based or entirely custom solution (see here for details).",iterating over spans,"Spacy Doc object allows iteration over doc.sents, which are Span objects of individual sentences.",,1,C20230706015231849942,0.758369446,0.48881489,0.774343312,0.555332184,0.753172874,0.625129759,0.721868277,0.692789972,0.620014012,0.762515724,0.534316301,0.547249913,0.641446173,0.599659503,0.449217677,0.607442379,0.4479855,0.609237969,0.624302387,0.726642251,0.779433846,0.783356965,0.721747279,0.738845825,94iterating over spans
306,90,Spacy,Feature,Entity linking,Entity linking feature,60922171,Spacy - entity linker - why is the predict score a combination of prob and cosine sim?,"I was going through the predict method for the entity linker pipe under spacy, and for some reason the score is defined as the following :

scores = prior_probs + sims - (prior_probs*sims)

Link here

Anybody has experience with this / knows where this formula comes from?

Thanks!","It is taken from Entity Linking via Joint Encoding of Types, Descriptions, and Context section 4 equation 2.

I don't feel confident enough though in explaining the formula in detail, on overall the purpose is to combine probability scores for entitiy candidates derived from external knowledge based resources (KB in the paper), which are the prior probabilities, and scores estimated with a sentence encoder, used to encode the mention to link along with its context, sims in the formula because they compute cosine similarity between the encoded mention vector and all entity candidates (which is why this formula is used only if ""incl_context"" is true).",formula source,"The entity linker's formula is taken from the paper 'Entity Linking via Joint Encoding of Types, Descriptions, and Context,' section 4 equation 2.",,1,C20230706015224020667,0.723212838,0.719785988,0.776415348,0.262458265,0.856431007,0.243860349,0.333515048,0.687772214,0.364203393,0.547316611,0.774167001,0.461652786,0.663790524,0.414405614,0.518795729,0.449530989,0.595098197,0.400746554,0.496926129,0.303621382,0.812186122,0.589482784,0.678084135,0.457067519,90formula source
255,75,Spacy,Feature,POS,POS tagging feature,34102420,POS tagging using spaCy,"I am trying to do POS tagging using the spaCy module in Python.
Here it returns crispy as a noun instead of an adjective. However, if I use a test sentence like

a=""we had crispy fries""
It recognizes that crispy is an adjective. Here is the output:

[(we , u'PRP'), (had , u'VBD'), (crispy , u'JJ'), (fries, u'NNS')]
I think the primary reason why crispy wasn't tagged as an adjective in the first case was because dosa was tagged as 'NN' whereas fries was tagged as 'NNS' in the second case.

Is there any way I can get crispy to be tagged as an adjective in the second case too?","TL;DR: You should accept the occasional error.

Details:

Spacy's tagger is statistical, meaning that the tags you get are its best estimate based on the data it was shown during training. I would guess those data did not contain the word dosa. The tagger had to guess, and guessed wrong. There isn't an easy way to correct its output, because it is not using rules or anything you can modify easily. The model has been trained on a standard corpus of English, which may be quite different to the kind of language you are using it for (domain). If error rate is too high for your purposes, you can re-train the model using domain-specific data. This will be very laborious though. Ask yourself what you are trying to achieve and whether 3% error rate in PoS tagging is the worst of your problems.

In general, you shouldn't judge the performance of a statistical system on a case-by-case basis. The accuracy of modern English PoS taggers is around 97%, which is roughly the same as the average human. You will inevitably get some errors. However, the errors of the model will not be the same as the human errors, as the two have ""learnt"" how to solve the problem in a different way. Sometimes the model will get confused by things you and I consider obvious, e.g. your example. This doesn't mean it is bad overall, or that PoS tagging is your real problem.",retraining with domain data,"While there is no easy way to correct occasional errors, you can retrain the Spacy model with domain-specific data if higher accuracy is desired.",,1,C20230706015052235583,0.822007298,0.803900778,0.582643092,0.814525664,0.415385276,0.440368682,0.738148093,0.788326681,0.521444619,0.660775065,0.329546332,0.506114364,0.511598527,0.607405126,0.638975859,0.579919219,0.522272527,0.626759946,0.612629056,0.627823055,0.564992905,0.920337975,0.876368821,0.893757164,75retraining with domain data
9,3,Spacy,Ease of use,easy,Ease of use aspect,74799295,How to extract cities with Spacy / Can't load French model,"I know it's perhaps an easy question but i'm not very familiar with Spacy.

So i'm trying to extract cities in a text file.","I just skimmed some of the source code for locationtagger, and it appears that it hardcodes usage of the en_core_web_sm model. It likely does not form correct parses of your input text.

I would not use nltk or locationtagger for this task.

Instead, download a proper spaCy model for French:

python3 -m spacy download fr_core_news_{sm|md|lg|trf}
Read spaCy's documentation on named entity recognition [1]. This includes information about identifying geopolitical entities (""GPE"").

The default spaCy models will tag cities, states/provinces/districts, and countries under the ""GPE"" tag. If you are interested only in the cities, then, you should filter the found GPEs against the data in locationtagger's City-Region-Locations.csv.

Additionally, you may wish to segment the text by paragraph and use spaCy's nlp.pipe to process paragraphs in parallel.",dependency issues,"Tools like locationtagger may have hardcoded dependencies on certain Spacy models, limiting their usefulness for non-English text.",,1,C20230706014330311473,0.596098721,0.603255212,0.30857867,0.399475217,0.463780612,0.373491734,0.571369946,0.669848859,0.382425129,0.501307368,0.479133844,0.498055845,0.369490534,0.443006694,0.369716614,0.327077568,0.402231812,0.576327264,0.309140921,0.509925604,0.506359279,0.723133028,0.574015617,0.772943795,3dependency issues
176,51,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",active maintenance,Spacy is actively maintained by a dedicated team of developers who work to improve the library and make it more user-friendly.,,1,C20230706015007862634,0.684068143,0.35529682,0.606432259,0.539880455,0.828850567,0.724025369,0.628954709,0.508528054,0.69413811,0.869405568,0.904963255,0.824580669,0.620850921,0.613754869,0.670970798,0.58395052,0.677912593,0.615166008,0.694538116,0.50336355,0.797046185,0.649268985,0.795239687,0.661198318,51active maintenance
161,46,Spacy,Stability,version,Stability aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",ongoing investigation,"The respondent mentions that they are investigating the installation issue, which suggests a commitment to maintaining and improving the library.",,1,C20230706014959803445,0.62351954,0.408896595,0.673994362,0.713909984,0.868167341,0.726553619,0.81458056,0.443603516,0.75766933,0.567364454,0.893103957,0.651771724,0.337875336,0.527995348,0.476702064,0.659149408,0.514040411,0.556492388,0.269753665,0.554484487,0.154311463,0.491352111,0.092770018,-0.005728844,46ongoing investigation
75,22,Spacy,Performance,performance,Performance aspect,57049798,Can we find sentences around an entity tagged via NER?,"We have a model ready which identifies a custom named entity. The problem is if the whole doc is given then the model does not work as per expecation if only a few sentences are given, it is giving amazing results.

I want to select two sentences before and after a tagged entity.

eg. If a part of the doc has world Colombo(which is tagged as GPE), I need to select two sentences before the tag and 2 sentences after the tag. I tried a couple of approaches but the complexity is too high.

Is there a built-in way in spacy with which we can address this problem?

I am using python and spacy.

I have tried parsing the doc by identifying the index of the tag. But that approach is really slow.","It might be worth it to see if you can improve the custom named entity recognizer, because it should be unusual for extra context to hurt performance and potentially if you fix that issue it will work better overall.

However, regarding your concrete question about surrounding sentences:

A Token or a Span (an entity is a Span) has a .sent attribute that gives you the covering sentence as a Span. If you look at the tokens right before/after a given sentence's start/end tokens, you can get the previous/next sentences for any token in a document.",built-in functionality,Spacy has a built-in functionality that allows access to the previous and next sentences for any token in a document.,,0,C20230706014907128270,0.68162477,0.703427076,0.706729889,0.572065413,0.370296448,0.642996669,0.406038761,0.648592651,0.82229203,0.735086918,0.509397447,0.766136527,0.530160487,0.710835099,0.523541808,0.529531837,0.423664153,0.576028228,0.445244044,0.734005809,0.776800156,0.650118113,0.589318752,0.836624742,22built-in functionality
122,35,Spacy,Stability,bug,Stability aspect,52263757,Spacy is_stop doesn't identify stop words?,"When I use SpaCy to identify stopwords, it doesn't work if I use the en_core_web_lg corpus, but it does work when I use en_core_web_sm. Is this a bug, or am I doing something wrong?
However, when I change this line to use the en_core_web_smcorpus, I get different results:","The issue you have is a documented bug. The suggested workaround is the following:

",workaround available,The Spacy community has suggested a workaround for the issue.,No answer available against the challenge,1,C20230706014936205527,0.71496135,0.693715334,0.694352448,0.759626687,0.611692846,0.544310391,0.565952182,0.439947873,0.517090023,0.605279386,0.62500912,0.576468647,0.645063519,0.50139147,0.503061414,0.546698809,0.639389753,0.468711704,0.443736851,0.300986439,0.584809601,0.656753302,0.650743365,0.613673627,35workaround available
316,93,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,51725599,training sentence tokenizer in spaCy,"I'm trying to tokenize sentences using spacy.

The text includes lots of abbreviations and comments which ends with a period. Also, the text was obtained with OCR and sometimes there are line breaks in the middle of sentences. Spacy doesn't seem to be performing so well in these situations.

I have extracted some examples of how I want these sentences to be split. Is there any way to train spacy's sentence tokenizer?","Spacy is a little unusual in that the default sentence segmentation comes from the dependency parser, so you can't train a sentence boundary detector directly as such, but you can add your own custom component to the pipeline or pre-insert some boundaries that the parser will respect. See their documentation with examples: Spacy Sentence Segmentation

For the cases you're describing it would potentially be useful also be able to specify that a particular position is NOT a sentence boundary, but as far as I can tell that's not currently possible.",customization possible,It is possible to add a custom component to the pipeline or pre-insert boundaries to improve sentence segmentation.,,1,C20230706015230801167,0.72099632,0.737860024,0.547239244,0.88691628,0.649593234,0.597707212,0.78515929,0.828599989,0.789788485,0.866266131,0.927015901,0.840264916,0.864818335,0.672237277,0.415118605,0.613012433,0.406789541,0.326756954,0.688400149,0.714540601,0.663618505,0.652165055,0.605963826,0.891755223,93customization possible
101,29,Spacy,Performance,fast,Performance aspect,69738938,How to use existing huggingface-transformers model into spacy?,"I'm here to ask you guys if it is possible to use an existing trained huggingface-transformers model with spacy.

My first naive attempt was to load it via spacy.load('bert-base-uncased'), it didn't work because spacy demands a certain structure, which is understandable.

Now I'm trying to figure out how to use the spacy-transformers library to load the model, create the spacy structure, and use it from that point as a normal spacy-aware model.

I don't know if it is even possible as I couldn't find anything regarding the subject. I've tried to read the documentation but all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place? I can believe someone has to train everything again with spacy.
","What you do is add a Transformer component to your pipeline and give the name of your HuggingFace model as a parameter to that. This is covered in the docs, though people do have trouble finding it. It's important to understand that a Transformer is only one piece of a spaCy pipeline, and you should understand how it all fits together.

To pull from the docs, this is how you specify a custom model in a config:

[components.transformer.model]
@architectures = ""spacy-transformers.TransformerModel.v3""
# XXX You can change the model name here
name = ""bert-base-cased""
tokenizer_config = {""use_fast"": true}
Going back to why you need to understand spaCy's structure, it's very important to understand that in spaCy, Transformers are only sources of features. If your HuggingFace model has an NER head or something it will not work. So if you use a custom model, you'll need to train other components, like NER, on top of it.

Also note that spaCy has a variety of non-Transformers built-in models. These are very fast to train and in many situations will give performance comparable to Transformers; even if they aren't as accurate, you can use the built-in models to get your pipeline configured and then just swap in a Transformer.

all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place?",custom model training,"Even if you use a custom trained HuggingFace model with spacy-transformers, you may still need to train other components, such as NER, that are included in spaCy's built-in models. Training your own custom models from scratch may be necessary if your use case or domain differs significantly from what existing models are prepped for.",wrong labeling,1,C20230706014923290434,0.70262593,0.7584337,0.605253398,0.347213477,0.441062152,0.397792339,0.598633051,0.744365394,0.470335543,0.533529937,0.528518319,0.543981671,0.544284225,0.406479001,0.421268046,0.619294047,0.562476218,0.440750778,0.520232141,0.411947966,0.421626687,0.671995401,0.788378894,0.630013466,29custom model training
258,76,Spacy,Feature,dependency parsing,dependency parsing feature,55521858,"spacy noun-chunking creates unexpected lemma, pos, tag, and dep","I am using spacy to parse documents and unfortunately I am unable to process noun chunks the way I would have expected them to be processed. 

I expected a ""lemma"" would be the phrase ""the big dog"" with plural form changed to singular and the phrase would be ""pos"" of ""NOUN"", a ""tag"" of ""NNS"", and a ""dep"" of ""nsubj"".

Is this the correct behaviour, or am I using spacy incorrectly? If I am using spacy incorrectly, please let me know the correct manner in which to perform this task.","There are a few things to consider here

Lemmatisation is token based
POS tagging and dependency parsing is predictive
You probably will get the big dog if you take the lemma_ attribute for each token. It does not update the token pos of you use the attribute.

Also, since dependency parsing and POS tagging is trained in a predictive model, it is not guaranteed to always be ""right"" from a human linguistic perspective.

Other than the lemma issue, it seems you are using spacy correct",no major issues with dependency parsing in spacy,"Overall, there are no major issues with Spacy's dependency parsing features and the user's specific issues with noun chunking are likely due to misunderstandings rather than limitations of the library.",,1,C20230706015054856693,0.762378454,0.705629706,0.43925482,0.4698309,0.790925622,0.460898936,0.685710669,0.86161691,0.759199798,0.671406567,0.766619623,0.67258054,0.700923026,0.601662099,0.636215985,0.387295872,0.663908362,0.49479869,0.540619373,0.687462807,0.685723066,0.846933603,0.78032434,0.843420923,76no major issues with dependency parsing in spacy
148,42,Spacy,Stability,bug,Stability aspect,62737680,Spacy tagger loss is zero while training,"I use this snippet of code to train a tagger in spacy 2.3.0.
The problem is that the loss value is always zero. What am I doing wrong?","Sorry, this is a bug in v2.3.0. It will be fixed in the upcoming v2.3.1. You can train a tagger with spacy train instead or use v2.2.4 in the meanwhile.

If you'd like to have this fix sooner, you can also install from source in the current master branch (the fix is in commit b7107ac8).",upcoming v2.3.1 release,"The Spacy development team is actively working on a fix for the bug, which indicates regular maintenance and updates of the library.",,1,C20230706014949420980,0.892216146,0.687291622,0.479959339,0.517459989,0.580413222,0.303368211,0.647459567,0.573038697,0.554060161,0.632707536,0.584157765,0.663031757,0.654505372,0.697677255,0.414921343,0.488552988,0.466234803,0.500931442,0.496921748,0.479850262,0.444948733,0.712025642,0.582195997,0.633127093,42upcoming v2.3.1 release
116,33,Spacy,Stability,bug,Stability aspect,40595828,"Retrieving the start and end character indices in the original document, for those sentences returned by Spacy","I am using something similar to the following pattern to retrieve the start and end indices of Spacy's sentences in the original document:
This seems to work for those few test docs I used. But worried if I am overlooking any 'gotchas' like spacy sometimes stripping off some characters that I am not aware of . Am I?

PS: If it helps, I need these indices to compare with indices I have from Brat's annotation file.","You should just be able to use the sent.start_char and sent.end_char attributes. These give exactly the indices you're after: https://spacy.io/docs/api/span#attributes

Also doc.text should always equal the original full text. If it doesn't, please submit a bug report.",relevant attributes available,Spacy provides relevant attributes for retrieving start and end character indices.,,1,C20230706014932209293,0.683313727,0.560499072,0.354420632,0.789538801,0.577283382,0.612184227,0.407560706,0.388024509,0.646525919,0.571095288,0.611063004,0.655514657,0.479171723,0.520739138,0.393281132,0.687658727,0.432464808,0.514228463,0.583247066,0.586309195,0.507110178,0.79173708,0.727808595,0.788605988,33relevant attributes available
134,38,Spacy,Stability,bug,Stability aspect,64164360,How can I add a specific substring to tokenize on in spaCy?,"I am using spaCy to tokenize a string, and the string is likely to contain a specific substring. If the substring is present, I would like spaCy to treat the substring as a token, regardless of any other rules it has. I would like to keep all other rules intact. Is this possible?

To provide a concrete example, suppose the substring of interest is 'banana'; I want 'I like bananabread.' to be tokenized as ['I', 'like', 'banana', 'bread', '.'].

Where do I go from here (keeping in mind that I would like to keep the rest of the tokenizer rules intact)? I have tried adding 'banana' to the prefixes, suffixes, and infixes, with no success.","Adding the string as a prefix, suffix, and infix should work, but depending on which version of spacy you're using, you may have run into a caching bug while testing. This bug is fixed in v2.2+.

With spacy v2.3.2:

(In v2.1 or earlier, the tokenizer customization still works on a newly loaded nlp, but if you've already processed some texts with the nlp pipeline and then modify the settings, the bug was that it would use the stored tokenization from the cache rather than the new settings.)",specific version numbers given,"The answer provides specific version numbers for Spacy, indicating that the library is being actively maintained and updated.",,1,C20230706014942062635,0.589964926,0.534987688,0.558563292,0.41502437,0.851469755,0.441308528,0.648853004,0.332789958,0.708818793,0.520307839,0.906151295,0.528409243,0.695128441,0.241056293,0.559737206,0.473976552,0.578533888,0.41598323,0.74162066,0.326947302,0.47589922,0.637598574,0.718407094,0.757813394,38specific version numbers given
110,31,Spacy,Performance,speed,Performance aspect,52897492,spaCy: optimizing tokenization,"I'm currently trying to tokenize a text file where each line is the body text of a tweet:
The file is 59,397 lines long (a day's worth of data) and I'm using spaCy for pre-processing/tokenization. It's currently taking me around 8.5 minutes and I was wondering if there were any way of optimising the following code to be quicker as 8.5 minutes seems awfully long for this process:Although it says files, it's currently only looping over 1 file.

Just to note, I only need this to tokenize the content; I don't need any extra tagging etc.","It sounds like you haven't optimised the pipeline yet. You'll get a significant speed up from disabling the pipeline components you don't need, like so:

nlp = spacy.load('en', disable=['parser', 'tagger', 'ner'])    
This should get you down to about the two-minute mark, or better, on its own.

If you need a further speed up, you can look at multi-threading using nlp.pipe. Docs for multi-threading are here: https://spacy.io/usage/processing-pipelines#section-multithreading",speed using multi-threading,The user can also utilize multi-threading with nlp.pipe to further speed up the tokenization process.,unknown/long answer?,1,C20230706014929391515,0.662154019,0.734528422,0.660724878,0.976631701,0.9835186,0.976199746,0.746514678,0.826011181,0.754419446,0.837797105,0.820609808,0.800561249,0.682545483,0.718922317,0.753416419,0.835021913,0.954780042,0.791808665,0.694248617,0.876581013,0.804174662,0.820540309,0.807801664,0.880967915,31speed using multi-threading
44,13,Spacy,Documentation,documentation,Documentation aspect,74550422,Concatenate two spacy docs together?,"How do I concatenate two spacy docs together? To merge them into one?

import spacy

nlp = spacy.load('en')
doc1 = nlp(u'This is the doc number one.')
doc2 = nlp(u'And this is the doc number two.')
new_doc = doc1+doc2
Of course that will return an error as a doc object is not concatenable by default. Is there a straightforward solution to do that?

I looked at this: https://github.com/explosion/spaCy/issues/2229 The issue seems closed so it sounds like they have implemented a solution but I cannot find a simple example of that being used.","What about this:
For ""a lot"" of different sentences, it might be better to use nlp.pipe as shown in the documentation.

Hope it helps.",no straightforward solution,There isn't a straightforward solution provided for concatenating two Spacy docs together in the conversation.,No answer available against the challenge,1,C20230706014422219122,0.750526845,0.443585992,0.550355077,0.677004099,0.29178223,0.386105478,0.74578774,0.558881521,0.744513571,0.725075722,0.851408005,0.819632709,0.57790488,0.571801484,0.690438449,0.620692909,0.437876612,0.559345782,0.718023598,0.487891525,0.623613834,0.699052334,0.83494997,0.648665905,13no straightforward solution
327,96,Spacy,Feature,Text classification,Text classification feature,48834832,How do I create gold data for TextCategorizer training?,"I want to train a TextCategorizer model with the following (text, label) pairs.

Label COLOR:

The door is brown.
The barn is red.
The flower is yellow.
Label ANIMAL:

The horse is running.
The fish is jumping.
The chicken is asleep.
I am copying the example code in the documentation for TextCategorizer.

textcat = TextCategorizer(nlp.vocab)
losses = {}
optimizer = nlp.begin_training()
textcat.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)
The doc variables will presumably be just nlp(""The door is brown."") and so on. What should be in gold1 and gold2? I'm guessing they should be GoldParse objects, but I don't see how you represent text categorization information in those.","According to this example train_textcat.py it should be something like {'cats': {'ANIMAL': 0, 'COLOR': 1}} if you want to train a multi-label model. Also, if you have only two classes, you can simply use {'cats': {'ANIMAL': 1}} for label ANIMAL and {'cats': {'ANIMAL': 0}} for label COLOR.

You can use the following minimal working example for a one category text classification;",supports multi-class classification,"The user is able to classify text into categories like ANIMAL and COLOR, indicating that Spacy is capable of supporting multi-class text classification.",,1,C20230706015235520866,0.75476259,0.650571585,0.312130898,0.468033791,0.625687897,0.440654069,0.304465413,0.716478765,0.749456167,0.32554394,0.35640949,0.55304414,0.080399707,0.488815755,0.596027493,0.361412406,0.573078096,0.406438768,0.287888795,0.480502665,0.586659968,0.360129237,0.135550112,0.425179809,96supports multi-class classification
11,3,Spacy,Ease of use,easy,Ease of use aspect,74799295,How to extract cities with Spacy / Can't load French model,"I know it's perhaps an easy question but i'm not very familiar with Spacy.

So i'm trying to extract cities in a text file.","I just skimmed some of the source code for locationtagger, and it appears that it hardcodes usage of the en_core_web_sm model. It likely does not form correct parses of your input text.

I would not use nltk or locationtagger for this task.

Instead, download a proper spaCy model for French:

python3 -m spacy download fr_core_news_{sm|md|lg|trf}
Read spaCy's documentation on named entity recognition [1]. This includes information about identifying geopolitical entities (""GPE"").

The default spaCy models will tag cities, states/provinces/districts, and countries under the ""GPE"" tag. If you are interested only in the cities, then, you should filter the found GPEs against the data in locationtagger's City-Region-Locations.csv.

Additionally, you may wish to segment the text by paragraph and use spaCy's nlp.pipe to process paragraphs in parallel.",spacy model availability,"Spacy requires a proper model for the language of interest, and these are not always readily available and may need to be downloaded.",,1,C20230706014329838521,0.638043344,0.648239195,0.398007125,0.745322526,0.390183896,0.557556391,0.553867996,0.680434287,0.417555541,0.556913555,0.509277463,0.436257869,0.707629204,0.750265956,0.441090584,0.52729708,0.26723361,0.345063895,0.393031806,0.496265978,0.35236302,0.615382731,0.274641901,0.448026955,3spacy model availability
249,74,Spacy,Feature,POS,POS tagging feature,58136715,Is there a way to determine part of speech patterns in a dataset of sentences?,I have a pandas dataframe with sentences and I'd like to determine part of speech patterns in each sentence. What's a good way to do this?,"The two most popular POS taggers for Python are NLTK and spaCy. spaCy is both faster and easier to use, and as you need to do more, spaCy also provides a nice API for interacting with wordnet, word Vectors, and other more advanced tools.

This is how you do POS reading with spaCy:

import spacy

nlp = spacy.load('en_core_web_sm')
doc = nlp(u'Apple is looking at buying U.K. startup for $1 billion')

for token in doc:
    print(token.text, token.lemma_, token.pos_, token.tag_, token.dep_,
            token.shape_, token.is_alpha, token.is_stop)",spacy has a pre-built model for english language,"Spacy provides a pre-trained model for English language, which can be used directly for tagging POS in English text.",,1,C20230706015050136022,0.696095288,0.64889729,0.739959717,0.673464179,0.691727936,0.751227796,0.52808851,0.58048135,0.447759449,0.595682144,0.573526621,0.691334307,0.755726755,0.426284254,0.575325668,0.385167509,0.643386722,0.326782793,0.653544009,0.674099088,0.572311282,0.824104071,0.638571858,0.587597787,74spacy has a pre-built model for english language
263,77,Spacy,Feature,dependency parsing,dependency parsing feature,43397502,Rule-based matcher of entities with spacy,"I want to use the python library spacy for matching tokens in a text (adding a labels as a semantic reference). Then, I want to use the matches to extract relations between the tokens. My first was to make use of the matcher.add and matcher.add_pattern of spacy. The matcher.add is working fine and I can find tokens, my code until now:

I have tried in different ways to make this works but is obviously not, I guess there is something wrong with my understanding of matcher.add_pattern.

Can some please put me in the right direction how to do this with spacy?
Is it possible to add regex here to find patterns, how?
How can I add more than one token with the same label, or somehow create a list of tokens for the same label, eg. ""FINANCE""?
I will appreciate any comments.","Your matcher would identify the tokens, but to find relations between them you will have to do dependency parsing. Here is visual example from spacy :
You can then traverse the tree to find relations between the tokens. https://spacy.io/docs/usage/dependency-parse#navigating

The dep (enum) and dep_ (verbose name) attribute of each token would give you the relationships with its child",dependency parsing for relations,Spacy supports dependency parsing to find relations between tokens.,,1,C20230706015055389209,0.66766727,0.641744971,0.736643016,0.771079659,0.692772806,0.547583699,0.706241906,0.608571172,0.628393948,0.824340761,0.561777294,0.580495894,0.516687453,0.710406542,0.689105332,0.551481366,0.54918021,0.515825033,0.643906593,0.751681387,0.613713205,0.65994823,0.629941404,0.71248132,77dependency parsing for relations
28,9,Spacy,Documentation,documentation,Documentation aspect,52855178,Discrepancy documentation and implementation of spaCy vectors for German words?,"According to documentation:

spaCy's small models (all packages that end in sm) don't ship with word vectors, and only include context-sensitive tensors. [...] individual tokens won't have any vectors assigned.
But when I use the de_core_news_sm model, the tokens Do have entries for x.vector and x.has_vector=True.

It looks like these are context_vectors, but as far as I understood the documentation only word vectors are accessible through the vector attribute and sm models should have none. Why does this work for a ""small model""?","has_vector behaves differently than you expect.

This is discussed in the comments on an issue raised on github. The gist is, since vectors are available, it is True, even though those vectors are context vectors. Note that you can still use them, eg to compute similarity.

Quote from spaCy contributor Ines:

We've been going back and forth on how the has_vector should behave in cases like this. There is a vector, so having it return False would be misleading. Similarly, if the model doesn't come with a pre-trained vocab, technically all lexemes are OOV.
Version 2.1.0 has been announced to include German word vectors.",behavior of has_vector,"has_vector attribute returns True if vectors are available, regardless of whether they are context or word vectors.",Question not focused on main topic,1,C20230706014341892503,0.76144886,0.628818333,0.655379832,0.655179441,0.630762339,0.684775531,0.455376983,0.66212666,0.652846217,0.542560875,0.49571383,0.609253407,0.420616925,0.45218423,0.534977794,0.784989834,0.564196348,0.622628272,0.454753458,0.472284526,0.3835226,0.78116852,0.739238024,0.775060952,9behavior of has_vector
329,97,Spacy,Feature,Text classification,Text classification feature,62092445,Is it possible to improve spaCy's similarity results with custom named entities?,"I've found that spaCy's similarity does a decent job of comparing my documents using ""en_core_web_lg"" out-of-the-box.

I'd like to tighten up relationships in some areas and thought adding custom NER labels to the model would help, but my results before and after show no improvements, even though I've been able to create a test set of custom entities.

Now I'm wondering, was my theory completely wrong, or could I simply be missing something in my pipeline?

If I was wrong, what's the best approach to improve results? Seems like some sort of custom labeling should help.","I found my solution was nestled in this tutorial: Text Classification in Python Using spaCy, which generates a BoW matrix for spaCy's text data by using SciKit-Learn's CountVectorizer.

I avoided sentiment analysis tutorials, due to binary classification, since I need support for multiple categories. The trick was to set multi_class='auto' on the LogisticRegression linear model, and to use average='micro' on the precision score and precision recall, so all my text data, like entities, were leveraged:

classifier = LogisticRegression(solver='lbfgs', multi_class='auto')
and...

print(""Logistic Regression Accuracy:"",metrics.accuracy_score(y_test, predicted))
print(""Logistic Regression Precision:"",metrics.precision_score(y_test, predicted,average='micro'))
print(""Logistic Regression Recall:"",metrics.recall_score(y_test, predicted,average='micro'))
Hope this helps save someone some time!",effective approach,The user found success with a LogisticRegression model with multi_class='auto' and average='micro' for optimal use of their text data.,,1,C20230706015238138506,0.701974332,0.520543218,0.595157444,0.730475008,0.90172559,0.73777169,0.764499426,0.83946389,0.720803857,0.825430453,0.846257687,0.779073775,0.652935386,0.458543211,0.653625846,0.502655149,0.951004684,0.544152319,0.599880636,0.78860718,0.585633457,0.729681373,0.955550313,0.72778517,97effective approach
56,16,Spacy,Documentation,documentation,Documentation aspect,67198877,Cannot import biluo_tags_from_offsets from spacy.gold,"I am trying to import biluo_tags_from_offsets from spacy.gold but cannot do it. Getting ModuleNotFoundError.

---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
<ipython-input-21-d17a54331c7a> in <module>
      3 
      4 import spacy
----> 5 from spacy.gold import biluo_tags_from_offsets
      6 nlp = spacy.load(""en_core_web_lg"")
      7 

ModuleNotFoundError: No module named 'spacy.gold'
How can I use this spacy.gold module. I have already installed spacy. I am an amateur, sorry if this question does not make any sense. Any kind of help is appreciated. Thanks!","As the documentation says, spacy.gold was disabled in spaCy 3.0. If you have the latest spaCy version, that is why you are getting this error.

You need to replace from spacy.gold import biluo_tags_from_offsets with from spacy.training import offsets_to_biluo_tags.",replace with new module,The recommended solution is to replace from spacy.gold import biluo_tags_from_offsets with from spacy.training import offsets_to_biluo_tags to import the equivalent functionality from a new module.,,1,C20230706014429557161,0.798622966,0.619476676,0.508532047,0.656406522,0.275727689,0.351873755,0.761274636,0.726938903,0.505385578,0.69532007,0.412096113,0.647389948,0.693374157,0.593550384,0.401449323,0.478698283,0.435679436,0.362438262,0.685907423,0.760354757,0.733952284,0.815551758,0.735299587,0.809405148,16replace with new module
103,29,Spacy,Performance,fast,Performance aspect,69738938,How to use existing huggingface-transformers model into spacy?,"I'm here to ask you guys if it is possible to use an existing trained huggingface-transformers model with spacy.

My first naive attempt was to load it via spacy.load('bert-base-uncased'), it didn't work because spacy demands a certain structure, which is understandable.

Now I'm trying to figure out how to use the spacy-transformers library to load the model, create the spacy structure, and use it from that point as a normal spacy-aware model.

I don't know if it is even possible as I couldn't find anything regarding the subject. I've tried to read the documentation but all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place? I can believe someone has to train everything again with spacy.
","What you do is add a Transformer component to your pipeline and give the name of your HuggingFace model as a parameter to that. This is covered in the docs, though people do have trouble finding it. It's important to understand that a Transformer is only one piece of a spaCy pipeline, and you should understand how it all fits together.

To pull from the docs, this is how you specify a custom model in a config:

[components.transformer.model]
@architectures = ""spacy-transformers.TransformerModel.v3""
# XXX You can change the model name here
name = ""bert-base-cased""
tokenizer_config = {""use_fast"": true}
Going back to why you need to understand spaCy's structure, it's very important to understand that in spaCy, Transformers are only sources of features. If your HuggingFace model has an NER head or something it will not work. So if you use a custom model, you'll need to train other components, like NER, on top of it.

Also note that spaCy has a variety of non-Transformers built-in models. These are very fast to train and in many situations will give performance comparable to Transformers; even if they aren't as accurate, you can use the built-in models to get your pipeline configured and then just swap in a Transformer.

all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place?",using transformer component,"Adding a Transformer component to spacy by specifying the name of the HuggingFace model allows you to load your custom model in spacy, but it's important to understand that Transformers are only sources of features, not complete models. ",,0,C20230706014922768159,0.600714564,0.486501098,0.695159256,0.402864426,0.521126866,0.513517559,0.703729928,0.741310179,0.698955059,0.759420335,0.785161614,0.793796837,0.427516341,0.44364351,0.506057739,0.43369633,0.269111931,0.47972703,0.365723222,0.317018509,0.607966661,0.570872962,0.682990611,0.528088808,29using transformer component
186,54,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,72068918,"Python NLP Spacy : improve bi-gram extraction from a dataframe, and with named entities?","I am using Python and spaCy as my NLP library, working on a big dataframe that contains feedback about different cars, which looks like this:

enter image description here

'feedback' column contains natural language text to be processed,
'lemmatized' column contains lemmatized version of the feedback text,
'entities' column contains named entities extracted from the feedback text (I've trained the pipeline so that it will recognise car models and brands, labelling these as 'CAR_BRAND' and 'CAR_MODEL')
I then created the following function, which applies the Spacy nlp token to each row of my dataframe and extract any [noun + verb], [verb + noun], [adj + noun], [adj+ proper noun] combinations.
This is where I have a problem...

This is producing only one bigram per row maximum. How can I tweak the code so that more than one bigram can be extracted and put in a column? (Also are there more linguistic combinations I should try?)
Is there a possibility to find out what people are saying about 'CAR_BRAND' and 'CAR_MODEL' named entities extracted in the 'entities' column? For example 'Cool Porsche' - Some brands or models are made of more than two words so it's tricky to tackle.
I am very new to NLP.. If there is a more efficient way to tackle this, any advice will be super helpful! Many thanks for your help in advance.","spaCy has a built-in pattern matching engine that's perfect for your application ‚Äö√Ñ√∂‚àö√ë‚àö¬® it's documented here and in a more extensive usage guide. It allows you to define patterns in a readable and easy-to-maintain way, as lists of dictionaries that define the properties of the tokens to be matched.

Some ideas for improvement

Named entity recognition should be able to detect multi-word expressions, so brand and/or model names that consist of more than one token shouldn't be an issue if everything is set up correctly
Matching dependency patterns instead of linear patterns might slightly improve your results
That being said, what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® kind of sentiment analysis -is quite a difficult task that's normally engaged with machine learning approaches and heaps of training data. So don't expect too much from simple heuristics.
",acknowledgement of complexity,"The responder acknowledged the complex nature of sentiment analysis, demonstrating knowledge and understanding of the field.",,1,C20230706015014556107,0.606793463,0.469767064,0.623863697,0.782023013,0.672762454,0.695866644,0.717366457,0.525093675,0.573917687,0.730757117,0.739484727,0.774864018,0.77649492,0.525344014,0.520744562,0.881725132,0.44339177,0.430883169,0.525678456,0.359753132,0.42577669,0.668098211,0.624834418,0.583725929,54acknowledgement of complexity
231,69,Spacy,Feature,tokenization,tokenization feature,50719732,Keeping all white spaces as tokens,"I have a question about whether there is a way to keep single white space as an independent token in spaCy tokenization.

For example if I ran:

import spacy

nlp = spacy.load(""en_core_web_sm"")
doc = nlp(""This is easy."")
toks = [w.text for w in doc]
toks
The result is

['This', 'is', 'easy', '.']
Instead, I would like to have something like

['This', ' ', 'is', ' ', 'easy', '.']
Is there are a simple way to do that?","spaCy exposes the token's whitespace as the whitespace_ attribute. So if you only need a list of strings, you could do:

token_texts = []
for token in doc:
   token_texts.append(token.text)
   if token.whitespace_:  # filter out empty strings
       token_texts.append(token.whitespace_)
If you want to create an actual Doc object out of those tokens, that's possible, too. Doc objects can be constructed with a words keyword argument (a list of strings to add as tokens). However, I'm not sure how useful that would be.",whitespace tokenization available,Spacy provides support for tokenizing whitespace as individual tokens.,,0,C20230706015037794630,0.758734107,0.627834022,0.307047844,0.726011634,0.170488745,0.127718508,0.89076817,0.596332312,0.509284198,0.716308475,0.581950188,0.550551355,0.621382892,0.646765649,0.571024537,0.657698333,0.312964857,0.318134815,0.618239284,0.637340963,0.503204644,0.856126726,0.669730067,0.607601285,69whitespace tokenization available
251,74,Spacy,Feature,POS,POS tagging feature,58136715,Is there a way to determine part of speech patterns in a dataset of sentences?,I have a pandas dataframe with sentences and I'd like to determine part of speech patterns in each sentence. What's a good way to do this?,"The two most popular POS taggers for Python are NLTK and spaCy. spaCy is both faster and easier to use, and as you need to do more, spaCy also provides a nice API for interacting with wordnet, word Vectors, and other more advanced tools.

This is how you do POS reading with spaCy:

import spacy

nlp = spacy.load('en_core_web_sm')
doc = nlp(u'Apple is looking at buying U.K. startup for $1 billion')

for token in doc:
    print(token.text, token.lemma_, token.pos_, token.tag_, token.dep_,
            token.shape_, token.is_alpha, token.is_stop)",spacy provides advanced tools,"Spacy's API extends beyond basic tagging, and provides additional tools for interacting with wordnet, word vectors, and other advanced features.",,1,C20230706015049608399,0.707565308,0.506207228,0.577852726,0.637580395,0.652167797,0.679871142,0.812329054,0.733608067,0.614699304,0.772938013,0.766346335,0.70452404,0.66429472,0.540355384,0.630181313,0.474205434,0.841606081,0.570299089,0.668714821,0.671055615,0.719981253,0.564751387,0.729983866,0.834039748,74spacy provides advanced tools
82,24,Spacy,Performance,performance,Performance aspect,66433304,spacy- why nlp() works for single string while nlp.pipe() works fine for a list of strings?,"I recently ran into a strange behavior while using spacy, which is when I process string,

in case the string is a single string object, I have to use nlp(string),

while I have to use nlp.pipe(a list) for a list made of strings elements.
Why is this? I assume this must be something to do with nlp.pipe() behavior which is generator.

What is the reason?","Spacy does this because generators are more efficient. Since generators are consumed only once they are more memory efficient than a list.

According to their documentation instead of processing texts one-by-one and applying nlp pipeline it processes texts in batches.

Furthermore, you can configure batch size in nlp.pipe to optimize performance according to your system

Process the texts as a stream using nlp.pipe and buffer them in batches, instead of one-by-one. This is usually much more efficient.
If your goal is to process large streams of data using nlp.pipe it would be much more efficient to write a streamer/generator to produce results as you need them from database/filesystem than loading everything in memory and then processing them one by one.",batch size optimization,Configuring batch size in nlp.pipe optimizes performance according to the system being used.,,1,C20230706014913135871,0.763761878,0.727118194,0.669303715,0.597587347,0.59967804,0.966917217,0.519319594,0.783204556,0.7057302,0.791499019,0.8333534,0.927487969,0.587382972,0.623309016,0.578414261,0.626908064,0.4681741,0.733707428,0.680021048,0.709095538,0.734778881,0.938862503,0.940352738,0.957396984,24batch size optimization
64,19,Spacy,Performance,performance,Performance aspect,58724562,When creating a Doc using the standard constructor the model is not loaded ,"I'm trying to use SpaCY and instantiate the Doc object using the constructor:
but when I do that, if I try to use the dependency parser:
I get the error:

ValueError: [E029] noun_chunks requires the dependency parse, which requires a statistical model to be installed and loaded. For more info, see the documentation:
While if I use the method nlp(""Hello world!"") that does not happens.

The reason I do that, is because I use the entity extraction from a third party application I want to supply to SpaCy my tokenisation and my entities.
What should I do? load the pipeline by myself in the document, and exclude the tokeniser for example?","nlp() returns a Doc where the tokenizer and all the pipeline components in nlp.pipeline have been applied to the document.

If you create a Doc by hand, the tokenizer and the pipeline components are not loaded or applied at any point.

After creating a Doc by hand, you can still apply individual pipeline components from a loaded model:

nlp = spacy.load('en_core_web_sm')
nlp.tagger(doc)
nlp.parser(doc)
Then you can add your own entities to the document. (Note that if your tokenizer is very different from the default tokenizer used when training a model, the performance may not be as good.)",doc instantiation affects performance,"Using the standard constructor to create a Doc object in Spacy negatively affects its performance since the model and pipeline components are not loaded. Hence, errors may occur when using certain functions like the dependency parser.",Confidently wrong inference,0,C20230706014828076581,0.604337275,0.537025392,0.518966496,0.663541436,0.599517763,0.686820388,0.496707082,0.707327962,0.757212043,0.622619987,0.579713166,0.54654783,0.589431286,0.479785502,0.557964087,0.919998825,0.628114164,0.619051874,0.696332455,0.740865529,0.755764425,0.867074668,0.830585003,0.815678954,19doc instantiation affects performance
52,15,Spacy,Documentation,documentation,Documentation aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",further documentation available,The Spacy library provides further information on how to use multiprocessing for efficient and speedy processing.,,0,C20230706014427993632,0.739606202,0.50073415,0.615494251,0.787038326,0.735566556,0.688368917,0.771643102,0.696990132,0.75032109,0.662216544,0.695025802,0.870716691,0.60635072,0.670566142,0.572162449,0.826217949,0.626749635,0.728214383,0.682089567,0.638880193,0.710126102,0.853112936,0.825987101,0.793572307,15further documentation available
298,88,Spacy,Feature,Entity linking,Entity linking feature,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?

import spacy
nlp = spacy.load(r""D:\el model\nlp"")
doc = nlp(""Amir Khan is a great boxer"")
ents = [(e.text, e.label_, e.kb_id_) for e in doc.ents]
print(ents) ","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",kb doesn't store descriptions,The descriptions are not stored in the KB itself because of performance reasons.,,1,C20230706015219786661,0.813481629,0.502338946,0.643138349,0.525850713,0.569142401,0.652298272,0.590498626,0.694837093,0.754484475,0.635283113,0.549929619,0.557945371,0.739491701,0.644280732,0.497281641,0.528583884,0.517134845,0.61295718,0.636598706,0.649668396,0.662021697,0.623659968,0.565783262,0.88323462,88kb doesn't store descriptions
157,45,Spacy,Stability,backwards,Stability aspect,66503956,"spaCy 3.0, installed files are different from the files in github repo","I installed spaCy 3.0 on my ubuntu. I use ctrl+B to find the definition of class ""sentencizer"" which is in sentencizer.py file:
Why there is no content in the functions defined in sentencizer.py. In the spaCy github repo, there is no sentencizer.py file and the class ""sentencizer"" is defined in sentencizer.pyx:
Why the installed files are different from the github repo? Thanks!","When developing a Python library, small changes are saved in Git as they're made, but they're only released to PyPI when the maintainer intentionally makes a release. So it's normal for the files on your computer to be a little different from the files in a git repo, even if you have a very recent release.

I was really confused about the sentencizer.py code you posted, since there doesn't seem to have ever been a file with that name in spaCy, but it looks like that is a magic PyCharm feature - it's not showing you the actual source code, it's doing some sort of decompilation.

You noticed spaCy has the sentencizer.pyx file. That's compiled into a binary .so file that Python runs when you use the code. PyCharm is presumably working backwards from the .so file.",compiled .so files,The 'sentencizer.pyx' file is compiled into a binary .so file that Python runs when the code is used.,,1,C20230706014958224351,0.718102753,0.505377352,0.635990143,0.71330893,0.583600223,0.63067019,0.531523108,0.824859619,0.623198748,0.484232813,0.636870086,0.631824076,0.475652128,0.46410808,0.569108367,0.716656685,0.540849149,0.524922729,0.584888577,0.572455347,0.61199975,0.857767224,0.638972282,0.699433148,45compiled .so files
290,85,Spacy,Feature,NER,NER feature,65220447,Add new named entity to Spacy's en_core_web_sm model?,"I'm following the example here on training a new entity type:

https://spacy.io/usage/training#example-new-entity-type

It works fine when I don't pass an existing model to it, and will correctly create a new model, which recognizes my new named entity e.g.

 python.exe train-new-entity-type.py
It also works fine when I pass an existing model to it (created by running it once before), and will correctly load the model in the dir/my_model dir, which still recognizes my new named entity e.g.

 python.exe train-new-entity-type.py -m dir/my_model
However, I want to train a new entity type, and add that to spacy's existing model, so that spacy will recognize it's own supported named entities as well as my new entity type, so I tried:

 python.exe train-new-entity-type.py -m en_core_web_sm
However, this didn't seem to work. Spacy's own supported named entities were recognized but they were not correct (vs just using the en_core_web_sm on its own without adding my new entity type to it), and my new entity type was no longer recognized at all.

Am I doing something wrong? Is this possible (adding named entities to en_core_web_sm)?","Read about the ""catastrophic forgetting"" problem when updating an existing model: https://spacy.io/usage/training#ner

It can be tricky to update an existing model, so it might be easier to train a separate model for your new entity type and add the NER component to the en_core_web_sm pipeline with a custom name. The main thing to watch out for is that you need to make sure the models are loaded with the same vocab so that you don't run into problems with the string store:

import spacy
nlp = spacy.load(""en_core_web_sm"")
custom_nlp = spacy.load(""my_model"", vocab=nlp.vocab)
nlp.add_pipe(custom_nlp.get_pipe(""ner""), name=""my_ner"", before=""ner"")
Where you add it in the pipeline (before/after the existing ner) will determine which entity spans have priority, since the ner component won't modify existing entity spans.",ner customization possible,"Spacy's NER feature is flexible and can be customized to recognize new named entities, as long as the models are compatible and loaded properly.",,1,C20230706015216643389,0.781985641,0.707658112,0.707022071,0.669836164,0.636748016,0.898423314,0.724250257,0.805340648,0.709463477,0.792715073,0.792475462,0.929705977,0.621054888,0.693856657,0.607022941,0.839978456,0.640691757,0.681931973,0.645091474,0.746798396,0.738824368,0.890760958,0.706373692,0.82516861,85ner customization possible
275,80,Spacy,Feature,Lemmatization,Lemmatization feature,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.

class SpacyLemmatizer(object):
    def __init__(self, smodel):
        import spacy
        self.lemmatizer = spacy.load(smodel).vocab.morphology.lemmatizer

    # get the lemmas for every upos
    def getLemmas(self, entry):
        possible_lemmas = set()
        for upos in ('NOUN', 'VERB', 'ADJ', 'ADV'):
            lemmas = self.lemmatizer(entry, upos, morphology=None)
            lemma = lemmas[0]    # See morphology.pyx::lemmatize
            possible_lemmas.add( lemma )
        return possible_lemmas",spacy supports lemmatization,SpaCy supports lemmatization as a stand-alone component.,No answer available against the challenge,1,C20230706015101506603,0.774284303,0.568710685,0.737614453,0.776980281,0.796410859,0.77137351,0.645867944,0.514768958,0.744721055,0.532656372,0.816812575,0.614409208,0.517477214,0.551741242,0.562234759,0.873329937,0.696799695,0.683007956,0.576331496,0.504311025,0.527184546,0.675693989,0.834302127,0.612812936,80spacy supports lemmatization
330,97,Spacy,Feature,Text classification,Text classification feature,62092445,Is it possible to improve spaCy's similarity results with custom named entities?,"I've found that spaCy's similarity does a decent job of comparing my documents using ""en_core_web_lg"" out-of-the-box.

I'd like to tighten up relationships in some areas and thought adding custom NER labels to the model would help, but my results before and after show no improvements, even though I've been able to create a test set of custom entities.

Now I'm wondering, was my theory completely wrong, or could I simply be missing something in my pipeline?

If I was wrong, what's the best approach to improve results? Seems like some sort of custom labeling should help.","I found my solution was nestled in this tutorial: Text Classification in Python Using spaCy, which generates a BoW matrix for spaCy's text data by using SciKit-Learn's CountVectorizer.

I avoided sentiment analysis tutorials, due to binary classification, since I need support for multiple categories. The trick was to set multi_class='auto' on the LogisticRegression linear model, and to use average='micro' on the precision score and precision recall, so all my text data, like entities, were leveraged:

classifier = LogisticRegression(solver='lbfgs', multi_class='auto')
and...

print(""Logistic Regression Accuracy:"",metrics.accuracy_score(y_test, predicted))
print(""Logistic Regression Precision:"",metrics.precision_score(y_test, predicted,average='micro'))
print(""Logistic Regression Recall:"",metrics.recall_score(y_test, predicted,average='micro'))
Hope this helps save someone some time!",ineffective approach,Adding custom named entities did not improve similarity results for the user.,No answer available against the challenge,1,C20230706015237097167,0.423549175,0.604633749,0.660100877,0.58828944,0.581551015,0.741620123,0.392813891,0.532159388,0.460587382,0.624614954,0.613938689,0.834410608,0.526371658,0.523209333,0.397950888,0.505961835,0.509546876,0.575371504,0.530333221,0.471752405,0.496134967,0.780383229,0.776652038,0.865381241,97ineffective approach
325,96,Spacy,Feature,Text classification,Text classification feature,48834832,How do I create gold data for TextCategorizer training?,"I want to train a TextCategorizer model with the following (text, label) pairs.

Label COLOR:

The door is brown.
The barn is red.
The flower is yellow.
Label ANIMAL:

The horse is running.
The fish is jumping.
The chicken is asleep.
I am copying the example code in the documentation for TextCategorizer.

textcat = TextCategorizer(nlp.vocab)
losses = {}
optimizer = nlp.begin_training()
textcat.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)
The doc variables will presumably be just nlp(""The door is brown."") and so on. What should be in gold1 and gold2? I'm guessing they should be GoldParse objects, but I don't see how you represent text categorization information in those.","According to this example train_textcat.py it should be something like {'cats': {'ANIMAL': 0, 'COLOR': 1}} if you want to train a multi-label model. Also, if you have only two classes, you can simply use {'cats': {'ANIMAL': 1}} for label ANIMAL and {'cats': {'ANIMAL': 0}} for label COLOR.

You can use the following minimal working example for a one category text classification;",example code provided,"The user is provided with an example code train_textcat.py, which shows how to represent text categorization information in the gold1 and gold2 variables.",,1,C20230706015236047434,0.597364306,0.623427331,0.75524652,0.427871436,0.37818709,0.339148492,0.394526511,0.531599343,0.618573487,0.61494571,0.48166126,0.428694516,0.754642725,0.060793336,0.479854137,0.520619035,0.523113966,0.447250843,0.52999866,0.047051821,0.425863028,0.048109792,0.351992458,0.107160427,96example code provided
303,89,Spacy,Feature,Entity linking,Entity linking feature,59050554,Error running Spacy entity linking example,"I was trying the entity linking example in spacy.
Using this example to train the entity linker and generating the knowledge base for the same with this example.

I can create a knowledge base with the available en_core_web_md, this is the output for the same.
When I try to train the entity linker with the knowledge base from above, I get this error.
File ""pipes.pyx"", line 1219, in spacy.pipeline.pipes.EntityLinker.update
I did follow the instructions specified here. I used the en_core_web_md to create the knowledge base since I do not have a pre-trained model.

I did not write any custom code just trying to run this example, Can someone point me to the right direction.
","This was asked and answered in the following issue on spaCy's GitHub.

It looks like the script no longer worked after a refactor of the entity linking pipeline as it now expects either a statistical or rule-based NER component in the pipeline.

The new script adds such an EntityRuler to the pipeline as an example. I.e.,

# Add a custom component to recognize ""Russ Cochran"" as an entity for the example training data.
# Note that in a realistic application, an actual NER algorithm should be used instead.
ruler = EntityRuler(nlp)
patterns = [{""label"": ""PERSON"", ""pattern"": [{""LOWER"": ""russ""}, {""LOWER"": ""cochran""}]}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, this can be replaced with your own statistical NER model.",example demonstrates adding ner component,The example provided in the answer demonstrates how to add a custom NER component (EntityRuler) to the pipeline. This can be replaced with a user's own statistical NER model for a more realistic application.,No answer available against the challenge,1,C20230706015222412999,0.710716248,0.803760171,0.668751359,0.501051962,0.465967476,0.559155166,0.721940935,0.832500219,0.834395945,0.797621965,0.680182874,0.809335232,0.62413168,0.591181874,0.714386046,0.562298656,0.474980742,0.446256846,0.73525542,0.816333711,0.730594099,0.83254993,0.686701059,0.693773389,89example demonstrates adding ner component
206,61,Spacy,Security,leak,Security aspect,58956171,"Dataflow job failed after more than 6 hours with ""The worker lost contact with the service""?","I am using Dataflow to read data from BigQuery and then do NLP preprocessing using python. I am using Python 3 and SDK 2.16.0. I am using 100 workers (provite IP, private access and Cloud NAT) with workers in europe-west6 and endpoint in europe-west1. The BigQuery tables are in US. Test jobs were working without any issue but when trying to process the full table (32 GB), the job failed after 6h 40 min and it is hard to fully understand what is the underlying error.","After some test and after few plots for monitoring, it was clear that even if the length of the text was the sime the processing time started to augment rapidly (botton right plot)
Then it became clear that the issue was with SpaCy 2.1.8 (memory leak).

Using Spacy 2.2.3 fix the issue. Now the 32 Gb of data are processed in 4h30 without any issue.",private ip and access,Using private IP and access provides additional security measures to protect the data from unauthorized access.,Unknown,1,C20230706015022871961,0.721205056,0.736305118,0.661251366,0.966124296,0.979993403,0.963617802,0.816357672,0.833939731,0.790505826,0.942539275,0.90304482,0.938096821,0.652688384,0.53410399,0.438303649,0.679704905,0.72166729,0.967841625,0.679404199,0.390348196,0.163160488,0.52766037,0.162606835,0.459022135,61private ip and access
59,17,Spacy,Documentation,documentation,Documentation aspect,61241351,"Install specific version of spacy - working with pip, but not with conda","I am revisiting some code I wrote months ago with Spacy Version 2.1.8. I need this version of spacy. pip install is working but Anaconda does not even show that spacy is installed. And

conda install spacy=2.1.8
gives the PackagesNotFoundError error.","As explained in spaCy documentation, you can take advantage of the conda-forge community repository to install spacy

$ conda install -c conda-forge spacy=2.1.8
This version should be available according to spaCy's page on Conda Forge.",command line code,"Documentation provides a command-line code to install spacy package, which specifies the version number and the conda-forge community repository.",,1,C20230706014430720078,0.547315478,0.592806637,0.557276368,0.807062507,0.684104562,0.718017459,0.69731617,0.637090385,0.623295069,0.534348369,0.734140277,0.543772459,0.380375087,0.507609963,0.560134828,0.920286298,0.857076705,0.895421684,0.501156151,0.496045709,0.529321909,0.409483314,0.6703161,0.640223622,17command line code
241,72,Spacy,Feature,POS,POS tagging feature,42830248,how to write spacy matcher of POS regex,"Spacy has two features I'd like to combine - part-of-speech (POS) and rule-based matching.

How can I combine them in a neat way?

For example - let's say input is a single sentence and I'd like to verify it meets some POS ordering condition - for example the verb is after the noun (something like noun**verb regex). result should be true or false. Is that doable? or the matcher is specific like in the example

Rule-based matching can have POS rules?

If not - here is my current plan - gather everything in one string and apply regex","Sure, simply use the POS attribute.

import spacy
nlp = spacy.load('en')
from spacy.matcher import Matcher
from spacy.attrs import POS
matcher = Matcher(nlp.vocab)
matcher.add_pattern(""Adjective and noun"", [{POS: 'ADJ'}, {POS: 'NOUN'}])

doc = nlp(u'what are the main issues')
matches = matcher(doc)",customizability,"Spacy supports regex as well as rule-based matching, giving users the flexibility to choose an approach based on their needs.",,1,C20230706015044887437,0.704528689,0.670187771,0.582682967,0.584699214,0.543048978,0.763781905,0.319440573,0.615135849,0.47079125,0.737296641,0.58423537,0.652559221,0.831786633,0.757182181,0.752389789,0.440502375,0.553349018,0.629377723,0.567024291,0.558119714,0.532287419,0.605336785,0.632351577,0.828589022,72customizability
197,57,Spacy,Active Maintenance,github,Active Maintenance aspect,46765198,Unable to load spacy English model - 'WindowsPath' object has no attribute 'read',"I installed spacy using pip and then downloaded the English model using  
$ python -m spacy download en which after downloading gave me the message

You can now load the model via spacy.load('en')
I have the English model files(en_core_web_sm) downloaded to the working directory, am I missing something? Do I need to set a path variable? Any help is much appreciated, thanks!",If anybody else receives this error : I opened this as an issue with spaCy's developers on Github. I was suggested using Python 3.6 instead of 2.7 for the moment as there is no alternate workaround to the problem. The next spaCy version should cover this bugfix (I'm told).,open source support,The ability for users to report issues and receive support from the community is an important aspect of maintaining a successful open source project.,,0,C20230706015019203032,0.601154566,0.647592902,0.545905411,0.359315187,0.53249234,0.367732465,0.747104585,0.700478196,0.623972476,0.747133672,0.656698644,0.652608871,0.515659988,0.428470582,0.590598464,0.345047563,0.318541378,0.210696116,0.648490131,0.548052549,0.428060681,0.826410532,0.617655396,0.602660596,57open source support
236,70,Spacy,Feature,tokenization,tokenization feature,50908667,Tokenization not working the same for both case.,"I have a document

doc = nlp('x-xxmessage-id:')
When I want to extract the tokens of this one I get 'x', 'xx', 'message' and 'id', ':'. Everything goes well. Then I create a new document

test_doc = nlp('id')
If I try to extract the tokens of test_doc, I will get 'i' and 'd'. Is there any way to get past this problem? Because I want to get the same token as above and this is creating problems in the text processing.","Just like language itself, tokenization is context-dependent and the language-specific data defines rules that tell spaCy how to split the text based on the surrounding characters. spaCy's defaults are also optimised for general-purpose text, like news text, web texts and other modern writing.

In your example, you've come across an interesting case: the abstract string ""x-xxmessage-id:"" is split on punctuation, while the isolated lowercase string ""id"" is split into ""i"" and ""d"", because in written text, it's most commonly an alternate spelling of ""I'd"" or ""i'd"" (""I could"", ""I would"" etc.). You can find the respective rules here.

If you're dealing with specific texts that are substantially different from regular natural language texts, you usually want to customise the tokenization rules or possibly even add a Language subclass for your own custom ""dialect"". If there's a fixed number of cases you want to tokenize differently that can be expressed by rules, another option would be to add a component to your pipeline that merges the split tokens back together.

Finally, you could also try using the language-independent xx / MultiLanguage class instead. It still includes very basic tokenization rules, like splitting on punctuation, but none of the rules specific to the English language.

from spacy.lang.xx import MultiLanguage
nlp = MultiLanguage()",using multilanguage class,The language-independent MultiLanguage class allows basic tokenization rules but not English-specific rules.,,1,C20230706015040931352,0.721300185,0.735722005,0.564312518,0.710154116,0.723170102,0.736655891,0.638775826,0.747003078,0.676832974,0.804179966,0.727927506,0.719664276,0.543698668,0.726107955,0.597283542,0.552293897,0.477950394,0.74613297,0.588984847,0.642301321,0.628368258,0.65893364,0.652818859,0.677012384,70using multilanguage class
322,95,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,57779549,Converting Spacy generated dependency into CoNLL format cannot handle more than one ROOT?,"I used the SpaCy library to generate dependencies and save it into a CoNLL format using the code below.

This works, but there are some sentences in my dataset that get splits into two by Spacy because they have two ROOTS. This results in having two fields for one sentence in the CoNLL format.

Example: A random sentence from my dataset is : ""teanna trump probably cleaner twitter hoe but""

Is there a way to save it all in one field instead of two even though it has two ROOTS so that 'but' becomes 7th item in field number 1? Which means it would look like this instead","I'd recommend using (or adapting) the textacy CoNLL exporter to get the right format, see: How to generate .conllu from a Doc object?

Spacy's parser is doing sentence segmentation and you're iterating over doc.sents, so you'll see each sentence it exported separately. If you want to provide your own sentence segmentation, you can do that with a custom component, e.g.:

def set_custom_boundaries(doc):
    for token in doc[:-1]:
        if token.text == ""..."":
            doc[token.i+1].is_sent_start = True
    return doc

nlp.add_pipe(set_custom_boundaries, before=""parser"")
Details (especially about how to handle None vs. False vs. True): https://spacy.io/usage/linguistic-features#sbd-custom

Spacy's default models aren't trained on twitter-like text, the parser probably won't perform well with respect to sentence boundaries here.

(Please ask unrelated questions as separate questions, and also take a look at spacy's docs: https://spacy.io/usage/linguistic-features#special-cases)",custom sentence segmentation,"The user can provide their own sentence segmentation using a custom component, which allows for more flexibility and customization of the segmentation process.",,1,C20230706015234550541,0.659165263,0.766909301,0.648483694,0.658807516,0.59134239,0.733827353,0.513957679,0.765338361,0.691339433,0.773403525,0.822518945,0.902328968,0.545300782,0.604144752,0.684702873,0.832052171,0.434663862,0.380655289,0.497417778,0.719122231,0.521033525,0.829346418,0.738807619,0.747411132,95custom sentence segmentation
309,91,Spacy,Feature,Entity linking,Entity linking feature,60809394,Can spaCy link only named entities?,"I'd would like to extract important entities and link them to Wikipedia entities. I've trained spaCy on a small sample of Wikipedia/WikiData and run entity linking on the review:

[('Tofu', 'PERSON', 'Q177378'), 
('Nyquil', 'WORK_OF_ART', 'NIL')]
I'd like other entities to be extracted and linked as well, e.g.:

kimchi -> Kimchi
cold -> Common cold
healing -> medicine 
medically -> medicine
It looks like spaCy can link only named entities. I've tried to explicitly list other entities as named (which obviously does not scale well):

ruler = EntityRuler(nlp)
patterns = [{""label"": ""ORG"", ""pattern"": ""kimchi""}, {""label"": ""ORG"", ""pattern"": ""cold""}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, spaCy does not seem to link new entities at all:

[ ('Tofu', 'PERSON', 'Q177378'),
  ('cold', 'ORG', ''),
  ('Nyquil', 'WORK_OF_ART', 'NIL'),
  ('kimchi', 'ORG', '')]
How can I make Spacy recognize also other entities?
Should this be done before training entity linking model or can be done with already trained model?
Is spaCy the right tool for my task at all?","In theory it's possible. First, you'll need to make sure you have a component that tags these kind of entities. You could train an NER model for this, but be aware that its performance might not be as good on things like ""cold"" than it would be for actual named entities like ""London"".

To create the Knowledge Base and the Entity Linker from Wikipedia/Wikidata, the example scripts are not limited to named entities - they attempt to parse anything that appears in an intra-wiki link. If the word ""cold"" gets linked to the page ""Common cold"", it should be able to learn it. The exact entities that are stored in the KB and that are used for training the EL model, depend on which entities are found by your entity recognizer component. So if you adjust that according to your use-case, the entity linking component will follow automatically.",kb and entity linker,Creating a Knowledge Base and Entity Linker from Wikipedia/Wikidata can potentially link other entities as well.,,0,C20230706015227142689,0.80893898,0.802331626,0.612128615,0.822355151,0.716167271,0.780451357,0.755336106,0.81577462,0.744282067,0.86786288,0.666187525,0.740200758,0.731841505,0.555776775,0.458139539,0.554082274,0.563793123,0.486136705,0.729357481,0.724718869,0.514241278,0.871943593,0.695581913,0.799202144,91kb and entity linker
317,93,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,51725599,training sentence tokenizer in spaCy,"I'm trying to tokenize sentences using spacy.

The text includes lots of abbreviations and comments which ends with a period. Also, the text was obtained with OCR and sometimes there are line breaks in the middle of sentences. Spacy doesn't seem to be performing so well in these situations.

I have extracted some examples of how I want these sentences to be split. Is there any way to train spacy's sentence tokenizer?","Spacy is a little unusual in that the default sentence segmentation comes from the dependency parser, so you can't train a sentence boundary detector directly as such, but you can add your own custom component to the pipeline or pre-insert some boundaries that the parser will respect. See their documentation with examples: Spacy Sentence Segmentation

For the cases you're describing it would potentially be useful also be able to specify that a particular position is NOT a sentence boundary, but as far as I can tell that's not currently possible.",limitations of default segmentation,"Spacy's default sentence segmentation may not work well with text containing abbreviations, comments that end with a period, and OCR-induced line breaks.",,1,C20230706015230277318,0.59900552,0.733370185,0.587892354,0.619424939,0.640106499,0.619344532,0.588187516,0.730790854,0.92383492,0.85134995,0.655948043,0.767608404,0.657585979,0.426347673,0.591203749,0.558941782,0.585182786,0.499031246,0.620893359,0.565872431,0.691322446,0.843845487,0.5336169,0.503306568,93limitations of default segmentation
10,3,Spacy,Ease of use,easy,Ease of use aspect,74799295,How to extract cities with Spacy / Can't load French model,"I know it's perhaps an easy question but i'm not very familiar with Spacy.

So i'm trying to extract cities in a text file.","I just skimmed some of the source code for locationtagger, and it appears that it hardcodes usage of the en_core_web_sm model. It likely does not form correct parses of your input text.

I would not use nltk or locationtagger for this task.

Instead, download a proper spaCy model for French:

python3 -m spacy download fr_core_news_{sm|md|lg|trf}
Read spaCy's documentation on named entity recognition [1]. This includes information about identifying geopolitical entities (""GPE"").

The default spaCy models will tag cities, states/provinces/districts, and countries under the ""GPE"" tag. If you are interested only in the cities, then, you should filter the found GPEs against the data in locationtagger's City-Region-Locations.csv.

Additionally, you may wish to segment the text by paragraph and use spaCy's nlp.pipe to process paragraphs in parallel.",model capabilities,"It's important to choose the appropriate Spacy model for the task at hand, based on its features and named entity recognition capabilities.",,1,C20230706014330837706,0.59701699,0.445845187,0.554773748,0.639929533,0.68627739,0.696717441,0.599436283,0.547081232,0.469091207,0.557043493,0.595964849,0.719033837,0.456058055,0.682860851,0.33996731,0.616741359,0.293646812,0.423493713,0.645551264,0.677052379,0.263391823,0.693765819,0.545660377,0.3212156,3model capabilities
62,18,Spacy,Documentation,documentation,Documentation aspect,68083466,How to use spacy train to add entities to an existing custom NER model? (Spacy v3.0),"I am currently implementing a custom NER model interface where a user can interact with a frontend application to add custom entities to train a spacy model.

I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.

For example, let's say I have a model that is already trained for a custom entity of FOOD. (Pizza, Pasta, Bread, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ). Now I want to take this existing model, and train it for a new entity called DRINKS with keywords like Coca-Cola, Pepsi, Juice, etc‚Äö√Ñ√∂‚àö√ë¬¨‚àÇ Using spacy train command for spacy v3.0.

The spacy train command that I am using currently is as follows:

> python -m spacy train config.cfg --output ./output --paths.train ./train.spacy --paths.dev ./train.spacy
I load the model for prediction using:

> nlp1 = spacy.load(R"".\output\model-best"")
As of now, I was training the model for new entities manually. Below is the code to find keywords in my training data and output a JSON format for training data (old format).","""I want to use spacy train (CLI) to take an existing model (custom NER model) and add the keyword and entity specified by the user, to that model. (Instead of training the whole model again). I can't find this anywhere in the documentation.""
What you are describing is called ""online learning"" and the default spaCy models don't support it. Most modern neural NER methods, even outside of spaCy, have no support for it at all.

You cannot fix this by using a custom training loop.

Your options are to use rule-based matching, so you can only match things explicitly in a list, or to retrain models on the fly.

Rule-based matching should be easy to set up but has the obvious issue that it can't learn things not explicitly in the list.

Training things on the fly may sound like it'll take too long, but you can train a small model quite quickly. What you can do is train a small model for a small number of iterations while the user is working interactively, and after they've confirmed the model is more or less working correctly you can use the same training data for a larger model with longer training.",options: retrain models on the fly,"Retraining models on the fly may seem time-consuming, but a small model can be trained quickly and then used to train a larger model with longer training.",Confidently wrong inference,0,C20230706014827542569,0.677224159,0.834393442,0.612814069,0.763217688,0.626612067,0.630301595,0.83268106,0.910968781,0.91727525,0.834078193,0.834674597,0.947886169,0.534255803,0.594464481,0.424025297,0.443454981,0.41783759,0.426128477,0.835694611,0.658452094,0.519292176,0.717567742,0.614397526,0.716305733,18options: retrain models on the fly
262,77,Spacy,Feature,dependency parsing,dependency parsing feature,43397502,Rule-based matcher of entities with spacy,"I want to use the python library spacy for matching tokens in a text (adding a labels as a semantic reference). Then, I want to use the matches to extract relations between the tokens. My first was to make use of the matcher.add and matcher.add_pattern of spacy. The matcher.add is working fine and I can find tokens, my code until now:

I have tried in different ways to make this works but is obviously not, I guess there is something wrong with my understanding of matcher.add_pattern.

Can some please put me in the right direction how to do this with spacy?
Is it possible to add regex here to find patterns, how?
How can I add more than one token with the same label, or somehow create a list of tokens for the same label, eg. ""FINANCE""?
I will appreciate any comments.","Your matcher would identify the tokens, but to find relations between them you will have to do dependency parsing. Here is visual example from spacy :
You can then traverse the tree to find relations between the tokens. https://spacy.io/docs/usage/dependency-parse#navigating

The dep (enum) and dep_ (verbose name) attribute of each token would give you the relationships with its child",attribute for relationships,The dep and dep_ attributes can be used to find relationships between tokens.,,1,C20230706015056426706,0.733585179,0.728314996,0.586502194,0.928579926,0.822570622,0.830447435,0.756480932,0.751652718,0.646695256,0.925020039,0.877778769,0.862480164,0.421706319,0.554404974,0.713137984,0.924342811,0.617652595,0.555250227,0.169821396,0.150684863,0.630657554,0.726812065,0.306307226,0.307551354,77attribute for relationships
286,84,Spacy,Feature,NER,NER feature,57536896,Custom entity ruler with SpaCy did not return a match,"This link shows how to create custom entity ruler.

I basically copied and modified the code for another custom entity ruler and used it to find a match in a doc as follows:
However, when I run the code (in Jupyter notebook), nothing returned.

Could you please tell me:

If the code returned nothing, did it mean no match was found?
Why couldn't my code find a match although it's almost identical to the original (except for the patterns added to the ruler)? What did I do wrong?","The problem is an interaction between the NER component provided in the English model and your EntityRuler component. The NER component finds 2 as a number (CARDINAL) and there's a restriction that entities aren't allowed to overlap, so the EntityRuler component doesn't find any matches.

You can either add your EntityRuler before the NER component:

nlp.add_pipe(ruler, before='ner')
Or tell the EntityRuler that it's allowed to overwrite existing entities:

ruler = EntityRuler(nlp, overwrite_ents=True)",issue with overlapping entities,"The NER component found an entity that overlapped with the entities defined in the custom entity ruler, resulting in no matches being found.",,1,C20230706015141525231,0.727486908,0.561993718,0.601981699,0.575704932,0.617082059,0.704270959,0.665234745,0.79260695,0.743549168,0.762670279,0.8543396,0.786921322,0.638347924,0.384290665,0.66471982,0.457010418,0.519395232,0.494919211,0.676451921,0.608002901,0.7017802,0.687193692,0.848230302,0.633434832,84issue with overlapping entities
304,89,Spacy,Feature,Entity linking,Entity linking feature,59050554,Error running Spacy entity linking example,"I was trying the entity linking example in spacy.
Using this example to train the entity linker and generating the knowledge base for the same with this example.

I can create a knowledge base with the available en_core_web_md, this is the output for the same.
When I try to train the entity linker with the knowledge base from above, I get this error.
File ""pipes.pyx"", line 1219, in spacy.pipeline.pipes.EntityLinker.update
I did follow the instructions specified here. I used the en_core_web_md to create the knowledge base since I do not have a pre-trained model.

I did not write any custom code just trying to run this example, Can someone point me to the right direction.
","This was asked and answered in the following issue on spaCy's GitHub.

It looks like the script no longer worked after a refactor of the entity linking pipeline as it now expects either a statistical or rule-based NER component in the pipeline.

The new script adds such an EntityRuler to the pipeline as an example. I.e.,

# Add a custom component to recognize ""Russ Cochran"" as an entity for the example training data.
# Note that in a realistic application, an actual NER algorithm should be used instead.
ruler = EntityRuler(nlp)
patterns = [{""label"": ""PERSON"", ""pattern"": [{""LOWER"": ""russ""}, {""LOWER"": ""cochran""}]}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, this can be replaced with your own statistical NER model.",spacy supports entity linking feature,The conversation indicates that Spacy supports entity linking feature. The user encountered an issue with an example in the documentation.,,1,C20230706015221368593,0.581546843,0.534605205,0.339502275,0.79475069,0.443711847,0.391016901,0.704557002,0.767445266,0.737897635,0.798128664,0.789019465,0.784003794,0.503612757,0.311906397,0.515632749,0.550759375,0.293177307,0.39480567,0.472980678,0.514673591,0.37954998,0.482551724,0.780897915,0.453502595,89spacy supports entity linking feature
30,9,Spacy,Documentation,documentation,Documentation aspect,52855178,Discrepancy documentation and implementation of spaCy vectors for German words?,"According to documentation:

spaCy's small models (all packages that end in sm) don't ship with word vectors, and only include context-sensitive tensors. [...] individual tokens won't have any vectors assigned.
But when I use the de_core_news_sm model, the tokens Do have entries for x.vector and x.has_vector=True.

It looks like these are context_vectors, but as far as I understood the documentation only word vectors are accessible through the vector attribute and sm models should have none. Why does this work for a ""small model""?","has_vector behaves differently than you expect.

This is discussed in the comments on an issue raised on github. The gist is, since vectors are available, it is True, even though those vectors are context vectors. Note that you can still use them, eg to compute similarity.

Quote from spaCy contributor Ines:

We've been going back and forth on how the has_vector should behave in cases like this. There is a vector, so having it return False would be misleading. Similarly, if the model doesn't come with a pre-trained vocab, technically all lexemes are OOV.
Version 2.1.0 has been announced to include German word vectors.",importance of understanding,Understanding the behavior of the has_vector attribute and the differences between context and word vectors is vital in using Spacy's functionality effectively.,Confidently wrong inference,0,C20230706014342900550,0.808351517,0.581574738,0.704381347,0.69117111,0.817439795,0.84358108,0.848238051,0.72092241,0.763680339,0.737888157,0.731368899,0.737143397,0.55958426,0.613169432,0.595896423,0.636761904,0.555339217,0.755139172,0.727747738,0.74132508,0.656333268,0.668080807,0.688023984,0.681351006,9importance of understanding
12,4,Spacy,Ease of use,simple,Ease of use aspect,57199811,Create a Spacy pipeline with my own Tokeniser?,"What puzzles me is that a spacy ""pipeline"" is a sequence of processing steps, but the very first step which converts the original data into a spacy document is ""hidden"". Unlike all the other steps it cannot be accessed from the pipeline, I think. So what if I want to replace it, change it, or create a pipeline with my own Tokenizer, what is the proper way to do this?","The reason the tokenizer isn't part of the regular pipeline is because it's ""special"": There can only really be one, and while all other pipeline components take a Doc and return it, the tokenizer takes a string of text and turns it into a Doc.

However, nlp.tokenizer is writable, so you can either create your own Tokenizer class from scratch, or even replace it with an entirely custom function. Here's a super simple example that shows the idea:
",creating a custom tokenizer,Developers can use a simple example provided in the answer to create their own Tokenizer that suits their needs.,,1,C20230706014333140120,0.741780519,0.639607489,0.592784643,0.813300133,0.510973155,0.453703076,0.593994856,0.766593158,0.599539042,0.508409441,0.36554268,0.599882543,0.376908302,0.638895094,0.643066823,0.402622581,0.298397988,0.525462508,0.565330625,0.573079884,0.595926046,0.435656548,0.693057597,0.518263638,4creating a custom tokenizer
130,37,Spacy,Stability,bug,Stability aspect,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.",modular design,"SpaCy lemmatizer can be used as a standalone component, suggesting a modular design which may indicate reliability.",,1,C20230706014938831474,0.381786108,0.457328141,0.614854217,0.485927492,0.702646732,0.80560106,0.793343902,0.603385508,0.739401281,0.818657756,0.789117277,0.692811847,0.50083679,0.728673935,0.780395627,0.533572197,0.628494382,0.611079633,0.471862644,0.707752585,0.752589643,0.462130398,0.513960302,0.624773145,37modular design
324,95,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,57779549,Converting Spacy generated dependency into CoNLL format cannot handle more than one ROOT?,"I used the SpaCy library to generate dependencies and save it into a CoNLL format using the code below.

This works, but there are some sentences in my dataset that get splits into two by Spacy because they have two ROOTS. This results in having two fields for one sentence in the CoNLL format.

Example: A random sentence from my dataset is : ""teanna trump probably cleaner twitter hoe but""

Is there a way to save it all in one field instead of two even though it has two ROOTS so that 'but' becomes 7th item in field number 1? Which means it would look like this instead","I'd recommend using (or adapting) the textacy CoNLL exporter to get the right format, see: How to generate .conllu from a Doc object?

Spacy's parser is doing sentence segmentation and you're iterating over doc.sents, so you'll see each sentence it exported separately. If you want to provide your own sentence segmentation, you can do that with a custom component, e.g.:

def set_custom_boundaries(doc):
    for token in doc[:-1]:
        if token.text == ""..."":
            doc[token.i+1].is_sent_start = True
    return doc

nlp.add_pipe(set_custom_boundaries, before=""parser"")
Details (especially about how to handle None vs. False vs. True): https://spacy.io/usage/linguistic-features#sbd-custom

Spacy's default models aren't trained on twitter-like text, the parser probably won't perform well with respect to sentence boundaries here.

(Please ask unrelated questions as separate questions, and also take a look at spacy's docs: https://spacy.io/usage/linguistic-features#special-cases)",solution with textacy conll exporter,The user is advised to use (or adapt) textacy CoNLL exporter to get the right format for the CoNLL export.,No answer available against the challenge,1,C20230706015234078447,0.752710462,0.550281107,0.658780932,0.597873032,0.613852143,0.655563474,0.709527016,0.688713074,0.710009098,0.578843713,0.615166485,0.722650588,0.706234157,0.604536414,0.508470535,0.579609871,0.500253141,0.48667407,0.587473452,0.660802722,0.54639101,0.746632397,0.638449073,0.557870507,95solution with textacy conll exporter
84,24,Spacy,Performance,performance,Performance aspect,66433304,spacy- why nlp() works for single string while nlp.pipe() works fine for a list of strings?,"I recently ran into a strange behavior while using spacy, which is when I process string,

in case the string is a single string object, I have to use nlp(string),

while I have to use nlp.pipe(a list) for a list made of strings elements.
Why is this? I assume this must be something to do with nlp.pipe() behavior which is generator.

What is the reason?","Spacy does this because generators are more efficient. Since generators are consumed only once they are more memory efficient than a list.

According to their documentation instead of processing texts one-by-one and applying nlp pipeline it processes texts in batches.

Furthermore, you can configure batch size in nlp.pipe to optimize performance according to your system

Process the texts as a stream using nlp.pipe and buffer them in batches, instead of one-by-one. This is usually much more efficient.
If your goal is to process large streams of data using nlp.pipe it would be much more efficient to write a streamer/generator to produce results as you need them from database/filesystem than loading everything in memory and then processing them one by one.",memory efficiency,"Using generators consumes less memory than processing texts one-by-one, making it more efficient.",,1,C20230706014912610734,0.529155672,0.659265399,0.701488674,0.648923397,0.665670693,0.954372883,0.707088768,0.83271575,0.840982616,0.856761098,0.73640281,0.860501349,0.487540156,0.604961634,0.493034571,0.54469347,0.563592494,0.562491119,0.62479347,0.693827152,0.750557363,0.894904375,0.852519214,0.916515887,24memory efficiency
235,70,Spacy,Feature,tokenization,tokenization feature,50908667,Tokenization not working the same for both case.,"I have a document

doc = nlp('x-xxmessage-id:')
When I want to extract the tokens of this one I get 'x', 'xx', 'message' and 'id', ':'. Everything goes well. Then I create a new document

test_doc = nlp('id')
If I try to extract the tokens of test_doc, I will get 'i' and 'd'. Is there any way to get past this problem? Because I want to get the same token as above and this is creating problems in the text processing.","Just like language itself, tokenization is context-dependent and the language-specific data defines rules that tell spaCy how to split the text based on the surrounding characters. spaCy's defaults are also optimised for general-purpose text, like news text, web texts and other modern writing.

In your example, you've come across an interesting case: the abstract string ""x-xxmessage-id:"" is split on punctuation, while the isolated lowercase string ""id"" is split into ""i"" and ""d"", because in written text, it's most commonly an alternate spelling of ""I'd"" or ""i'd"" (""I could"", ""I would"" etc.). You can find the respective rules here.

If you're dealing with specific texts that are substantially different from regular natural language texts, you usually want to customise the tokenization rules or possibly even add a Language subclass for your own custom ""dialect"". If there's a fixed number of cases you want to tokenize differently that can be expressed by rules, another option would be to add a component to your pipeline that merges the split tokens back together.

Finally, you could also try using the language-independent xx / MultiLanguage class instead. It still includes very basic tokenization rules, like splitting on punctuation, but none of the rules specific to the English language.

from spacy.lang.xx import MultiLanguage
nlp = MultiLanguage()",merging split tokens,Adding a component to merge split tokens back together can improve tokenization accuracy.,,1,C20230706015040518241,0.794558644,0.671668768,0.514089048,0.78426075,0.616753459,0.661691785,0.70986867,0.727030933,0.526227653,0.816683888,0.732540905,0.808965623,0.756517351,0.621842086,0.607113898,0.606886268,0.617359877,0.513140619,0.759016275,0.774056196,0.593950927,0.813252151,0.775586963,0.715173483,70merging split tokens
238,71,Spacy,Feature,tokenization,tokenization feature,50330455,How to detokenize spacy text without doc context?,"I have a sequence to sequence model trained on tokens formed by spacy's tokenization. This is both encoder and decoder.

The output is a stream of tokens from a seq2seq model. I want to detokenize the text to form natural text.

Example:

Input to Seq2Seq: Some text

Output from Seq2Seq: This does n't work .

Is there any API in spacy to reverse tokenization done by rules in its tokenizer?","TL;DR I've written a code that attempts to do it, the snippet is below.

Another approach, with a computational complexity of O(n^2) * would be to use a function I just wrote. The main thought was ""What spaCy splits, shall be rejoined once more!""
Downsides:

In this approach you may easily merge ""do"" and ""nt"", as well as strip space between the dot ""."" and preceding word. This method is not perfect, as there are multiple possible combinations of sentences that lead to specific spaCy tokenization.

I am not sure if there is a method to fully detokenize a sentence when all you have is spaCy separated text, but this is the best I've got.

After having searched for hours on Google, only a few answers came along, with this very stack question being opened on 3 of my tabs on chrome ;), and all it wrote was basically ""don't use spaCy, use revtok"". As I couldn't change the tokenization other researchers chose, I had to develop my own solution. Hope it helps someone ;)",imperfect solution,"The attempted solution may result in incorrectly merged words or stripped spaces between words and punctuation, as there are multiple possible combinations of sentences that lead to specific Spacy tokenization.",,1,C20230706015042302919,0.503909349,0.65958333,0.730495095,0.519508362,0.536361694,0.894701064,0.903422832,0.753470302,0.864332139,0.767901838,0.848571002,0.68554765,0.826557517,0.788243592,0.701377809,0.565501273,0.536679208,0.94220233,0.796609521,0.740256965,0.813985169,0.734567404,0.7290411,0.820629358,71imperfect solution
7,2,Spacy,Ease of use,easy,Ease of use aspect,56694713,In spaCy is there a way to extract the sentence the entity has been extracted from?,"considering the following sentence:

""the quick brown fox jumps over the lazy dog""
and if I want to extract brown, extracting only brown is fairly easy to do however I want the following output:

""brown"" , ""the quick brown fox jumps over the lazy dog""","Yes, there is a way to do this in Spacy. You have to iterate over the entity Span objects and extract the sentence from each Span object. Here is an example:

    doc = nlp(""John and Claire live in London. They have a dog. Claire walks her 
    dog everyday."")
    for entity in doc.ents:
       print('Entity extracted : ', entity.text)
       print('Sentence extracted from : ', entity.sent)",useful for nlp,"For those with coding proficiency, Spacy can offer useful tools for natural language processing and text analysis.",,0,C20230706014107386977,0.666052878,0.692724645,0.86257267,0.542304099,0.563652337,0.804271638,0.331115991,0.772718012,0.720416009,0.52145648,0.620348811,0.751783431,0.639209747,0.463167101,0.489223123,0.458780676,0.560007513,0.667048037,0.65012151,0.718607187,0.728639662,0.703724802,0.645052314,0.862817645,2useful for nlp
177,51,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",awareness of potential issues,The responder is aware of potential issues that may arise during the upgrading process and provides information on training models on different versions of Spacy.,,1,C20230706015009625687,0.593351305,0.466133475,0.669923425,0.54261893,0.887834549,0.585299134,0.64401871,0.478546947,0.527593493,0.767210305,0.873018503,0.813540518,0.444766521,0.517439783,0.457388759,0.615935624,0.936039448,0.645219386,0.388508409,0.401104599,0.435435563,0.755761862,0.774875879,0.759515405,51awareness of potential issues
215,64,GSON,Security,Security,Security aspect,8403277,GSON vulnerabilities or exploits on deserialization to avoid,"I am planning to use gson's fromJson() method to parse a string coming from the browser. Are there any potential vulnerabilities associated with doing that? The data type I am converting to is relatively simple, a List and a boolean. But since gson uses reflection, is there something for me to watch out for?

For example, with older jvm (pre 6.24), a DOS attack could have been used against integers, where the integer parser would hang.

Can some clever json cause gson to start loading classes it should be?","The thing to watch with Gson is what type of builder you are using (see custom deserializer / serializer)

Gson has another weakness, when you are deserializing, (let's say using a custom one) you better check for the type of object you are passing (use instanceof).

Other main point: Gson will automatically convert the variable based on the type being passed.

ie. { ""var1"":1 , ""var2"":""1""} The first one will be converted into an integer, the second based to a string, therefore I would watch out on your objects transformation.",object type checking,"It's important to check for the type of object being passed, using 'instanceof'.",,1,C20230706015029455158,0.765833437,0.575239778,0.712355375,0.726806104,0.88802439,0.70207566,0.688111782,0.6365574,0.546243727,0.806161284,0.803487241,0.895486534,0.625965178,0.411107659,0.643209636,0.448476583,0.677788854,0.52848357,0.575110912,0.707433641,0.676838517,0.771933913,0.854215205,0.819844186,64object type checking
250,74,Spacy,Feature,POS,POS tagging feature,58136715,Is there a way to determine part of speech patterns in a dataset of sentences?,I have a pandas dataframe with sentences and I'd like to determine part of speech patterns in each sentence. What's a good way to do this?,"The two most popular POS taggers for Python are NLTK and spaCy. spaCy is both faster and easier to use, and as you need to do more, spaCy also provides a nice API for interacting with wordnet, word Vectors, and other more advanced tools.

This is how you do POS reading with spaCy:

import spacy

nlp = spacy.load('en_core_web_sm')
doc = nlp(u'Apple is looking at buying U.K. startup for $1 billion')

for token in doc:
    print(token.text, token.lemma_, token.pos_, token.tag_, token.dep_,
            token.shape_, token.is_alpha, token.is_stop)",spacy is faster and easier,"As compared to NLTK, Spacy is faster and easier to use. It is a great tool for POS tagging and can handle even complex and lengthy datasets.",,1,C20230706015049087216,0.651793718,0.70533365,0.586747169,0.808667004,0.640127003,0.693937838,0.58235395,0.77987957,0.716498375,0.788773537,0.685098469,0.844005525,0.778199732,0.846565485,0.724727213,0.732433319,0.493814766,0.570167661,0.72578752,0.724868655,0.695704877,0.670539737,0.509875834,0.709917426,74spacy is faster and easier
175,50,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",reference to brat tool,"The answer provided a recommendation for another tool called Brat, which suggests that the SpaCy maintainers are aware of and keeping up with other tools in the field.",Question not focused on main topic,1,C20230706015007205217,0.690346479,0.54517597,0.871507466,0.569211483,0.91526866,0.586425602,0.777956426,0.781512022,0.755996287,0.833798885,0.67598927,0.675286174,0.64151758,0.790018439,0.894490421,0.513452053,0.827784181,0.513943076,0.705040216,0.736800551,0.656824291,0.679969251,0.555434287,0.470427185,50reference to brat tool
220,66,GSON,Security,Security,Security aspect,39176229,Deserializing to a templated class with Gson,"I have a class with a nested subclass
Currently I would like to be able to have a function that takes as a parameter the held class, and returns an appropriate instance of GenericClassHolder, i.e. something like my current code:
But this does not work in my current implementation, with the error

Unable to invoke no-args constructor for GenericClassHolder<T>. Register an InstanceCreator with Gson for this type may fix this problem.
How can I succinctly achieve my aforementioned goal of having a function that takes as input the specification for a class that may change and parses to this object accordingly? If it is not possible to achieve an elegant solution through a function, how can I achieve this goal without one?","I deployed this code in a Google Appengine instance, and due to some security reasons, I could not deserialize the way I was deserializing and replicate the same way on my local machine. The solution was to make the deserialized classes static; they were nested inside of an outer encapsulating class as well",focus on technical issue,The conversation is focused on resolving a technical issue with deserialization of a nested class using GSON.,,1,C20230706015032151593,0.58747679,0.65336132,0.523162842,0.521740794,0.278120488,0.59314394,0.445061356,0.721800983,0.702108383,0.709695339,0.452050388,0.642106116,0.503488779,0.780850589,0.358974308,0.520463109,0.476976812,0.382831812,0.305720419,0.414022475,0.591494858,0.213079795,0.412409633,0.632545412,66focus on technical issue
55,16,Spacy,Documentation,documentation,Documentation aspect,67198877,Cannot import biluo_tags_from_offsets from spacy.gold,"I am trying to import biluo_tags_from_offsets from spacy.gold but cannot do it. Getting ModuleNotFoundError.

---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
<ipython-input-21-d17a54331c7a> in <module>
      3 
      4 import spacy
----> 5 from spacy.gold import biluo_tags_from_offsets
      6 nlp = spacy.load(""en_core_web_lg"")
      7 

ModuleNotFoundError: No module named 'spacy.gold'
How can I use this spacy.gold module. I have already installed spacy. I am an amateur, sorry if this question does not make any sense. Any kind of help is appreciated. Thanks!","As the documentation says, spacy.gold was disabled in spaCy 3.0. If you have the latest spaCy version, that is why you are getting this error.

You need to replace from spacy.gold import biluo_tags_from_offsets with from spacy.training import offsets_to_biluo_tags.",module disabled,Spacy.gold was disabled in spaCy 3.0 which resulted in the error message 'No module named 'spacy.gold'.',,1,C20230706014429048055,0.668482542,0.820719898,0.676863313,0.642070889,0.781441152,0.66635114,0.487189233,0.762954473,0.629190207,0.511463761,0.595475554,0.580274761,0.575948358,0.560373604,0.590024889,0.535336673,0.617118418,0.882387877,0.577915132,0.729613185,0.649581611,0.72066474,0.704881907,0.672628701,16module disabled
334,98,Spacy,Feature,Rule-based matching,Rule-based matching feature,72346631,Highlight text parts based on labels,"thanks to fellow stackoverflowrians I have data labels that I would like to high light in the text:

eg. I have product description

Description: Tampered black round grey/natural swing with yellow load-bearing left hook
Features were extracted as

colors=['black','grey','natural','yellow']
shape = ['round']
direction= ['left']
In Spacy it is possible to highlight the features like this

enter image description here

Is there any possibility to highlight it also like this from the data I have as labels? So that I have labels shown in the text too? I dont know if Spacy is the good tool or any other is better?
","I'm not entirely sure what you're asking, but you can put entities of your own on the spaCy Doc object and pass them to Displacy.

To simply set entities manually, you can do this:

doc = nlp(...)
span = doc[0:1] # whatever span of the doc you want to highlight
span.ent_label_ = ""COLOR"" # the label you want
ents = [span] # in reality you could do more than one
doc.ents = ents
If you have word list and need to look for words, you can use rule-based matching with an EntityRuler. Check the rule-based matching guide.",support for rule-based matching,"Spacy supports rule-based matching features for highlighting text based on labels, as confirmed in the answer.",Limitation of similarity calculation (large text),1,C20230706015238685988,0.569066942,0.635880232,0.797584295,0.902822733,0.537147403,0.474189073,0.611736536,0.680297017,0.295107335,0.799222469,0.607596576,0.633640289,0.521657228,0.636754215,0.931700051,0.709602773,0.2776241,0.373647362,0.73060143,0.705949664,0.322452366,0.796521187,0.405189931,0.415361732,98support for rule-based matching
17,5,Spacy,Ease of use,difficult,Ease of use aspect,67789544,Given a word can we get all possible lemmas for it using Spacy?,"The input word is standalone and not part of a sentence but I would like to get all of its possible lemmas as if the input word were in different sentences with all possible POS tags. I would also like to get the lookup version of the word's lemma.

Why am I doing this?

I have extracted lemmas from all the documents and I have also calculated the number of dependency links between lemmas. Both of which I have done using en_core_web_sm. Now, given an input word, I would like to return the lemmas that are linked most frequently to all the possible lemmas of the input word.

So in short, I would like to replicate the behaviour of token._lemma for the input word with all possible POS tags to maintain consistency with the lemma links I have counted.","I found it difficult to get lemmas and inflections directly out of spaCy without first constructing an example sentence to give it context. This wasn't ideal, so I looked further and found LemmaInflect did this very well.",not straightforward task,"Based on the conversation, it seems that using Spacy solely for this specific task may require some additional knowledge or tools beyond the library itself.",wrong labeling,0,C20230706014334111237,0.687634766,0.686136007,0.45964703,0.783182502,0.963993192,0.800905287,0.777157366,0.788609803,0.653733134,0.829772115,0.739247501,0.797955871,0.762662292,0.783243537,0.503232062,0.549573362,0.659475744,0.67988956,0.533768415,0.718083978,0.59100306,0.580677032,0.589645088,0.684080303,5not straightforward task
121,35,Spacy,Stability,bug,Stability aspect,52263757,Spacy is_stop doesn't identify stop words?,"When I use SpaCy to identify stopwords, it doesn't work if I use the en_core_web_lg corpus, but it does work when I use en_core_web_sm. Is this a bug, or am I doing something wrong?
However, when I change this line to use the en_core_web_smcorpus, I get different results:","The issue you have is a documented bug. The suggested workaround is the following:

",stopwords variation,"The bug only affects stopword identification with en_core_web_lg, while it works with en_core_web_sm.",,1,C20230706014935680274,0.699800611,0.588577807,0.71826303,0.573922992,0.657492638,0.712907255,0.709713876,0.743461192,0.518988073,0.713830709,0.622793078,0.565733671,0.572136819,0.513577342,0.602372408,0.451934516,0.491324097,0.669389844,0.784241557,0.385577917,0.703208268,0.471046984,0.771896958,0.427311748,35stopwords variation
218,65,GSON,Security,Security,Security aspect,4981101,Gson Security concerns,I plan to use Gson (http://code.google.com/p/google-gson/) on my server and transfer JavaScript objects from the browser to Java objects on the server. I will use Ajax to POST the request. I am a little concerned that everybody will be able to post Java objects to my server VM. A Java object that runs in the server process will have the potential to do whatever it wants. How does Gson address that?,"gson/json is data only, not code. So noone can post code to your server, just data.

When you're deserializing json, you specify which class (or you just extract primitives or collections of primitives directly) to populate with data - noone can send you json that aribtarly instantiate any of your classes living on the server.",security enhancements,"While Gson's data processing methods ensure security, added security measures such as input validation can further enhance overall security and prevent potential security breaches on the server.",,1,C20230706015031681465,0.826610744,0.805249095,0.622216225,0.6767326,0.892555475,0.744674563,0.903451145,0.680548191,0.794232666,0.765473008,0.684517682,0.519536018,0.719481468,0.677691519,0.651026905,0.512565613,0.893556118,0.483858854,0.914560258,0.643011868,0.838200867,0.659279644,0.813006043,0.593890488,65security enhancements
280,82,Spacy,Feature,Lemmatization,Lemmatization feature,74175424,"Is Spacy lemmatization not working properly or does it not lemmatize all words ending with ""-ing""?","When I run the spacy lemmatizer, it does not lemmatize the word ""consulting"" and therefore I suspect it is failing.

Here is my code:

nlp = spacy.load('en_core_web_trf', disable=['parser', 'ner'])
lemmatizer = nlp.get_pipe('lemmatizer')
doc = nlp('consulting')
print([token.lemma_ for token in doc])
And my output:

['consulting']","The spaCy lemmatizer is not failing, it's performing as expected. Lemmatization depends heavily on the Part of Speech (PoS) tag assigned to the token, and PoS tagger models are trained on sentences/documents, not single tokens (words). For example, parts-of-speech.info which is based on the Stanford PoS tagger, does not allow you to enter single words.

In your case, the single word ""consulting"" is being tagged as a noun, and the spaCy model you are using deems ""consulting"" to be the appropriate lemma for this case. You'll see if you change your string instead to ""consulting tomorrow"", spaCy will lemmatize ""consulting"" to ""consult"" as it is tagged as a verb (see output from the code below). In short, I recommend not trying to perform lemmatization on single tokens, instead, use the model on sentences/documents as it was intended.",contextual dependence,"Lemmatization depends heavily on the Part of Speech (PoS) tag assigned to the token, and PoS tagger models are trained on sentences/documents, not single tokens (words).",,1,C20230706015138036079,0.668315351,0.689811707,0.638172328,0.543935955,0.32785508,0.570751309,0.653402388,0.820836842,0.710287035,0.73030138,0.655498564,0.766449153,0.577502728,0.698685646,0.470585883,0.672852755,0.452349424,0.620338082,0.776042819,0.814996362,0.71809572,0.847403347,0.643202782,0.700447857,82contextual dependence
15,5,Spacy,Ease of use,difficult,Ease of use aspect,67789544,Given a word can we get all possible lemmas for it using Spacy?,"The input word is standalone and not part of a sentence but I would like to get all of its possible lemmas as if the input word were in different sentences with all possible POS tags. I would also like to get the lookup version of the word's lemma.

Why am I doing this?

I have extracted lemmas from all the documents and I have also calculated the number of dependency links between lemmas. Both of which I have done using en_core_web_sm. Now, given an input word, I would like to return the lemmas that are linked most frequently to all the possible lemmas of the input word.

So in short, I would like to replicate the behaviour of token._lemma for the input word with all possible POS tags to maintain consistency with the lemma links I have counted.","I found it difficult to get lemmas and inflections directly out of spaCy without first constructing an example sentence to give it context. This wasn't ideal, so I looked further and found LemmaInflect did this very well.",difficult to get lemmas,The user found it difficult to get the desired output of all possible lemmas for a given word without first constructing an example sentence to provide context.,,1,C20230706014333678890,0.711844325,0.608238697,0.617549539,0.788223743,0.766029716,0.825122356,0.72263962,0.613505304,0.812768161,0.750118434,0.741799057,0.774911761,0.76799041,0.744975209,0.727436602,0.800127149,0.617363155,0.540884495,0.874305367,0.787784934,0.548659384,0.8315804,0.605318427,0.703916013,5difficult to get lemmas
87,25,Spacy,Performance,fast,Performance aspect,58212589,How to check if a sentence is a question with spacy?,"I am using spacy library to build a chat bot. How do I check if a document is a question with a certain confidence? I know how to do relevance, but not sure how to filter statements from questions.

I am looking for something like below:

spacy.load('en_core_web_lg')('Is this a question?').is_question","My first response is to suggest looking for question marks at the end of the sentence.

Otherwise, most questions start with {is, does, do, what, when, where, who, why, what, how}.

There is a more complex answer involving the inclusion of auxiliary verbs and their placement relative to the verb, but if your data is well-formed, this may be sufficient (and fast).",identifying question marks,Suggests looking for question marks at the end of the sentence,,1,C20230706014914703734,0.637047768,0.588428676,0.626542509,0.866420507,0.562534571,0.604073286,0.559952021,0.603426397,0.52842176,0.778688967,0.717252135,0.718399107,0.772748351,0.63054508,0.419428438,0.388402373,0.810243785,0.4144319,0.569578409,0.256866515,0.466531247,0.477949947,0.700240433,0.657847762,25identifying question marks
252,74,Spacy,Feature,POS,POS tagging feature,58136715,Is there a way to determine part of speech patterns in a dataset of sentences?,I have a pandas dataframe with sentences and I'd like to determine part of speech patterns in each sentence. What's a good way to do this?,"The two most popular POS taggers for Python are NLTK and spaCy. spaCy is both faster and easier to use, and as you need to do more, spaCy also provides a nice API for interacting with wordnet, word Vectors, and other more advanced tools.

This is how you do POS reading with spaCy:

import spacy

nlp = spacy.load('en_core_web_sm')
doc = nlp(u'Apple is looking at buying U.K. startup for $1 billion')

for token in doc:
    print(token.text, token.lemma_, token.pos_, token.tag_, token.dep_,
            token.shape_, token.is_alpha, token.is_stop)",spacy supports pos tagging,Spacy is mentioned as one of the two most popular POS taggers for Python in the conversation. Spacy provides a simple and easy to use API for POS tagging.,,1,C20230706015048564484,0.53730011,0.581724048,0.371820003,0.693203509,0.449950606,0.559197843,0.709174931,0.65142256,0.793675065,0.851135373,0.80766356,0.723572612,0.457968116,0.510340393,0.643221676,0.561463118,0.524844348,0.528695822,0.683055222,0.626499832,0.740407109,0.893423617,0.883142769,0.834402025,74spacy supports pos tagging
245,73,Spacy,Feature,POS,POS tagging feature,47856247,Extract verb phrases using Spacy,I have been using Spacy for noun chunks extraction using Doc.noun_chunks property provided by Spacy. How could I extract verb phrases from input text using Spacy library (of the form 'VERB ? ADV * VERB +' )?,"This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
On how to highlight the verb phrases do check the link below.

Highlight verb phrases using spacy and html

Another Approach:

Recently observed Textacy has made some changes to regex matches. Based on that approach i tried this way.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The cat sat on the mat. He dog jumped into the water. The author is writing a book.'
pattern = [{'POS': 'VERB', 'OP': '?'},
           {'POS': 'ADV', 'OP': '*'},
           {'POS': 'VERB', 'OP': '+'}]
doc = textacy.make_spacy_doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

sat
jumped
writing
I checked the POS matches in this links seems the result is not the intended one.

[https://explosion.ai/demos/matcher][1]

Did anybody try framing POS tags instead of Regexp pattern for finding Verb phrases?",alternative approach using textacy,"The answer provides an alternative approach to using regex patterns, using the Textacy library's make_spacy_doc and extract functions to extract verb phrases.",,1,C20230706015047516109,0.602223337,0.670773685,0.729980171,0.707934916,0.606710851,0.704298794,0.790501535,0.7701689,0.63270241,0.840364397,0.80555141,0.729095399,0.661373258,0.592532814,0.707953513,0.612433791,0.524876595,0.742489278,0.679157615,0.697272539,0.727633834,0.70235914,0.683869779,0.802320361,73alternative approach using textacy
37,11,Spacy,Documentation,documentation,Documentation aspect,58215855,"How to get full list of POS, Tag, and Dep in spaCy?","The POS, TAG, and DEP values used in spaCy are common ones of NLP, but I believe there are some differences depending on the corpus database.

For example, Universal Dependencies Contributors has listed 37 syntactic dependencies. Does spaCy use all of these 37 dependencies? And nothing more?

Is there a command to output all POS, TAG, and DEP values, spaCy may provide?","A specific pipeline component can show its labels:

nlp = spacy.load('en')
nlp.get_pipe(""tagger"").labels
# ('$', ""''"", ',', '-LRB-', '-RRB-', '.', ':', 'ADD', 'AFX', 'CC', 'CD', 'DT', 'EX', 'FW', 'HYPH', 'IN', 'JJ', 'JJR', 'JJS', 'LS', 'MD', 'NFP', 'NN', 'NNP', 'NNPS', 'NNS', 'PDT', 'POS', 'PRP', 'PRP$', 'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB', 'XX', '_SP', '``')
spacy.explain(label) will give a short definition for most labels, e.g.:

spacy.explain(""NN"")
# 'noun, singular or mass'
spacy.explain(""PERSON"")
# 'People, including fictional'
The detailed documentation is here: https://spacy.io/api/annotation",additional documentation,"For more information, the detailed documentation for spaCy's annotations can be found at https://spacy.io/api/annotation.",,1,C20230706014348147508,0.74033165,0.495387346,0.644952476,0.579128504,0.702349722,0.736092448,0.613272429,0.507436216,0.526975989,0.292168796,0.65771389,0.536683857,0.467009813,0.565168083,0.567401528,0.433722228,0.753081977,0.513698578,0.621151328,0.501287758,0.546689034,0.616605699,0.820780277,0.606730103,11additional documentation
120,35,Spacy,Stability,bug,Stability aspect,52263757,Spacy is_stop doesn't identify stop words?,"When I use SpaCy to identify stopwords, it doesn't work if I use the en_core_web_lg corpus, but it does work when I use en_core_web_sm. Is this a bug, or am I doing something wrong?
However, when I change this line to use the en_core_web_smcorpus, I get different results:","The issue you have is a documented bug. The suggested workaround is the following:

",documented bug,The issue the user experienced is a documented bug in Spacy.,,1,C20230706014935157811,0.823016167,0.825078189,0.639040887,0.794056535,0.642237604,0.586636186,0.556108177,0.537017286,0.542807519,0.846631885,0.714841366,0.755330145,0.779759943,0.444085747,0.256564319,0.797220051,0.729170918,0.828712702,0.599722743,0.34252131,0.415418893,0.58419919,0.558630645,0.421191752,35documented bug
48,14,Spacy,Documentation,documentation,Documentation aspect,57206701,Spacy tokenizer rule for exceptions that contain whitespace?,"When I create a pipeline with the default tokenizer for say English, I can then call the method for adding a special case:

tokenizer.add_special_case(""don't"", case)
The tokenizer will happily accept a special case that contains whitespace:

tokenizer.add_special_case(""some odd case"", case)
but it appears that does not actually change the behavior of the tokenizer or will never match?

More generally, what is the best way of extending an existing tokenizer so that the some patterns which normally would result in multiple tokens only create one token? For example something like [A-Za-z]+\([A-Za-z0-9]+\)[A-Za-z]+ should not result in three tokens because of the parentheses but in a single token, e.g. for asdf(a33b)xyz while the normal English rules should still apply if that pattern does not match.

Is this something that can be done somehow by augmenting an existing tokenizer or would I have to first tokenize, then find entities that match the corresponding token patterns and then merge the entity tokens?","As you found, Tokenizer.add_special_case() doesn't work for handling tokens that contain whitespace. That's for adding strings like ""o'clock"" and "":-)"", or expanding e.g. ""don't"" to ""do not"".

Modifying the prefix, suffix and infix rules (either by setting them on an existing tokenizer or creating a new tokenizer with custom parameters) also doesn't work since those are applied after whitespace splitting.

To override the whitespace splitting behavior, you have four options:

Merge after tokenization. You use Retokenizer.merge(), or possibly merge_entities or merge_noun_chunks. The relevant documentation is here: https://spacy.io/usage/linguistic-features#retokenization and https://spacy.io/api/pipeline-functions#merge_entities and https://spacy.io/api/pipeline-functions#merge_noun_chunks

This is your best bet for keeping as much of the default behavior as possible.
Subclass Tokenizer and override __call__. Sample code:

Implement a completely new tokenizer (without subclassing Tokenizer). Relevant docs here: https://spacy.io/usage/linguistic-features#custom-tokenizer-example
Tokenize externally and instantiate Doc with words. Relevant docs here: https://spacy.io/usage/linguistic-features#own-annotations
To answer the second part of your question, if you don't need to change whitespace splitting behavior, you have two other options:

Add to the default prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizer-additions

Note from https://stackoverflow.com/a/58112065/594211: ""You can add new patterns without defining a custom tokenizer, but there's no way to remove a pattern without defining a custom tokenizer.""
Instantiate Tokenizer with custom prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizers

To get the default rules, you read the existing tokenizer's attributes (as shown above) or use the nlp object‚Äö√Ñ√∂‚àö√ë‚àö¬•s Defaults. There are code samples for the latter approach in https://stackoverflow.com/a/47502839/594211 and https://stackoverflow.com/a/58112065/594211.",override whitespace splitting,"Four options are provided, including merging after tokenization, subclassing Tokenizer, implementing a new tokenizer, or tokenizing externally and instantiating Doc with words.",,1,C20230706014425567550,0.759864509,0.667360008,0.516346276,0.640045643,0.490175068,0.369282365,0.824387491,0.701083362,0.735948324,0.801692903,0.700652599,0.704246163,0.638424814,0.731001258,0.415748656,0.490435481,0.511229753,0.323748261,0.78009069,0.790194809,0.884078979,0.84232688,0.856219411,0.857872128,14override whitespace splitting
233,70,Spacy,Feature,tokenization,tokenization feature,50908667,Tokenization not working the same for both case.,"I have a document

doc = nlp('x-xxmessage-id:')
When I want to extract the tokens of this one I get 'x', 'xx', 'message' and 'id', ':'. Everything goes well. Then I create a new document

test_doc = nlp('id')
If I try to extract the tokens of test_doc, I will get 'i' and 'd'. Is there any way to get past this problem? Because I want to get the same token as above and this is creating problems in the text processing.","Just like language itself, tokenization is context-dependent and the language-specific data defines rules that tell spaCy how to split the text based on the surrounding characters. spaCy's defaults are also optimised for general-purpose text, like news text, web texts and other modern writing.

In your example, you've come across an interesting case: the abstract string ""x-xxmessage-id:"" is split on punctuation, while the isolated lowercase string ""id"" is split into ""i"" and ""d"", because in written text, it's most commonly an alternate spelling of ""I'd"" or ""i'd"" (""I could"", ""I would"" etc.). You can find the respective rules here.

If you're dealing with specific texts that are substantially different from regular natural language texts, you usually want to customise the tokenization rules or possibly even add a Language subclass for your own custom ""dialect"". If there's a fixed number of cases you want to tokenize differently that can be expressed by rules, another option would be to add a component to your pipeline that merges the split tokens back together.

Finally, you could also try using the language-independent xx / MultiLanguage class instead. It still includes very basic tokenization rules, like splitting on punctuation, but none of the rules specific to the English language.

from spacy.lang.xx import MultiLanguage
nlp = MultiLanguage()",context-dependent tokenization,Spacy's tokenization feature relies on language-specific data to define rules based on surrounding characters.,,1,C20230706015039128403,0.739561021,0.603013575,0.605478525,0.752480626,0.676325202,0.728437006,0.650310934,0.682555914,0.699214995,0.67490685,0.734282732,0.796959877,0.639851809,0.710448265,0.531669617,0.562245846,0.556629241,0.618845105,0.559097886,0.662829936,0.72486186,0.66062206,0.763433039,0.786767244,70context-dependent tokenization
32,10,Spacy,Documentation,documentation,Documentation aspect,48200524,Named entity recognition in Spacy,"I am trying to find Named entities for a sentence as below

import spacy.lang.en
parser = spacy.lang.en.English()
ParsedSentence = parser(u""Alphabet is a new startup in China"")
for Entity in  ParsedSentence.ents:  
    print (Entity.label, Entity.label_, ' '.join(t.orth_ for t in Entity))
I am expecting to get the result ""Alphabet"",""China"" but I am getting an empty set as result. What am I doing wrong here","As per spacy documentation for Name Entity Recognition here is the way to extract name entity

import spacy
nlp = spacy.load('en') # install 'en' model (python3 -m spacy download en)
doc = nlp(""Alphabet is a new startup in China"")
print('Name Entity: {0}'.format(doc.ents))
Result
Name Entity:  (China,) ",importing spacy module,Necessary to perform name entity recognition.,,1,C20230706014345093135,0.513685167,0.507120669,0.605028033,0.779895723,0.813011944,0.951744795,0.374632239,0.388733476,0.418598413,0.693198383,0.69292289,0.806814671,0.509789944,0.569441915,0.727761686,0.727363646,0.69090724,0.660875082,0.454220682,0.537266076,0.484164745,0.803961754,0.862793863,0.832979083,10importing spacy module
168,48,Spacy,Stability,version,Stability aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",native python packages,"Models are now hosted on GitHub and wrapped as native Python packages, which makes managing model dependencies easier.",,1,C20230706015002949755,0.819708765,0.483482391,0.537249684,0.758103311,0.793220818,0.834555864,0.283983499,0.701025784,0.626498818,0.265151709,0.305963576,0.781333327,0.636495233,0.345269322,0.550849915,0.636752963,0.733222961,0.805707037,0.560497463,0.7674613,0.842334509,0.73793292,0.690562308,0.802570701,48native python packages
214,64,GSON,Security,Security,Security aspect,8403277,GSON vulnerabilities or exploits on deserialization to avoid,"I am planning to use gson's fromJson() method to parse a string coming from the browser. Are there any potential vulnerabilities associated with doing that? The data type I am converting to is relatively simple, a List and a boolean. But since gson uses reflection, is there something for me to watch out for?

For example, with older jvm (pre 6.24), a DOS attack could have been used against integers, where the integer parser would hang.

Can some clever json cause gson to start loading classes it should be?","The thing to watch with Gson is what type of builder you are using (see custom deserializer / serializer)

Gson has another weakness, when you are deserializing, (let's say using a custom one) you better check for the type of object you are passing (use instanceof).

Other main point: Gson will automatically convert the variable based on the type being passed.

ie. { ""var1"":1 , ""var2"":""1""} The first one will be converted into an integer, the second based to a string, therefore I would watch out on your objects transformation.",custom builder weakness,Custom deserializer/serializer builders can pose security weaknesses.,Limitation of similarity calculation (large text),1,C20230706015028930329,0.724271178,0.575998008,0.612721086,0.636330962,0.857144833,0.706500173,0.691314459,0.618126512,0.591522753,0.816081822,0.756570637,0.73371017,0.480409324,0.591867924,0.716588974,0.58232677,0.607881725,0.871409357,0.486113816,0.534305811,0.568139374,0.785802603,0.656638205,0.768577337,64custom builder weakness
212,63,GSON,Security,Security,Security aspect,45793451,Kotlin not nullable value can be null?,"I have backend that return me some json.

I parse it to my class:

class SomeData(
  @SerializedName(""user_name"") val name: String,
  @SerializedName(""user_city"") val city: String,
  var notNullableValue: String
)
Use gson converter factory:

Retrofit retrofit = new Retrofit.Builder()
  .baseUrl(ENDPOINT)
  .client(okHttpClient)
  .addConverterFactory(GsonConverterFactory.create(gson))
  .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
  .build();
And in my interface:

interface MyAPI {
    @GET(""get_data"")
    Observable<List<SomeData>> getSomeData();
}
Then I retrieve data from the server (with rxJava) without any error. But I expected an error because I thought I should do something like this (to prevent GSON converter error, because notNullableValue is not present in my JSON response):

class SomeData @JvmOverloads constructor(
  @SerializedName(""user_name"") val name: String,
  @SerializedName(""user_city"") val city: String,
  var notNullableValue: String = """"
)
After the data is received from backend and parsed to my SomeData class with constructor without def value, the value of the notNullableValue == null.

As I understand not nullable value can be null in Kotlin?","Yes, that is because you're giving it a default value. Ofcourse it will never be null. That's the whole point of a default value.

Remove ="""" from constructor and you will get an error.

Edit: Found the issue. GSON uses the magic sun.misc.Unsafe class which has an allocateInstance method which is obviously considered very unsafe because what it does is skip initialization (constructors/field initializers and the like) and security checks. So there is your answer why a Kotlin non-nullable field can be null. Offending code is in com/google/gson/internal/ConstructorConstructor.java:223

Some interesting details about the Unsafe class: http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/",unsafe class,GSON uses sun.misc.Unsafe class which skips initialization and security checks. This can potentially lead to security issues.,,1,C20230706015028509518,0.617154479,0.719537258,0.681997836,0.813786805,0.88661921,0.888808727,0.56125778,0.744349837,0.710848272,0.751307249,0.732490778,0.959379017,0.576045632,0.596705019,0.784672618,0.81206876,0.937720716,0.797784269,0.747309864,0.708594143,0.682469487,0.788847327,0.759229422,0.769766748,63unsafe class
83,24,Spacy,Performance,performance,Performance aspect,66433304,spacy- why nlp() works for single string while nlp.pipe() works fine for a list of strings?,"I recently ran into a strange behavior while using spacy, which is when I process string,

in case the string is a single string object, I have to use nlp(string),

while I have to use nlp.pipe(a list) for a list made of strings elements.
Why is this? I assume this must be something to do with nlp.pipe() behavior which is generator.

What is the reason?","Spacy does this because generators are more efficient. Since generators are consumed only once they are more memory efficient than a list.

According to their documentation instead of processing texts one-by-one and applying nlp pipeline it processes texts in batches.

Furthermore, you can configure batch size in nlp.pipe to optimize performance according to your system

Process the texts as a stream using nlp.pipe and buffer them in batches, instead of one-by-one. This is usually much more efficient.
If your goal is to process large streams of data using nlp.pipe it would be much more efficient to write a streamer/generator to produce results as you need them from database/filesystem than loading everything in memory and then processing them one by one.",efficient generators,Spacy uses generators to efficiently process texts in batches instead of one-by-one.,unknown,1,C20230706014912095974,0.608145535,0.699547172,0.492889225,0.598218977,0.786298096,0.694509923,0.756935418,0.705437124,0.676059842,0.864614964,0.862059474,0.880741954,0.676699638,0.567261398,0.605506599,0.655136764,0.837950528,0.797587395,0.705434382,0.679113805,0.764912903,0.764098823,0.80959326,0.887478054,24efficient generators
276,81,Spacy,Feature,Lemmatization,Lemmatization feature,59636002,Spacy lemmatization of a single word,"I am trying to get the lemmatized version of a single word. Is there a way using ""spacy"" (fantastic python NLP library) to do this.
Below is the code I have tried but this does not work):

from spacy.lemmatizer import Lemmatizer
from spacy.lookups import Lookups
lookups = Lookups()
lemmatizer = Lemmatizer(lookups)
word = ""ducks""
lemmas = lemmatizer.lookup(word)
print(lemmas)
The result I was hoping for was that the word ""ducks"" (plural) would result in ""duck"" (singular). Unfortunately, ""ducks"" (plural) is returned.

Is there a way of doing this?

NOTE: I realize that I could process an entire string of words from a document (nlp(document)) and then find the required token and then get its lemma (token.lemma_), but the word(s) I need to lemmatize are somewhat dynamic and are not able to be processed as a large document.","Otherwise you can keep using spaCy, but after disabling parser and NER pipeline components:

Start by downloading a 12M small model (English multi-task CNN trained on OntoNotes)
$ python -m spacy download en_core_web_sm
Python code
import spacy
nlp = spacy.load('en_core_web_sm', disable=['parser', 'ner']) # just keep tagger for lemmatization
"" "".join([token.lemma_ for token in nlp('ducks')])
Output

> duck",disabling components for lemmatization,The parser and NER pipeline components of Spacy can be disabled when using the library for lemmatization.,,1,C20230706015136936957,0.716127753,0.624765277,0.569627047,0.807534158,0.829122722,0.927022338,0.66068089,0.565410733,0.611609519,0.741900384,0.722001374,0.812865973,0.714437366,0.610984564,0.617642701,0.726786554,0.971091568,0.740375102,0.619506478,0.685083091,0.512331545,0.681726098,0.707506657,0.689700067,81disabling components for lemmatization
211,63,GSON,Security,Security,Security aspect,45793451,Kotlin not nullable value can be null?,"I have backend that return me some json.

I parse it to my class:

class SomeData(
  @SerializedName(""user_name"") val name: String,
  @SerializedName(""user_city"") val city: String,
  var notNullableValue: String
)
Use gson converter factory:

Retrofit retrofit = new Retrofit.Builder()
  .baseUrl(ENDPOINT)
  .client(okHttpClient)
  .addConverterFactory(GsonConverterFactory.create(gson))
  .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
  .build();
And in my interface:

interface MyAPI {
    @GET(""get_data"")
    Observable<List<SomeData>> getSomeData();
}
Then I retrieve data from the server (with rxJava) without any error. But I expected an error because I thought I should do something like this (to prevent GSON converter error, because notNullableValue is not present in my JSON response):

class SomeData @JvmOverloads constructor(
  @SerializedName(""user_name"") val name: String,
  @SerializedName(""user_city"") val city: String,
  var notNullableValue: String = """"
)
After the data is received from backend and parsed to my SomeData class with constructor without def value, the value of the notNullableValue == null.

As I understand not nullable value can be null in Kotlin?","Yes, that is because you're giving it a default value. Ofcourse it will never be null. That's the whole point of a default value.

Remove ="""" from constructor and you will get an error.

Edit: Found the issue. GSON uses the magic sun.misc.Unsafe class which has an allocateInstance method which is obviously considered very unsafe because what it does is skip initialization (constructors/field initializers and the like) and security checks. So there is your answer why a Kotlin non-nullable field can be null. Offending code is in com/google/gson/internal/ConstructorConstructor.java:223

Some interesting details about the Unsafe class: http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/",default value,Default value in Kotlin makes non-nullable values null when parsed by GSON.,,1,C20230706015027646369,0.761155188,0.745684266,0.62768203,0.832230806,0.87184006,0.894520462,0.704755247,0.717007041,0.623547137,0.726352215,0.639136612,0.791166186,0.662043631,0.782299221,0.637487292,0.676586628,0.709312379,0.786807418,0.733410537,0.645252287,0.330053002,0.633651137,0.22767964,0.549759328,63default value
114,33,Spacy,Stability,bug,Stability aspect,40595828,"Retrieving the start and end character indices in the original document, for those sentences returned by Spacy","I am using something similar to the following pattern to retrieve the start and end indices of Spacy's sentences in the original document:
This seems to work for those few test docs I used. But worried if I am overlooking any 'gotchas' like spacy sometimes stripping off some characters that I am not aware of . Am I?

PS: If it helps, I need these indices to compare with indices I have from Brat's annotation file.","You should just be able to use the sent.start_char and sent.end_char attributes. These give exactly the indices you're after: https://spacy.io/docs/api/span#attributes

Also doc.text should always equal the original full text. If it doesn't, please submit a bug report.",documentation available,Spacy provides documentation that directly addresses how to retrieve start and end character indices.,,1,C20230706014932685002,0.57331419,0.576432467,0.569430828,0.464844197,0.565035343,0.558729351,0.551038861,0.436605811,0.47121346,0.539188147,0.778398454,0.63314575,0.772013068,0.686054468,0.529757321,0.476620257,0.578720868,0.480582267,0.598423541,0.546986341,0.641529739,0.634238243,0.693855047,0.521256804,33documentation available
136,39,Spacy,Stability,bug,Stability aspect,75724665,How to maximize performance of spaCy on an M1 Mac (currently much slower than Intel),"I've observed that nlp.pipe is 30-40% slower on my almost brand new M1 Pro Macbook than on my old Macbook Pro from 2017. Most other functions are faster on the M1 by a similar margin, so this is not the performance I would expect.

For a benchmark, I'm running the following code (with scispacy):

My M1 Mac takes over 75 seconds to complete the task, while my 2017 Intel Mac can do it in 46 seconds.

I don't know whether spacy uses numpy, but I installed a fast version of numpy using ABarrier's answer to this question. That made numpy faster, but made no difference for spacy. I'm assuming that somewhere there is an unoptimized binary being used, but I don't know how to figure out what it is.
","Install the package thinc-apple-ops:

pip install thinc-apple-ops
Or through the spacy extra:

pip install 'spacy[apple]'
(The unoptimized package is blis. We'd like to be able to switch to a newer version of BLIS with M1 support, but there are still some open bugs.)",recommendation from spacy team,The recommended solution from the Spacy team implies that the library is generally stable and the team is actively working to address performance issues.,,0,C20230706014944065290,0.708184242,0.607684135,0.528348804,0.654121697,0.692945123,0.670188785,0.444242328,0.640801132,0.511944652,0.714442968,0.822922349,0.762849212,0.727306604,0.736156762,0.528065205,0.459970355,0.491521239,0.51775527,0.387821585,0.539423764,0.421303332,0.842728853,0.796517849,0.800558329,39recommendation from spacy team
45,13,Spacy,Documentation,documentation,Documentation aspect,74550422,Concatenate two spacy docs together?,"How do I concatenate two spacy docs together? To merge them into one?

import spacy

nlp = spacy.load('en')
doc1 = nlp(u'This is the doc number one.')
doc2 = nlp(u'And this is the doc number two.')
new_doc = doc1+doc2
Of course that will return an error as a doc object is not concatenable by default. Is there a straightforward solution to do that?

I looked at this: https://github.com/explosion/spaCy/issues/2229 The issue seems closed so it sounds like they have implemented a solution but I cannot find a simple example of that being used.","What about this:
For ""a lot"" of different sentences, it might be better to use nlp.pipe as shown in the documentation.

Hope it helps.",reference to github issue,The conversation references an issue on Github where the problem of concatenating Spacy docs together has been discussed by the Spacy community.,Question not focused on main topic,0,C20230706014422749354,0.768780172,0.667063951,0.614293337,0.884396791,0.552888095,0.494668365,0.78924948,0.701657593,0.723372638,0.552198708,0.543065608,0.818472683,0.779043674,0.465014935,0.485280216,0.745360672,0.497389287,0.576629519,0.676079988,0.550915301,0.634057403,0.615804255,0.611257315,0.582135916,13reference to github issue
294,86,Spacy,Feature,NER,NER feature,68682465,pattern match issue with SpaCy,"I have the following script using a pattern to match the postcode. However, depending on how I supply the postcode string seems to affect how it is matched.

It would appear that for some reason the first postcode is never matched. In the last example both ""RH5 0XE"" & ""PO01 0IO"" should match, as you can see ""RH5 0XE"" matched in the previous run.

Any ideas on how I can improve the match rate?","Put the entity_ruler before ner in the pipeline so that its matches have priority over the CARDINAL spans from ner, or alternatively you can set it to overwrite overlapping entities with the overwrite_ents setting.",higher match rate,"These features of Spacy improve the match rate of NER pattern matching, making it an effective tool for text analysis and entity recognition.",,0,C20230706015218223542,0.663429081,0.695403516,0.55657655,0.748505592,0.649201751,0.459655046,0.714761794,0.808962405,0.520561039,0.800736248,0.504608512,0.525185704,0.677333832,0.579454601,0.711937368,0.630414367,0.50835824,0.552512586,0.607978821,0.572709739,0.326037675,0.51738441,0.311213285,0.484808564,86higher match rate
296,87,Spacy,Feature,NER,NER feature,46934523,How to get spaCy NER probability,"I want to combine spaCy's NER engine with a separate NER engine (a BoW model). I'm currently comparing outputs from the two engines, trying to figure out what the optimal combination of the two would be. Both perform decently, but quite often spaCy finds entities that the BoW engine misses, and vice versa. What I would like is to access a probability score (or something similar) from spaCy whenever it finds an entity that is not found by the BoW engine. Can I get spaCy to print out its own probability score for a given entity it has found? As in, ""Hi, I'm spaCy. I've found this token (or combination of tokens) that I'm X% certain is an entity of type BLAH."" I want to know that number X every time spaCy finds an entity. I imagine there must be such a number somewhere internally in spaCy's NER engine, plus a threshold value below which the possible entity is not flagged as an entity, and I'd like to know how to get my hands on that number. Thanks in advance.","Actually, there is an issue for that.

The author of the library, suggests there (among others) the following solution:

Beam search with global objective. This is the standard solution: use a global objective, so that the parser model is trained to prefer parses that are better overall. Keep N different candidates, and output the best one. This can be used to support confidence by looking at the alternate analyses in the beam. If an entity occurs in every analysis, the NER is more confident it's correct.

mportant note: The outputs you will get here are probably different from the outputs you would get using the Standard NER and not the beam search alternative. However, the beam search alternative provides you a metric of confidence that as I understand from your question is useful for your case.
",beam search with global objective supported,"The author suggests using beam search with global objective to support confidence, which can provide useful metrics. This shows that Spacy has provisions for providing confidence scores for identifying entities and is a capable library for NER tasks.",,1,C20230706015218739626,0.696494341,0.705963492,0.769346237,0.837965369,0.752048731,0.834505081,0.601496518,0.687764585,0.719466865,0.850061119,0.603525758,0.671875298,0.708908498,0.716247499,0.621128857,0.878096104,0.483588815,0.535243213,0.702970326,0.700028002,0.649142981,0.926677227,0.859678745,0.875886023,87beam search with global objective supported
125,36,Spacy,Stability,bug,Stability aspect,62796437,Spacy French langage gives NoneType error,"Here is the code :

import spacy
nlp = spacy.load('fr_core_news_sm')
doc = nlp('Demain je travaille ‚Äö√†√∂‚Äö√Ñ‚Ä† la maison')
for token in doc:
    print(token.text)
It gives the error :

File ""c:\users\ab\appdata\local\programs\python\python37\lib\site-packages\spacy\lang\fr\lemmatizer.py"", line 49, in call if self.is_base_form(univ_pos, morphology): TypeError: 'NoneType' object is not callable
If I change 'fr_core_news_sm' to 'en_core_web_sm', it works well.

My python version is 3.7.7. And Spacy version is 2.3.1.","This seems to be a bug at spaCy 2.3.1: https://github.com/explosion/spaCy/issues/5728

Downgrade to 2.3.0 and it should work: pip install spacy==2.3.0",multilingual modules,"The availability of spaCy modules for multiple languages, including French, demonstrates the library's testing and development for use in different languages.",,0,C20230706014937782194,0.783154786,0.816237509,0.530032814,0.734561563,0.849201381,0.758928835,0.406812936,0.706025422,0.546886325,0.71035707,0.553280473,0.591612518,0.493766576,0.769802511,0.482611537,0.618639171,0.714402556,0.706723213,0.622626066,0.539953589,0.506525218,0.606726468,0.735568762,0.512322962,36multilingual modules
41,12,Spacy,Documentation,documentation,Documentation aspect,50189238,How to re-train an existing spacy NER model for currency,"I am trying to update an existing spacy model ""en_core_web_sm"" with some different country currency such as ""euro"", ""rupees"", ""eu"", ""Rs."", ""INR"" etc. How can I achieve that ? The spacy tutorial didn't quite help me as training a fixed string such as ""horses"" as ""ANIMAL"" seems different than my requirements. The reason is I can have currency value indifferent formats : ""1 million euros"", ""Rs. 10,000"", ""INR 1 thousand"" etc. My sample dataset contains around 1000 samples with the following format :

TRAIN_DATA = [      
 ("" You have activated International transaction limit for Debit Card ending XXXX1137 on 2017-07-05 12:48:20.0 via NetBanking. The new limit is Rs. 250,000.00"", {'entities' : [(140, 154, 'MONEY')] }),...
]
Can anyone please help me out with this with the data format, training size or any other relevant information ?","The example from the documentation should work for you. I altered it a little to match your variable name.

optimizer = nlp.begin_training()

for itn in range(100):
    random.shuffle(train_data)
    for raw_text, entity_offsets in TRAIN_DATA:
        doc = nlp.make_doc(raw_text)
        gold = GoldParse(doc, entities=entity_offsets)
        nlp.update([doc], [gold], drop=0.5, sgd=optimizer)
nlp.to_disk('/model')
Link to Documentation",solution overview,"The provided example shows how to retrain an existing Spacy NER model for currency, with different currency values in various formats.",,1,C20230706014348657773,0.581239223,0.662244678,0.500857115,0.802165508,0.654963493,0.475544751,0.669694483,0.735188246,0.533022106,0.600286603,0.345095068,0.475013316,0.560764074,0.641153395,0.589899063,0.496061027,0.647057176,0.281075835,0.725123107,0.496547848,0.553671241,0.553234935,0.491137713,0.309089065,12solution overview
138,40,Spacy,Stability,bug,Stability aspect,57109492,PhraseMatcher to match in a different token attribute,"We would like to match a set of phrases using PhraseMatcher. However we whould like to match not only on the verbatim text, but a normalized version of the input. For instance, lower case, with the accents removed, etc.

We have tried to add a custom attibute to the Token, and use it in the init of the PhraseMatcher to match it but, it did not work.

We could transform the text using a custom pipeline but we want to keep the original text to be able to use other components of spacy.
What is the way to do this?","Since EntityRuler is based on PhraseMatcher, I copy here a working example with Spacy v2.2.0. Follow the comments to understand how to work with ""NORM"" attribute from tokens.

At the end, you can see how the word ""F‚Äö√†√∂‚àö√ñCIL"" matches the pattern ""facil"", since it has been normalized.
This bug was fixed in release v2.1.8 https://github.com/explosion/spaCy/issues/4002",active maintenance,"The Spacy team referenced a specific version number, indicating active maintenance and updates.",,1,C20230706014945805788,0.665796995,0.514179528,0.662293375,0.534879863,0.749449015,0.461599857,0.672193706,0.621998787,0.633848011,0.854443491,0.858144104,0.86551106,0.812691927,0.691530228,0.681756377,0.55742842,0.611020565,0.331748068,0.676313579,0.55625689,0.706321478,0.809043229,0.628585875,0.657036722,40active maintenance
108,31,Spacy,Performance,speed,Performance aspect,52897492,spaCy: optimizing tokenization,"I'm currently trying to tokenize a text file where each line is the body text of a tweet:
The file is 59,397 lines long (a day's worth of data) and I'm using spaCy for pre-processing/tokenization. It's currently taking me around 8.5 minutes and I was wondering if there were any way of optimising the following code to be quicker as 8.5 minutes seems awfully long for this process:Although it says files, it's currently only looping over 1 file.

Just to note, I only need this to tokenize the content; I don't need any extra tagging etc.","It sounds like you haven't optimised the pipeline yet. You'll get a significant speed up from disabling the pipeline components you don't need, like so:

nlp = spacy.load('en', disable=['parser', 'tagger', 'ner'])    
This should get you down to about the two-minute mark, or better, on its own.

If you need a further speed up, you can look at multi-threading using nlp.pipe. Docs for multi-threading are here: https://spacy.io/usage/processing-pipelines#section-multithreading",disable parser/tagger/ner,"The user can disable the parser, tagger, and NER to improve performance.",,1,C20230706014928864783,0.654274464,0.503306389,0.619517207,0.681990743,0.938699365,0.688219905,0.719391763,0.73422277,0.691450894,0.827944398,0.880685687,0.756989539,0.635017991,0.766278684,0.49863255,0.44026044,0.514868379,0.609384775,0.787897587,0.282050282,0.684954405,0.321585864,0.853377521,0.295033038,31disable parser/tagger/ner
91,26,Spacy,Performance,fast,Performance aspect,59830899,sense2vec performance improvemets,"I am using Sense2Vec (builds upon Spacy, a fantastic NLP library/tool) and testing the similarity between various words. Unfortunately the performance is quite slow (execution is over a second on a regular MacBook Pro).

Does anyone have a way to speed this up?

Here is the code:

term = ""dog|NOUN""
sense2vec = Sense2Vec().from_disk(""path-to-s2v_reddit_2019_lg"")
sims = sense2vec.most_similar(term, n=top)
I suspect some caching would speed things, but I am not sure which elements should be cached.
","There is indeed a way to speed up Sense2Vec.most_similar. There is a script available from https://github.com/explosion/sense2vec/blob/master/scripts/06_precompute_cache.py, which precomputes a cache of the nearest neighbors. It will then save that cache with the component on disk, making the data larger but the queries fast. If a query is not covered by the cache, most_similar falls back to using the normal computation.",script available on github,"A script for precomputing the cache is available on Github, which, when saved on disk with the component, can make queries faster.",,1,C20230706014917331461,0.811055779,0.546880722,0.770134211,0.705530941,0.541134953,0.604707956,0.589470327,0.750534773,0.362948149,0.45327872,0.689382911,0.308007896,0.389600068,0.462230772,0.545483589,0.465055108,0.570279539,0.491431326,0.710781336,0.760806322,0.750529885,0.738857627,0.901259422,0.794720411,26script available on github
172,49,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",prompt response time,"The spaCy maintainer provided a prompt response to the user's issue, indicating an active and responsive maintenance process.",,1,C20230706015003997792,0.789124668,0.593991578,0.48459366,0.74794668,0.848889053,0.814795196,0.763793647,0.821200371,0.778820515,0.634559333,0.787407815,0.68703866,0.642180324,0.610218465,0.652858019,0.677033544,0.730708778,0.636685908,0.834109545,0.819866896,0.806218684,0.788606167,0.758270741,0.781776369,49prompt response time
16,5,Spacy,Ease of use,difficult,Ease of use aspect,67789544,Given a word can we get all possible lemmas for it using Spacy?,"The input word is standalone and not part of a sentence but I would like to get all of its possible lemmas as if the input word were in different sentences with all possible POS tags. I would also like to get the lookup version of the word's lemma.

Why am I doing this?

I have extracted lemmas from all the documents and I have also calculated the number of dependency links between lemmas. Both of which I have done using en_core_web_sm. Now, given an input word, I would like to return the lemmas that are linked most frequently to all the possible lemmas of the input word.

So in short, I would like to replicate the behaviour of token._lemma for the input word with all possible POS tags to maintain consistency with the lemma links I have counted.","I found it difficult to get lemmas and inflections directly out of spaCy without first constructing an example sentence to give it context. This wasn't ideal, so I looked further and found LemmaInflect did this very well.",found workaround with lemmainflect,The user found a solution by using LemmaInflect instead of Spacy to get the desired output of lemmas and inflections.,,1,C20230706014334528606,0.645242989,0.741923153,0.580355942,0.704007745,0.759607434,0.742693424,0.655893207,0.766124606,0.730674148,0.76768887,0.781968653,0.849427998,0.671190381,0.654558837,0.691597879,0.899677217,0.657990694,0.618521988,0.734619856,0.725553095,0.647116184,0.763812661,0.714659035,0.907198787,5found workaround with lemmainflect
139,40,Spacy,Stability,bug,Stability aspect,57109492,PhraseMatcher to match in a different token attribute,"We would like to match a set of phrases using PhraseMatcher. However we whould like to match not only on the verbatim text, but a normalized version of the input. For instance, lower case, with the accents removed, etc.

We have tried to add a custom attibute to the Token, and use it in the init of the PhraseMatcher to match it but, it did not work.

We could transform the text using a custom pipeline but we want to keep the original text to be able to use other components of spacy.
What is the way to do this?","Since EntityRuler is based on PhraseMatcher, I copy here a working example with Spacy v2.2.0. Follow the comments to understand how to work with ""NORM"" attribute from tokens.

At the end, you can see how the word ""F‚Äö√†√∂‚àö√ñCIL"" matches the pattern ""facil"", since it has been normalized.
This bug was fixed in release v2.1.8 https://github.com/explosion/spaCy/issues/4002",thorough response,The Spacy team provided specific code examples and referred to a recent bug fix.,,1,C20230706014945394213,0.650932133,0.628741503,0.754859149,0.809902847,0.882152855,0.752228618,0.54800874,0.608691454,0.659810007,0.809388638,0.945705414,0.864524841,0.558617353,0.552904427,0.672892749,0.441723108,0.624943078,0.54124707,0.602849364,0.705416143,0.755157828,0.742064238,0.648786187,0.861749232,40thorough response
268,78,Spacy,Feature,dependency parsing,dependency parsing feature,39258476,Collocations with spaCy,"I've been using NLTK for finding collocations, or n-grams, and have recently discovered the spaCy module for NLP. I've only just begun familiarizing myself with it and have, thus far, seen little mention for supported collocation functions.

Can spaCy be used to find collocations directly?

I have read through the documentation, but haven't seen mention.","Collocations detection also can be based on dependency parsing, but spaCy do not have support to do it. You can use spaCy as part of an approach, but not directly.

may you also consider gensim: https://radimrehurek.com/gensim/models/phrases.html

I hope it can help you",spacy as part of approach,"Although not directly supporting collocation detection based on dependency parsing, Spacy can be used as part of an approach in detecting collocations.",,0,C20230706015059267312,0.616425157,0.550079763,0.705255866,0.830010951,0.756050467,0.771887541,0.714206576,0.575141191,0.860251069,0.830949068,0.689819098,0.611802876,0.487732798,0.537284732,0.442623556,0.897517443,0.770617485,0.728907108,0.799113989,0.788645744,0.748831213,0.907731056,0.928057015,0.884703517,78spacy as part of approach
191,55,Spacy,Active Maintenance,github,Active Maintenance aspect,58327580,How to add new lemma rule to existing language for spacy,"I want to add a new lemmatiser rule for an existing language, i.e. lemmatise all nouns ending with ""z"" to ending with """".

In the case of individual words, spaCy gives the opportunity to add a tokeniser exception to an existing language after loading using

nlp.tokenizer.add_special_case(""adidas"", [{ORTH: 'adidas', LEMMA: 'Adidas', POS: 'NOUN', TAG: 'NNP'}])
The above sets the lemma, pos and tag of the new word and this is not altered. The default English lemmatiser returned ""adida"" as the lemma.

Now, I am trying to ""lemmatise"" nouns ""wordz"" to ""word"", ""windowz"" to ""window"" etc without setting all cases as exceptions but rather add a new rule: Noun ending with ""z"" has lemma the noun without the trailing ""z"".

I understand that it will depend on the tagger output as the rules that exist in _lemma_rules.py are pos dependent.

Is there a way to add the rule without creating a new language as a copy of an existing with just one modified file?","Since my question was very specific, I had to communicate with the spaCy developer team and got a working answer.

Actually it is does not work for the fake example in English but it works in real case scenario while using the Greek models as Greek lemmatisation is mainly rule based.

The proposed solution is to use the Lookups Api, which is only available in versions 2.2 and later.

As they mention,

nlp.vocab.lookups.get_table(""lemma_rules"") 
returns a dict-like table that you can write to.

Full answer in spaCy GitHub",newer version with lookups api,"The suggestion of using the Lookups API, which is only available in newer versions of Spacy, suggests that the library is continuously updated and improved with new features.",,1,C20230706015016118078,0.677569091,0.784634173,0.629437089,0.765200555,0.871156394,0.64063859,0.940053284,0.810110688,0.862828851,0.807423055,0.849733114,0.79292959,0.541199207,0.722122431,0.616873384,0.64496696,0.68755734,0.658527493,0.590007365,0.761985183,0.838096082,0.771829844,0.807806015,0.847243071,55newer version with lookups api
160,46,Spacy,Stability,version,Stability aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",library maintenance,"The respondent is a maintainer of the spaCy library, indicating that the library has a dedicated team of developers actively working on it.",,0,C20230706014958946853,0.738049865,0.793303728,0.637259543,0.866061211,0.712896109,0.781635344,0.757506192,0.738433123,0.588458419,0.884587467,0.781771481,0.84516567,0.65082854,0.685173213,0.428342193,0.764797747,0.648911297,0.812956691,0.707897723,0.650143623,0.069000386,0.799764156,0.065044723,0.153158888,46library maintenance
187,54,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,72068918,"Python NLP Spacy : improve bi-gram extraction from a dataframe, and with named entities?","I am using Python and spaCy as my NLP library, working on a big dataframe that contains feedback about different cars, which looks like this:

enter image description here

'feedback' column contains natural language text to be processed,
'lemmatized' column contains lemmatized version of the feedback text,
'entities' column contains named entities extracted from the feedback text (I've trained the pipeline so that it will recognise car models and brands, labelling these as 'CAR_BRAND' and 'CAR_MODEL')
I then created the following function, which applies the Spacy nlp token to each row of my dataframe and extract any [noun + verb], [verb + noun], [adj + noun], [adj+ proper noun] combinations.
This is where I have a problem...

This is producing only one bigram per row maximum. How can I tweak the code so that more than one bigram can be extracted and put in a column? (Also are there more linguistic combinations I should try?)
Is there a possibility to find out what people are saying about 'CAR_BRAND' and 'CAR_MODEL' named entities extracted in the 'entities' column? For example 'Cool Porsche' - Some brands or models are made of more than two words so it's tricky to tackle.
I am very new to NLP.. If there is a more efficient way to tackle this, any advice will be super helpful! Many thanks for your help in advance.","spaCy has a built-in pattern matching engine that's perfect for your application ‚Äö√Ñ√∂‚àö√ë‚àö¬® it's documented here and in a more extensive usage guide. It allows you to define patterns in a readable and easy-to-maintain way, as lists of dictionaries that define the properties of the tokens to be matched.

Some ideas for improvement

Named entity recognition should be able to detect multi-word expressions, so brand and/or model names that consist of more than one token shouldn't be an issue if everything is set up correctly
Matching dependency patterns instead of linear patterns might slightly improve your results
That being said, what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® kind of sentiment analysis -is quite a difficult task that's normally engaged with machine learning approaches and heaps of training data. So don't expect too much from simple heuristics.
",active development,"Overall, the conversation suggests that spaCy is well-maintained and has a knowledgeable and helpful community supporting it, indicating active development.",,1,C20230706015015059649,0.624072194,0.491588831,0.503252685,0.726264954,0.785347164,0.741833627,0.72527194,0.724377096,0.637003958,0.905794203,0.776326001,0.821567953,0.672469139,0.566726089,0.532369554,0.641488254,0.632368743,0.574138165,0.647798181,0.5570122,0.448086113,0.678557515,0.764163673,0.775295377,54active development
305,90,Spacy,Feature,Entity linking,Entity linking feature,60922171,Spacy - entity linker - why is the predict score a combination of prob and cosine sim?,"I was going through the predict method for the entity linker pipe under spacy, and for some reason the score is defined as the following :

scores = prior_probs + sims - (prior_probs*sims)

Link here

Anybody has experience with this / knows where this formula comes from?

Thanks!","It is taken from Entity Linking via Joint Encoding of Types, Descriptions, and Context section 4 equation 2.

I don't feel confident enough though in explaining the formula in detail, on overall the purpose is to combine probability scores for entitiy candidates derived from external knowledge based resources (KB in the paper), which are the prior probabilities, and scores estimated with a sentence encoder, used to encode the mention to link along with its context, sims in the formula because they compute cosine similarity between the encoded mention vector and all entity candidates (which is why this formula is used only if ""incl_context"" is true).",context score,"Spacy includes context scores for entity linking by computing cosine similarity between the mention vector and entity candidates, which is why the formula is used only if 'incl_context' is true.",,1,C20230706015225592152,0.800432622,0.685803354,0.775074601,0.511013269,0.795738161,0.662778735,0.830253601,0.832693756,0.748348415,0.77024442,0.753641069,0.773454845,0.701564968,0.612925649,0.83071214,0.59054637,0.60914731,0.506490707,0.733681679,0.813088417,0.705015719,0.735581338,0.615805745,0.705870867,90context score
224,67,GSON,Security,attack,Security aspect,53661408,Retrofit2 strange combination of different braces in front of request Body,"I am using Retrofit2 and I got stuck on the problem. I wrote simple entity for body:
also I wrote custom serializer for it:
DateTimeUtil:
and in request body somehow appears this:
How this "")]}'"" could be attached at front of my ""date"" json in request?
Only that I found is after JsonWriter do some magic in buffer.readByteString() it stores broken body.","I found where was the problem comes from:

Here my custom GsonBuilder:

private fun getGsonFactory(): Gson {
        return GsonBuilder()
            .setLenient()
            .serializeSpecialFloatingPointValues()
            .setLongSerializationPolicy(LongSerializationPolicy.DEFAULT)
            .generateNonExecutableJson()
            .enableComplexMapKeySerialization()
            .serializeNulls()
            .setPrettyPrinting()
            .registerTypeAdapter(CleaningProgress::class.java, CleaningProgressDeserializer())
            .create()
    }
The line of code below, add that "")]}'"" at front of request. Why am I add it to builder? I trust official documentation about this method:

Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some special text. This prevents attacks from third-party sites through script sourcing.",use of method,generateNonExecutableJson() adds a special prefix to the JSON output to make it non-executable in JavaScript and prevent potential attacks from third-party sites through script sourcing.,,1,C20230706015034064138,0.843494594,0.856287479,0.463882774,0.876705408,0.362906426,0.451260895,0.90493691,0.839741051,0.78452915,0.80288589,0.742669761,0.7948699,0.684406877,0.823671401,0.50089258,0.67980653,0.311622709,0.385711372,0.906734526,0.814171553,0.856670976,0.780620992,0.850496531,0.7814008,67use of method
313,92,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,56416641,separate texts into sentences NLTK vs spaCy,"I want to separate texts into sentences.

looking in stack overflow I found:

WITH NLTK

from nltk.tokenize import sent_tokenize
text=""""""Hello Mr. Smith, how are you doing today? The weathe is great, and city is awesome. The sky is pinkish-blue. You shouldn't eat cardboard""""""
tokenized_text=sent_tokenize(text)
print(tokenized_text)
WITH SPACY

from spacy.lang.en import English # updated

raw_text = 'Hello, world. Here are two sentences.'
nlp = English()
nlp.add_pipe(nlp.create_pipe('sentencizer')) # updated
doc = nlp(raw_text)
sentences = [sent.string.strip() for sent in doc.sents]
The question is what in the background for spacy having to do it differently with a so called create_pipe. Sentences are important for training your own word embedings for NLP. There should be a reason why spaCy does not include directly out of the box a sentence tokenizer.

Thanks.

NOTE: Be aware that a simply .split(.) does not work, there are several decimal numbers in the text and other kind of tokens containing '.'","By default, spaCy uses its dependency parser to do sentence segmentation, which requires loading a statistical model. The sentencizer is a rule-based sentence segmenter that you can use to define your own sentence segmentation rules without loading a model.

If you don't mind leaving the parser activated, you can use the following code:

import spacy
nlp = spacy.load('en_core_web_sm') # or whatever model you have installed
raw_text = 'Hello, world. Here are two sentences.'
doc = nlp(raw_text)
sentences = [sent.text.strip() for sent in doc.sents]",advantages of parser,The dependency parser is more accurate and can handle complex sentences.,No answer available against the challenge,0,C20230706015229224024,0.545129716,0.785509706,0.533809364,0.701608777,0.851651609,0.684278429,0.541980505,0.77719903,0.665728152,0.733562946,0.709724307,0.743034661,0.469359159,0.564183533,0.519000709,0.66627723,0.660562336,0.569739819,0.385218769,0.474853009,0.398484886,0.602885246,0.564458311,0.747298121,92advantages of parser
150,43,Spacy,Stability,backwards compatibility,Stability aspect,54201004,Multithreading with spacy: Is joblib necessary?,"In this part of the documentation, it is mentioned that nlp.pipe() works in parallel and the following example is given:

for doc in nlp.pipe(texts, batch_size=10000, n_threads=3):
    pass
After that, another, longer example is given that makes use of joblib. I don't quite understand the relationship between the two. As I understand the documentation, if I simply want to parallelize the tokenisation of many documents, the above, simple for loop will work and I do not have to use joblib, right?

My pipeline looks like this:

nlp = spacy.load('en', disable=['parser', 'ner', 'textcat'])
When would I need to use joblib?","Based on an answer in Spacy github issues:

We kept the n_threads argument to avoid breaking people's code, but unfortunately the implementation doesn't currently release the GIL, the way we did in v1. In v2 the neural network model is more complicated and more subject to change, so we haven't implemented it in Cython. We might at a later date.

In v2.1.0 (you can get an alpha by installing spacy-nightly, the matrix multiplications are now single-threaded. This makes it safe to launch multiple processes for the pipeline, so we can look at doing that internally. In the meantime, the n_threads argument sits idle...Which I agree is confusing, but removing it and breaking backwards compatibility seems worse.
Thus, to summarize: n_threads doesn't work in v2.1. What I'm doing now is using Spacy with joblib to read a dataset in minibatches.

Spacy released an example for that: Spacy Multiprocessing, and it works perfectly.

I have a dataset with almost ~4M short text. Without using the example they released, it took almost 23 hours to finish parsing them, but using joblib with spacy, it took 1 hour and half to finish!

To reference the readers of this question to Spacy Multiprocessing example: Spacy Multiprocessing",joblib efficacy,"Users report significant reductions in processing time, such as 1 hour and a half for parsing almost 4M short texts, making joblib a reliable alternative to Spacy's multithreading functionality.",,1,C20230706014954559329,0.50394237,0.517980635,0.492486984,0.595808506,0.558773637,0.78774637,0.809244335,0.552440464,0.720008314,0.587130666,0.601930022,0.626246572,0.568618059,0.552795589,0.484051168,0.472180903,0.455081731,0.458724409,0.608125329,0.446906745,0.633892179,0.722062528,0.850479722,0.797278166,43joblib efficacy
1,1,Spacy,Ease of use,simple,Ease of use aspect,62766608,Is there a simple way to get the position of a token in sequence with spacy?,"I want to the start index and the end index of every token in a sequence. Is there a simple way to do that with spacy?
","import spacy

text = 'Brown is a nice guy'
nlp = spacy.load(""en_core_web_sm"")
doc = nlp(text)

for token in doc:
  print(token.text, token.idx, token.idx + len(token.text) - 1)",installation is easy,Installing and loading the Spacy library is a straightforward process that can be accomplished in just a few lines of code.,No answer available against the challenge,0,C20230706014104560978,0.661655426,0.64172864,0.61571002,0.513161361,0.495149076,0.554512918,0.255483657,0.446300596,0.392433822,0.667995632,0.291717947,0.246943191,0.526397288,0.5700562,0.505125284,0.532849312,0.421052247,0.562051654,0.788025618,0.64606756,0.585741162,0.590550423,0.586131036,0.61711961,1installation is easy
188,54,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,72068918,"Python NLP Spacy : improve bi-gram extraction from a dataframe, and with named entities?","I am using Python and spaCy as my NLP library, working on a big dataframe that contains feedback about different cars, which looks like this:

enter image description here

'feedback' column contains natural language text to be processed,
'lemmatized' column contains lemmatized version of the feedback text,
'entities' column contains named entities extracted from the feedback text (I've trained the pipeline so that it will recognise car models and brands, labelling these as 'CAR_BRAND' and 'CAR_MODEL')
I then created the following function, which applies the Spacy nlp token to each row of my dataframe and extract any [noun + verb], [verb + noun], [adj + noun], [adj+ proper noun] combinations.
This is where I have a problem...

This is producing only one bigram per row maximum. How can I tweak the code so that more than one bigram can be extracted and put in a column? (Also are there more linguistic combinations I should try?)
Is there a possibility to find out what people are saying about 'CAR_BRAND' and 'CAR_MODEL' named entities extracted in the 'entities' column? For example 'Cool Porsche' - Some brands or models are made of more than two words so it's tricky to tackle.
I am very new to NLP.. If there is a more efficient way to tackle this, any advice will be super helpful! Many thanks for your help in advance.","spaCy has a built-in pattern matching engine that's perfect for your application ‚Äö√Ñ√∂‚àö√ë‚àö¬® it's documented here and in a more extensive usage guide. It allows you to define patterns in a readable and easy-to-maintain way, as lists of dictionaries that define the properties of the tokens to be matched.

Some ideas for improvement

Named entity recognition should be able to detect multi-word expressions, so brand and/or model names that consist of more than one token shouldn't be an issue if everything is set up correctly
Matching dependency patterns instead of linear patterns might slightly improve your results
That being said, what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® kind of sentiment analysis -is quite a difficult task that's normally engaged with machine learning approaches and heaps of training data. So don't expect too much from simple heuristics.
",resources offered,"The responder provided links to spaCy documentation and usage guides, indicating that the library is well-maintained and provides helpful resources for its users.",unknown,0,C20230706015014049568,0.750483334,0.649863482,0.4729774,0.710843921,0.620011508,0.549174726,0.790728092,0.899864018,0.724591315,0.696566343,0.731070518,0.774742663,0.556534708,0.725925446,0.519372702,0.566229045,0.661818206,0.551291823,0.504580498,0.713630557,0.586656511,0.795770705,0.763911009,0.666259527,54resources offered
3,1,Spacy,Ease of use,simple,Ease of use aspect,62766608,Is there a simple way to get the position of a token in sequence with spacy?,"I want to the start index and the end index of every token in a sequence. Is there a simple way to do that with spacy?
","import spacy

text = 'Brown is a nice guy'
nlp = spacy.load(""en_core_web_sm"")
doc = nlp(text)

for token in doc:
  print(token.text, token.idx, token.idx + len(token.text) - 1)",spacy is user-friendly,"Spacy provides a simple way to get the position of a token in sequence, making it a user-friendly library for natural language processing tasks.",,1,C20230706014104098379,0.594824135,0.531080663,0.658812284,0.82746911,0.533659995,0.582172632,0.34579286,0.859849274,0.827571929,0.328387976,0.307799608,0.791693687,0.615675807,0.731584191,0.722863674,0.477924079,0.463525265,0.745779037,0.896194935,0.639520884,0.726512849,0.641892076,0.699656129,0.71418035,1spacy is user-friendly
153,44,Spacy,Stability,backwards,Stability aspect,52598788,spaCy: custom attributes not matching correctly?,"I have been having problems using custom extension attributes with the recently improved Matcher (spaCy 2.012). Even a simple example (mostly copied from here) is not working as I expected:
In other words, the rule correctly matches on the span 'have' (1, 2), but incorrectly matches 'have' (5, 6) and 'had' (6, 7). Furthermore, the callback function is not called. The custom attribute appears to be ignored.
The first rule functions as above. Then the second rule triggers, along with the callback function (which prints the message). There is an additional correct match for the new pattern along with the correct and erroneous matches from the first rule.

So, I have a few questions:

why does pattern1 match incorrectly? (i.e. why does the _ custom attribute constraint not apply?)
why does the callback function not work on the first call?
why does it work upon addition of a new rule?
In my own code, when using custom attributes as constraints in subsequent patterns, these patterns match on ALL tokens. I assume this is related to the behaviour exhibited by the code above.","Sorry if this was confusing ‚Äö√Ñ√∂‚àö√ë‚àö¬® but the GitHub thread you're referring to is still only the spec and proposal, i.e. the planned implementation. The changes will hopefully ship with spaCy v2.1.0 (since some of the changes to the Matcher internals are not fully backwards compatible).

While the custom attribute matching isn't implemented yet, the basic improvements to the Matcher engine are already available on the develop branch and in the alpha version via spacy-nightly (pip install spacy-nightly). Those updates likely also resolve the inconsistent behaviour you observed with the callback function.",active development and improvement,"Overall, while the specific feature being discussed may not be fully stable or well tested yet, spaCy as a whole seems to be in active development and improving.",,1,C20230706014956669212,0.609602928,0.684435248,0.468466967,0.682589471,0.580143571,0.519405365,0.621452093,0.785187125,0.610821307,0.799151897,0.730823398,0.806928694,0.454808563,0.621787548,0.412377685,0.544463098,0.433462232,0.463505775,0.680148363,0.76874131,0.523246229,0.934507966,0.679197252,0.709840536,44active development and improvement
240,71,Spacy,Feature,tokenization,tokenization feature,50330455,How to detokenize spacy text without doc context?,"I have a sequence to sequence model trained on tokens formed by spacy's tokenization. This is both encoder and decoder.

The output is a stream of tokens from a seq2seq model. I want to detokenize the text to form natural text.

Example:

Input to Seq2Seq: Some text

Output from Seq2Seq: This does n't work .

Is there any API in spacy to reverse tokenization done by rules in its tokenizer?","TL;DR I've written a code that attempts to do it, the snippet is below.

Another approach, with a computational complexity of O(n^2) * would be to use a function I just wrote. The main thought was ""What spaCy splits, shall be rejoined once more!""
Downsides:

In this approach you may easily merge ""do"" and ""nt"", as well as strip space between the dot ""."" and preceding word. This method is not perfect, as there are multiple possible combinations of sentences that lead to specific spaCy tokenization.

I am not sure if there is a method to fully detokenize a sentence when all you have is spaCy separated text, but this is the best I've got.

After having searched for hours on Google, only a few answers came along, with this very stack question being opened on 3 of my tabs on chrome ;), and all it wrote was basically ""don't use spaCy, use revtok"". As I couldn't change the tokenization other researchers chose, I had to develop my own solution. Hope it helps someone ;)",no satisfactory solution found,"After hours of searching on Google, the user was not able to find a satisfactory solution and had to develop their own method to accomplish the detokenization.",,1,C20230706015042805088,0.593840539,0.76593256,0.45775333,0.8018139,0.353733063,0.420727223,0.553356051,0.703924656,0.672100425,0.563718557,0.421374112,0.631491184,0.635675609,0.768908799,0.497998118,0.735287368,0.593646049,0.47182098,0.625440598,0.801952779,0.631370962,0.694326639,0.835056663,0.75583154,71no satisfactory solution found
285,83,Spacy,Feature,Lemmatization,Lemmatization feature,63693463,SpaCy lemmatizer removes capitalization,"I would like to lemmatize some textual data in Hungarian language and encountered a strange feature in spaCy. The token.lemma_ function works well in terms of lemmatization, however, it returns some of the sentences without first letter capitalization. This is quite annoying, as my next function, unnest_stences (R) requires first capital letters in order to identify and break the text down into individual sentences. 

When I pass my original data to the function, it returns some sentences with upercase first letters, others with lowercase letters. For some strange reason I couldn't reproduce that pattern above, but I guess the main point is visible. The function does not work as expected.

Any ideas how I could fix this?

I'm using Jupyter Notebook, Python 2.7, Win 7 and a Toshiba laptop (Port‚Äö√†√∂¬¨¬©g‚Äö√†√∂¬¨¬© Z830-10R i3-2367M).","Lowercasing is the expected behavior of spaCy's lemmatizer for non-proper-noun tokens.

One workaround is to check if each token is titlecased, and convert to original casing after lemmatizing (only applies to the first character).

import spacy

nlp = spacy.load('en_core_web_sm')

text = 'This is a test sentence.'
doc = nlp(text)
newtext = ' '.join([tok.lemma_.title() if tok.is_title else tok.lemma_ for tok in doc])
print(newtext)
# This be a test sentence .",workaround for capitalization,"One workaround is to check if each token is titlecased, and convert to original casing after lemmatizing (only applies to the first character).",,1,C20230706015140995767,0.463901103,0.732653022,0.687717199,0.711753666,0.861775577,0.752083063,0.37101081,0.870515585,0.693964899,0.469054818,0.587934554,0.814442337,0.704846919,0.712139189,0.806209564,0.720123351,0.922803521,0.702867687,0.537497759,0.783633947,0.897168934,0.662452281,0.631194055,0.756160736,83workaround for capitalization
126,36,Spacy,Stability,bug,Stability aspect,62796437,Spacy French langage gives NoneType error,"Here is the code :

import spacy
nlp = spacy.load('fr_core_news_sm')
doc = nlp('Demain je travaille ‚Äö√†√∂‚Äö√Ñ‚Ä† la maison')
for token in doc:
    print(token.text)
It gives the error :

File ""c:\users\ab\appdata\local\programs\python\python37\lib\site-packages\spacy\lang\fr\lemmatizer.py"", line 49, in call if self.is_base_form(univ_pos, morphology): TypeError: 'NoneType' object is not callable
If I change 'fr_core_news_sm' to 'en_core_web_sm', it works well.

My python version is 3.7.7. And Spacy version is 2.3.1.","This seems to be a bug at spaCy 2.3.1: https://github.com/explosion/spaCy/issues/5728

Downgrade to 2.3.0 and it should work: pip install spacy==2.3.0",overall stability,"Although the conversation indicates that spaCy may have occasional issues, it seems that the library is generally stable and well-tested, based on the available evidence.",Question not focused on main topic,0,C20230706014938195714,0.808298469,0.656785846,0.284359038,0.641943216,0.72249192,0.56312108,0.532025456,0.691392541,0.512172699,0.568014383,0.332698733,0.553505182,0.403624088,0.611819983,0.452545404,0.626048923,0.507488728,0.475138664,0.292471081,0.645642579,0.424619466,0.599386573,0.539557219,0.569209278,36overall stability
155,44,Spacy,Stability,backwards,Stability aspect,52598788,spaCy: custom attributes not matching correctly?,"I have been having problems using custom extension attributes with the recently improved Matcher (spaCy 2.012). Even a simple example (mostly copied from here) is not working as I expected:
In other words, the rule correctly matches on the span 'have' (1, 2), but incorrectly matches 'have' (5, 6) and 'had' (6, 7). Furthermore, the callback function is not called. The custom attribute appears to be ignored.
The first rule functions as above. Then the second rule triggers, along with the callback function (which prints the message). There is an additional correct match for the new pattern along with the correct and erroneous matches from the first rule.

So, I have a few questions:

why does pattern1 match incorrectly? (i.e. why does the _ custom attribute constraint not apply?)
why does the callback function not work on the first call?
why does it work upon addition of a new rule?
In my own code, when using custom attributes as constraints in subsequent patterns, these patterns match on ALL tokens. I assume this is related to the behaviour exhibited by the code above.","Sorry if this was confusing ‚Äö√Ñ√∂‚àö√ë‚àö¬® but the GitHub thread you're referring to is still only the spec and proposal, i.e. the planned implementation. The changes will hopefully ship with spaCy v2.1.0 (since some of the changes to the Matcher internals are not fully backwards compatible).

While the custom attribute matching isn't implemented yet, the basic improvements to the Matcher engine are already available on the develop branch and in the alpha version via spacy-nightly (pip install spacy-nightly). Those updates likely also resolve the inconsistent behaviour you observed with the callback function.",improvements to matcher engine available,"The improvements to the Matcher engine are already available, indicating that other features of spaCy are being actively developed and tested.",,1,C20230706014955645032,0.684175611,0.637896538,0.570978701,0.756899238,0.498653382,0.49708873,0.681228042,0.74376452,0.682765961,0.595759809,0.758373141,0.617756724,0.545827568,0.529456615,0.618061543,0.86596781,0.357247889,0.388689458,0.605804682,0.644675195,0.589118183,0.827181578,0.600750387,0.73234731,44improvements to matcher engine available
71,21,Spacy,Performance,performance,Performance aspect,48169545,Does spacy take as input a list of tokens?,"I would like to use spacy's POS tagging, NER, and dependency parsing without using word tokenization. Indeed, my input is a list of tokens representing a sentence, and I would like to respect the user's tokenization. Is this possible at all, either with spacy or any other NLP package ?

For now, I am using this spacy-based function to put a sentence (a unicode string) in the Conll format:
I would like to do the same while having as input a list of tokens...","You can run Spacy's processing pipeline against already tokenised text. You need to understand, though, that the underlying statistical models have been trained on a reference corpus that has been tokenised using some strategy and if your tokenisation strategy is significantly different, you may expect some performance degradation.

Here's how to go about it using Spacy 2.0.5 and Python 3. If using Python 2, you may need to use unicode literals.",input flexibility,Spacy can take an input list of tokens to perform tasks.,,1,C20230706014832772915,0.55655241,0.648723066,0.672967672,0.617415488,0.626572847,0.737570226,0.591038048,0.576213479,0.619536161,0.705759406,0.667567074,0.635228992,0.45274359,0.672291756,0.741472542,0.58037585,0.365972698,0.43168202,0.54580003,0.56405741,0.504791379,0.842448711,0.637765527,0.676323771,21input flexibility
40,12,Spacy,Documentation,documentation,Documentation aspect,50189238,How to re-train an existing spacy NER model for currency,"I am trying to update an existing spacy model ""en_core_web_sm"" with some different country currency such as ""euro"", ""rupees"", ""eu"", ""Rs."", ""INR"" etc. How can I achieve that ? The spacy tutorial didn't quite help me as training a fixed string such as ""horses"" as ""ANIMAL"" seems different than my requirements. The reason is I can have currency value indifferent formats : ""1 million euros"", ""Rs. 10,000"", ""INR 1 thousand"" etc. My sample dataset contains around 1000 samples with the following format :

TRAIN_DATA = [      
 ("" You have activated International transaction limit for Debit Card ending XXXX1137 on 2017-07-05 12:48:20.0 via NetBanking. The new limit is Rs. 250,000.00"", {'entities' : [(140, 154, 'MONEY')] }),...
]
Can anyone please help me out with this with the data format, training size or any other relevant information ?","The example from the documentation should work for you. I altered it a little to match your variable name.

optimizer = nlp.begin_training()

for itn in range(100):
    random.shuffle(train_data)
    for raw_text, entity_offsets in TRAIN_DATA:
        doc = nlp.make_doc(raw_text)
        gold = GoldParse(doc, entities=entity_offsets)
        nlp.update([doc], [gold], drop=0.5, sgd=optimizer)
nlp.to_disk('/model')
Link to Documentation",model save,"After successfully updating the model, it is then saved to disk using nlp.to_disk().",,1,C20230706014349909613,0.783886969,0.790223897,0.601996601,0.850788832,0.590239882,0.597552001,0.761275291,0.711114168,0.618264139,0.743584514,0.733659208,0.627369881,0.474127561,0.706022441,0.710860789,0.589358509,0.599502921,0.479470044,0.677591741,0.745737314,0.570306122,0.594135821,0.783138752,0.598226666,12model save
20,6,Spacy,Ease of use,difficult,Ease of use aspect,48980120,Is it possible to parse emojis using spaCy?,"Is it possible to tokenize emojis like :), :(, ;~( properly using the spaCy Python library? e.g. If I run the following code:

import spacy

nlp = spacy.load('en')
doc = nlp(""Hello bright world :)"")
And then visualize the doc with displaCy:
It incorrectly parses world :) as one token. How can I modify spaCy so it recognizes these additional symbols? Thanks.

edit: Found the following: https://github.com/ines/spacymoji but I think it only supports Unicode emojis like ‚Äö√Ñ√∂‚àö‚à´¬¨√Ü and not ASCII ones like :)","Yes, spaCy actually includes a pretty comprehensive list of text-based emoticons as part of its tokenizer exceptions. So using your example above and printing the individual tokens, the emoticon is tokenized correctly:

doc = nlp(""Hello bright world :)"")
print([token.text for token in doc])
# ['Hello', 'bright', 'world', ':)']
I think what happens here is that you actually came across an interesting (maybe non-ideal) edge case with the displacy defaults. To avoid very long dependency arcs for punctuation, the collapse_punct setting defaults to True. This means that when the visualisation is rendered, punctuation is merged onto the preceding token. Punctuation is identified by checking whether the token's is_punct attribute returns True ‚Äö√Ñ√∂‚àö√ë‚àö¬® which also happens to be the case for "":)"".

In your example, you can work around this by setting collapse_punct to False in the options passed to displacy.serve:

displacy.serve(doc, style='dep', options={'collapse_punct': False})
(The displaCy visualizer should probably include an exception for emoticons when merging punctuation. This is currently difficult, because spaCy doesn't have an is_emoji or is_symbol flag. However, it might be a nice addition in the future ‚Äö√Ñ√∂‚àö√ë‚àö¬® you can vote for it on this thread.)",setting collapse_punct to false,The solution to the issue with merging punctuation in the visualization is to set collapse_punct to False in the options passed to the displacy visualizer.,,1,C20230706014336082249,0.738134146,0.785149515,0.496775806,0.666730165,0.488711923,0.298382074,0.638746977,0.855681837,0.737173617,0.654264987,0.600601017,0.775413454,0.613491118,0.620271087,0.472647458,0.572425425,0.475286424,0.411493033,0.777697027,0.703184009,0.656544387,0.753545403,0.743616641,0.799676061,6setting collapse_punct to false
135,39,Spacy,Stability,bug,Stability aspect,75724665,How to maximize performance of spaCy on an M1 Mac (currently much slower than Intel),"I've observed that nlp.pipe is 30-40% slower on my almost brand new M1 Pro Macbook than on my old Macbook Pro from 2017. Most other functions are faster on the M1 by a similar margin, so this is not the performance I would expect.

For a benchmark, I'm running the following code (with scispacy):

My M1 Mac takes over 75 seconds to complete the task, while my 2017 Intel Mac can do it in 46 seconds.

I don't know whether spacy uses numpy, but I installed a fast version of numpy using ABarrier's answer to this question. That made numpy faster, but made no difference for spacy. I'm assuming that somewhere there is an unoptimized binary being used, but I don't know how to figure out what it is.
","Install the package thinc-apple-ops:

pip install thinc-apple-ops
Or through the spacy extra:

pip install 'spacy[apple]'
(The unoptimized package is blis. We'd like to be able to switch to a newer version of BLIS with M1 support, but there are still some open bugs.)",limited evidence,The conversation doesn't provide enough evidence to make a definitive assessment of the stability and testing of Spacy.,Original explanation is not conclusive,0,C20230706014943097920,0.51282829,0.539512455,0.477031171,0.872043192,0.422713816,0.47141853,0.388464212,0.623632193,0.766672134,0.467137426,0.542081475,0.710581899,0.534902215,0.435795009,0.347314,0.442788899,0.324927419,0.466614336,0.42921102,0.524032474,0.268523574,0.574756622,0.56914264,0.380837232,39limited evidence
210,62,GSON,Security,Security,Security aspect,13267258,Gson SecurityException: Can not make Class Constructor accessible,"I am using Gson to serialize/deserialize a class that contains a static nested class. The class looks like below.

public class ClassA {
private NestedClass nestedClass;

public NestedClass getNestedClass() {
return nestedClass;
}

public void setNestedClass(NestedClass nestedClass) {
this.nestedClass = nestedClass;
}

public static class NestedClass implements Serializable {

public NestedClass() {
}
}
}
The serialization works fine, but when i am trying to deserialize the json string back into an object i get the following SecurityException.

The exception seems to be coming from Java while trying to reflect the inner class. Has anyone been in that situation before?

Any help appreciated.",It appears you're running Gson on a JVM with a SecurityManager enabled. You'll need to disable the security manager to use Gson.,securitymanager enabled,The conversation indicates that running Gson on a JVM with a SecurityManager enabled limits the usage of Gson.,,1,C20230706015025235112,0.727647722,0.72994858,0.619026363,0.871733248,0.427539438,0.393966585,0.798227131,0.737215042,0.61519295,0.721420288,0.506508529,0.605863988,0.612213254,0.709515214,0.518744409,0.745172203,0.383337826,0.374228895,0.692106962,0.791861176,0.345513195,0.701845527,0.294532001,0.348175734,62securitymanager enabled
167,48,Spacy,Stability,version,Stability aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",multi-language support,The availability of models for multiple languages suggests that the library has been thoroughly tested.,,1,C20230706015003472868,0.65902251,0.542848587,0.651161373,0.568034053,0.724152863,0.71738565,0.407416254,0.714990437,0.834404826,0.349921167,0.426940322,0.663631439,0.40240714,0.471059114,0.486576289,0.363280892,0.49496302,0.507967412,0.297075331,0.626311719,0.474480569,0.539471984,0.690814078,0.628833532,48multi-language support
284,83,Spacy,Feature,Lemmatization,Lemmatization feature,63693463,SpaCy lemmatizer removes capitalization,"I would like to lemmatize some textual data in Hungarian language and encountered a strange feature in spaCy. The token.lemma_ function works well in terms of lemmatization, however, it returns some of the sentences without first letter capitalization. This is quite annoying, as my next function, unnest_stences (R) requires first capital letters in order to identify and break the text down into individual sentences. 

When I pass my original data to the function, it returns some sentences with upercase first letters, others with lowercase letters. For some strange reason I couldn't reproduce that pattern above, but I guess the main point is visible. The function does not work as expected.

Any ideas how I could fix this?

I'm using Jupyter Notebook, Python 2.7, Win 7 and a Toshiba laptop (Port‚Äö√†√∂¬¨¬©g‚Äö√†√∂¬¨¬© Z830-10R i3-2367M).","Lowercasing is the expected behavior of spaCy's lemmatizer for non-proper-noun tokens.

One workaround is to check if each token is titlecased, and convert to original casing after lemmatizing (only applies to the first character).

import spacy

nlp = spacy.load('en_core_web_sm')

text = 'This is a test sentence.'
doc = nlp(text)
newtext = ' '.join([tok.lemma_.title() if tok.is_title else tok.lemma_ for tok in doc])
print(newtext)
# This be a test sentence .",lowercasing behavior,Spacy's lemmatizer produces lowercased output by default for non-proper-noun tokens.,,1,C20230706015140468990,0.884315252,0.766358912,0.717466712,0.757916331,0.769573987,0.839797199,0.607289135,0.753803134,0.602238059,0.637433231,0.537125945,0.790976226,0.747021019,0.646454096,0.605194688,0.649992108,0.751680315,0.58877033,0.721565187,0.73764497,0.609888375,0.875938773,0.725158513,0.769263923,83lowercasing behavior
192,56,Spacy,Active Maintenance,github,Active Maintenance aspect,51855137,Rasa NLU: Tensorflow embedding with entity extraction,"Tensorflow embedding has a very good intent recogition.

In my experience it improved test results from about 45% confidence to 95% for simple inputs such as ""Hello"" compared to spacy.

But out of the box it does not have any entity extraction.

Is there any Pipeline configuration to solve this?","Config

The configuration below contains ner_crf for entity extraction.
Version

Rasa NLU: >=0.13.0

credit: github issue",config,The answer suggests a configuration solution for the entity extraction issue in Rasa NLU.,,1,C20230706015016589020,0.640377641,0.542819381,0.483825833,0.256138027,0.928128779,0.150220543,0.695502341,0.20510295,0.472260892,0.049237087,0.627271056,0.24015291,0.664571524,0.310833782,0.605908453,0.343675166,0.910038829,0.382014781,0.756900072,0.592933714,0.567061543,0.719784796,0.795645237,0.70894134,56config
88,25,Spacy,Performance,fast,Performance aspect,58212589,How to check if a sentence is a question with spacy?,"I am using spacy library to build a chat bot. How do I check if a document is a question with a certain confidence? I know how to do relevance, but not sure how to filter statements from questions.

I am looking for something like below:

spacy.load('en_core_web_lg')('Is this a question?').is_question","My first response is to suggest looking for question marks at the end of the sentence.

Otherwise, most questions start with {is, does, do, what, when, where, who, why, what, how}.

There is a more complex answer involving the inclusion of auxiliary verbs and their placement relative to the verb, but if your data is well-formed, this may be sufficient (and fast).",well-formed data,"Acknowledges that identifying questions can be more complex with auxiliary verbs, but might not be necessary depending on the data being well-formed",,1,C20230706014915790700,0.530367255,0.786211848,0.733824134,0.32982567,0.372236609,0.454124331,0.368445814,0.764115453,0.612599611,0.454917848,0.531114995,0.584861994,0.594305456,0.771517992,0.679594815,0.497014701,0.559475839,0.511564076,0.414585501,0.726892471,0.654760659,0.580481827,0.567238152,0.709598064,25well-formed data
143,41,Spacy,Stability,bug,Stability aspect,68559878,Force 'parser' to not segment sentences?,"Is there an easy way to tell the ""parser"" pipe not to change the value of Token.is_sent_start ?

So, here is the story: I am working with documents that are pre-sentencized (1 line = 1 sentence), this segmentation is all I need. I realized the parser's segmentation is not always the same as in my documents, so I don't want to rely on the segmentation made by it.

I can't change the segmentation after the parser has done it, so I cannot correct it when it makes mistakes (you get an error). And if I segment the text myself and then apply the parser, it overrules the segmentation I've just made, so it doesn't work.

So, to force keeping the original segmentation and still use a pretrained transformer model (fr_dep_news_trf), I either :

disable the parser,
add a custom Pipe to nlp to set Token.is_sent_start how I want,
create the Doc with nlp(""an example"")
or, I simply create a Doc with

doc = Doc(words=[""an"", ""example""], sent_starts=[True, False])
and then I apply every element of the pipeline except the parser.

However, if I still do need the parser at some point (which I do, because I need to know some subtrees), If I simply apply it on my Doc, it overrules the segmentation already in place, so, in some cases, the segmentation is incorrect. So I do the following workaround:

Keep the correct segmentation in a list sentences = list(doc.sents)
Apply the parser on the doc
Work with whatever syntactic information the parser computed
Retrieve whatever sentencial information I need from the list I previously made, as I now cannot trust Token.is_sent_start.
It works, but it doesn't really feel right imho, it feels a bit messy. Is there an easier, cleaner way I missed ?

Something else I am considering is setting a custom extension, so that I would, for instance, use Token._.is_sent_start instead of the default Token.is_sent_start, and a custom Doc._.sents, but I fear it might be more confusing than helpful ...

Some user suggested using span.merge() for a pretty similar topic, but the function doesn't seem to exist in recent releases of spaCy (Preventing spaCy splitting paragraph numbers into sentences)","The parser is supposed to respect sentence boundaries if they are set in advance. There is one outstanding bug where this doesn't happen, but that was only in the case where some tokens had their sentence boundaries left unset.

If you set all the token boundaries to True or False (not None) and then run the parser, does it overwrite your values? If so it'd be great to have a specific example of that, because that sounds like a bug.

Given that, if you use a custom component to set your true sentence boundaries before the parser, it should work.

Regarding some of your other points...

I don't think it makes any sense to keep your sentence boundaries separate from the parser's - if you do that you can end up with subtrees that span multiple sentences, which will just be weird and unhelpful.

You didn't mention this in your question, but is treating each sentence/line as a separate doc an option? (It's not clear if you're combining multiple lines and the sentence boundaries are wrong, or if you're passing in a single line but it's turning into multiple sentences.)

Thanks a million for you answer! It made me go back to my documents and check every output of every element in the pipeline... Well, I feel terribly stupid, but I simply cannot reproduce my observation of a ""deffective parser"", everything seems fine now. I guess after my initial struggle with forcing my own sentence boundaries (which wasn't even actually that complicated ...), I convinced myself somehow it wasn't working even after my own boundaries were set ? Or I fixed something else in my code ? Terribly sorry. I'll keep an eye on it, might post here again if I find a mistake again",one outstanding bug,There is one outstanding bug where sentence boundaries are not always respected by the parser.,,1,C20230706014946340865,0.674500108,0.275394708,0.679226518,0.473728806,0.496575296,0.629450977,0.859733701,0.693363905,0.720296144,0.779187739,0.764439762,0.669504464,0.590533018,0.362226039,0.349708229,0.4780671,0.379301518,0.611087918,0.721810162,0.817017257,0.648040771,0.819712281,0.733147085,0.728316188,41one outstanding bug
14,4,Spacy,Ease of use,simple,Ease of use aspect,57199811,Create a Spacy pipeline with my own Tokeniser?,"What puzzles me is that a spacy ""pipeline"" is a sequence of processing steps, but the very first step which converts the original data into a spacy document is ""hidden"". Unlike all the other steps it cannot be accessed from the pipeline, I think. So what if I want to replace it, change it, or create a pipeline with my own Tokenizer, what is the proper way to do this?","The reason the tokenizer isn't part of the regular pipeline is because it's ""special"": There can only really be one, and while all other pipeline components take a Doc and return it, the tokenizer takes a string of text and turns it into a Doc.

However, nlp.tokenizer is writable, so you can either create your own Tokenizer class from scratch, or even replace it with an entirely custom function. Here's a super simple example that shows the idea:
",writable nlp.tokenizer,The nlp.tokenizer can be overwritten with either a custom Tokenizer class or a new tokenizer function.,,1,C20230706014332603482,0.801742196,0.723825693,0.571462929,0.809479594,0.663859308,0.696599305,0.873565018,0.760728359,0.61144048,0.840533137,0.649531722,0.692763805,0.617840469,0.689422727,0.645874441,0.903259277,0.602410257,0.695019841,0.584330618,0.613565683,0.571484566,0.646767914,0.486172706,0.592481136,4writable nlp.tokenizer
254,75,Spacy,Feature,POS,POS tagging feature,34102420,POS tagging using spaCy,"I am trying to do POS tagging using the spaCy module in Python.
Here it returns crispy as a noun instead of an adjective. However, if I use a test sentence like

a=""we had crispy fries""
It recognizes that crispy is an adjective. Here is the output:

[(we , u'PRP'), (had , u'VBD'), (crispy , u'JJ'), (fries, u'NNS')]
I think the primary reason why crispy wasn't tagged as an adjective in the first case was because dosa was tagged as 'NN' whereas fries was tagged as 'NNS' in the second case.

Is there any way I can get crispy to be tagged as an adjective in the second case too?","TL;DR: You should accept the occasional error.

Details:

Spacy's tagger is statistical, meaning that the tags you get are its best estimate based on the data it was shown during training. I would guess those data did not contain the word dosa. The tagger had to guess, and guessed wrong. There isn't an easy way to correct its output, because it is not using rules or anything you can modify easily. The model has been trained on a standard corpus of English, which may be quite different to the kind of language you are using it for (domain). If error rate is too high for your purposes, you can re-train the model using domain-specific data. This will be very laborious though. Ask yourself what you are trying to achieve and whether 3% error rate in PoS tagging is the worst of your problems.

In general, you shouldn't judge the performance of a statistical system on a case-by-case basis. The accuracy of modern English PoS taggers is around 97%, which is roughly the same as the average human. You will inevitably get some errors. However, the errors of the model will not be the same as the human errors, as the two have ""learnt"" how to solve the problem in a different way. Sometimes the model will get confused by things you and I consider obvious, e.g. your example. This doesn't mean it is bad overall, or that PoS tagging is your real problem.",occasional errors,"Due to the statistical nature of Spacy's tagger, there can be occasional errors, particularly for new or uncommon words.",,1,C20230706015051198148,0.640149176,0.734718859,0.412904292,0.687635303,0.679815233,0.636335552,0.66419673,0.779859185,0.499328464,0.767742872,0.874655008,0.655799389,0.578548789,0.633540034,0.60353303,0.557700515,0.393198788,0.509185731,0.51579988,0.620759368,0.530233264,0.833706379,0.626851082,0.668475211,75occasional errors
319,94,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,50742516,How to get the index of a token in a sentence in spaCy?,"Is there an elegant way to get the index of a word/token in its sentence? I am aware of the attributes for tokens https://spacy.io/api/token#attributes The i attribute returns the index within the whole parent document. But the parent document can contain multiple sentences.

Example:

""This is an example. This is another example.""
What I need is both ""This"" to be returned as index 0, both ""is"" to be returned as index 1 etc...","A spaCy Doc object also lets you iterate over the doc.sents, which are Span objects of the individual sentence. To get a span's start and end index in the parent document you can look at the start and end attribute. So if you iterate over the sentences and subtract the sentence start index from the token.i, you get the token's relative index within the sentence:

for sent in doc.sents:
    for token in sent:
        print(token.text, token.i - sent.start)
The default sentence segmentation uses the dependency parse, which is usually more accurate. However, you can also plug in a rule-based or entirely custom solution (see here for details).",flexible sentence segmentation,"Spacy's default sentence segmentation is accurate, but users can also plug in a rule-based or custom solution.",,1,C20230706015233100242,0.778557897,0.704519033,0.630636692,0.865148544,0.758895397,0.611149967,0.694197357,0.84754771,0.712353051,0.670748711,0.925490856,0.682523668,0.685428917,0.739563406,0.378812224,0.646383107,0.474856466,0.679166436,0.646266818,0.809526622,0.520296216,0.728976905,0.876283228,0.58507973,94flexible sentence segmentation
76,22,Spacy,Performance,performance,Performance aspect,57049798,Can we find sentences around an entity tagged via NER?,"We have a model ready which identifies a custom named entity. The problem is if the whole doc is given then the model does not work as per expecation if only a few sentences are given, it is giving amazing results.

I want to select two sentences before and after a tagged entity.

eg. If a part of the doc has world Colombo(which is tagged as GPE), I need to select two sentences before the tag and 2 sentences after the tag. I tried a couple of approaches but the complexity is too high.

Is there a built-in way in spacy with which we can address this problem?

I am using python and spacy.

I have tried parsing the doc by identifying the index of the tag. But that approach is really slow.","It might be worth it to see if you can improve the custom named entity recognizer, because it should be unusual for extra context to hurt performance and potentially if you fix that issue it will work better overall.

However, regarding your concrete question about surrounding sentences:

A Token or a Span (an entity is a Span) has a .sent attribute that gives you the covering sentence as a Span. If you look at the tokens right before/after a given sentence's start/end tokens, you can get the previous/next sentences for any token in a document.",improvement suggestion,Improving the named entity recognizer may lead to better performance.,,1,C20230706014906606986,0.739836335,0.670370817,0.737048447,0.900066614,0.909172177,0.83978802,0.633406818,0.798146904,0.59453392,0.652916491,0.912675798,0.627631903,0.438967347,0.729167461,0.620103657,0.873022497,0.636835456,0.565742195,0.617320418,0.611215353,0.683292627,0.713573515,0.926852643,0.719433069,22improvement suggestion
27,8,Spacy,Ease of use,complex,Ease of use aspect,65850018,processing text with spacy nlp.pipe,"I'm procerssing 40,000 abstracts with spacy nlp.pipe using the code below and its taking 8 mins. Is there a way to speed this up further? I've also disabled ner.","Try tuning batch_size and n_process params :
Note as well, by joining on "" "" you may have some surprises, as spaCy's splitting rules are a bit more complex than that.",string joining,Simple string join may not work properly due to complex splitting rules of Spacy.,No answer available against the challenge,1,C20230706014341425378,0.718231976,0.617274702,0.668204188,0.872370541,0.826063871,0.846571147,0.746716261,0.686836421,0.79968214,0.80218488,0.82177186,0.890083671,0.682712913,0.660284519,0.57173568,0.676651537,0.631670177,0.580217183,0.765756607,0.68516314,0.682928443,0.797117293,0.874559641,0.902490795,8string joining
189,54,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,72068918,"Python NLP Spacy : improve bi-gram extraction from a dataframe, and with named entities?","I am using Python and spaCy as my NLP library, working on a big dataframe that contains feedback about different cars, which looks like this:

enter image description here

'feedback' column contains natural language text to be processed,
'lemmatized' column contains lemmatized version of the feedback text,
'entities' column contains named entities extracted from the feedback text (I've trained the pipeline so that it will recognise car models and brands, labelling these as 'CAR_BRAND' and 'CAR_MODEL')
I then created the following function, which applies the Spacy nlp token to each row of my dataframe and extract any [noun + verb], [verb + noun], [adj + noun], [adj+ proper noun] combinations.
This is where I have a problem...

This is producing only one bigram per row maximum. How can I tweak the code so that more than one bigram can be extracted and put in a column? (Also are there more linguistic combinations I should try?)
Is there a possibility to find out what people are saying about 'CAR_BRAND' and 'CAR_MODEL' named entities extracted in the 'entities' column? For example 'Cool Porsche' - Some brands or models are made of more than two words so it's tricky to tackle.
I am very new to NLP.. If there is a more efficient way to tackle this, any advice will be super helpful! Many thanks for your help in advance.","spaCy has a built-in pattern matching engine that's perfect for your application ‚Äö√Ñ√∂‚àö√ë‚àö¬® it's documented here and in a more extensive usage guide. It allows you to define patterns in a readable and easy-to-maintain way, as lists of dictionaries that define the properties of the tokens to be matched.

Some ideas for improvement

Named entity recognition should be able to detect multi-word expressions, so brand and/or model names that consist of more than one token shouldn't be an issue if everything is set up correctly
Matching dependency patterns instead of linear patterns might slightly improve your results
That being said, what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® kind of sentiment analysis -is quite a difficult task that's normally engaged with machine learning approaches and heaps of training data. So don't expect too much from simple heuristics.
",solution provided,The responder provided a solution to the user's problem and addressed their concerns.,,1,C20230706015013493903,0.643396974,0.320087761,0.357591778,0.322853565,0.348447174,0.919858813,0.540354609,0.285890222,0.247809544,0.394095629,0.347019881,0.940247357,0.668811262,0.465233028,0.481893033,0.18942076,0.425439388,0.693106949,0.474592984,0.224515215,0.232916206,0.552440464,0.589285851,0.935737371,54solution provided
105,30,Spacy,Performance,speed,Performance aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",n_process argument,"Spacy provides the n_process argument to the nlp.pipe method, which allows users to specify the number of processes to use for a given task. This can further improve performance and make multiprocessing more efficient.",,1,C20230706014926677944,0.704284728,0.674152315,0.773260355,0.800259948,0.754473627,0.822598934,0.6670748,0.661912024,0.74618417,0.825710833,0.695460618,0.744368315,0.426383734,0.66195792,0.835035145,0.549481332,0.668441772,0.635918915,0.57338047,0.768395066,0.594428897,0.410387576,0.490893364,0.571876228,30n_process argument
203,60,Spacy,Security,leak,Security aspect,55841087,Python: Spacy and memory consumption,"1 - THE PROBLEM

I'm using ""spacy"" on python for text documents lemmatization. There are 500,000 documents having size up to 20 Mb of clean text.

The problem is the following: spacy memory consuming is growing in time till the whole memory is used.

2 - BACKGROUND

My hardware configuration: CPU: Intel I7-8700K 3.7 GHz (12 cores) Memory: 16 Gb SSD: 1 Tb GPU is onboard but is not used for this task

I'm using ""multiprocessing"" to split the task among several processes (workers). Each worker receives a list of documents to process. The main process performs monitoring of child processes. I initiate ""spacy"" in each child process once and use this one spacy instance to handle the whole list of documents in the worker.

3 - EXPECTATIONS

I have seen a good recommendation to build a separated server-client solution [here]Is possible to keep spacy in memory to reduce the load time?

Is it possible to keep memory consumption under control using ""multiprocessing"" approach?
","Memory problems when processing large amounts of data seem to be a known issue, see some relevant github issues:

https://github.com/explosion/spaCy/issues/3623
https://github.com/explosion/spaCy/issues/3556
Unfortunately, it doesn't look like there's a good solution yet.",no current solution,There may not be a good solution yet for managing memory consumption when using Spacy to process large amounts of data.,,1,C20230706015022348112,0.860779881,0.780790567,0.73653549,0.750911534,0.767889261,0.860192001,0.78306663,0.604304612,0.766179979,0.461875558,0.534625351,0.822488189,0.596327305,0.632881761,0.763889313,0.696737945,0.819272161,0.698435903,0.756215692,0.680683196,0.714033484,0.545747459,0.564957976,0.644995332,60no current solution
94,27,Spacy,Performance,fast,Performance aspect,48199353,How to use spacy in large dataset with short sentences efficiently?,"I choose spacy to process kinds of text because of the performance of it's lemmatation compared with nltk. But When I process millions short text, it always consumed all of my memory(32G) and crashed. Without it just a few minutes and less than 10G mem is consumed.

Is something wrong with the usage of this method? is there any better solution to improve the performance? Thanks!","You can use multithreading in spacy to create a fast tokenization and data ingestion pipeline.

Rewriting your code block and functionality using the nlp.pipe method would look something like this:
This way puts all your filtering into the token_filter function, which takes in a spacy token and returns True only if it is not punctuation, a space, a stopword, and 4 or less characters. Then, you use this function as you pass through each token in each document, where it will return the lemma only if it meets all of those conditions. Then, filtered_tokens is a list of your tokenized documents.

Some helpful references for customizing this pipeline would be:

Token attributes
Language.pipe",references for customization,Spacy's token attributes and language.pipe provide helpful reference points for customizing the pipeline.,,1,C20230706014920624687,0.757196784,0.70199275,0.744057834,0.607808411,0.812338471,0.648272336,0.66790396,0.625025809,0.592933297,0.553148329,0.757242978,0.527014375,0.794185936,0.531548083,0.506432652,0.550687075,0.695793092,0.659890592,0.748080373,0.359719902,0.538917124,0.323307186,0.682547569,0.177094668,27references for customization
50,14,Spacy,Documentation,documentation,Documentation aspect,57206701,Spacy tokenizer rule for exceptions that contain whitespace?,"When I create a pipeline with the default tokenizer for say English, I can then call the method for adding a special case:

tokenizer.add_special_case(""don't"", case)
The tokenizer will happily accept a special case that contains whitespace:

tokenizer.add_special_case(""some odd case"", case)
but it appears that does not actually change the behavior of the tokenizer or will never match?

More generally, what is the best way of extending an existing tokenizer so that the some patterns which normally would result in multiple tokens only create one token? For example something like [A-Za-z]+\([A-Za-z0-9]+\)[A-Za-z]+ should not result in three tokens because of the parentheses but in a single token, e.g. for asdf(a33b)xyz while the normal English rules should still apply if that pattern does not match.

Is this something that can be done somehow by augmenting an existing tokenizer or would I have to first tokenize, then find entities that match the corresponding token patterns and then merge the entity tokens?","As you found, Tokenizer.add_special_case() doesn't work for handling tokens that contain whitespace. That's for adding strings like ""o'clock"" and "":-)"", or expanding e.g. ""don't"" to ""do not"".

Modifying the prefix, suffix and infix rules (either by setting them on an existing tokenizer or creating a new tokenizer with custom parameters) also doesn't work since those are applied after whitespace splitting.

To override the whitespace splitting behavior, you have four options:

Merge after tokenization. You use Retokenizer.merge(), or possibly merge_entities or merge_noun_chunks. The relevant documentation is here: https://spacy.io/usage/linguistic-features#retokenization and https://spacy.io/api/pipeline-functions#merge_entities and https://spacy.io/api/pipeline-functions#merge_noun_chunks

This is your best bet for keeping as much of the default behavior as possible.
Subclass Tokenizer and override __call__. Sample code:

Implement a completely new tokenizer (without subclassing Tokenizer). Relevant docs here: https://spacy.io/usage/linguistic-features#custom-tokenizer-example
Tokenize externally and instantiate Doc with words. Relevant docs here: https://spacy.io/usage/linguistic-features#own-annotations
To answer the second part of your question, if you don't need to change whitespace splitting behavior, you have two other options:

Add to the default prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizer-additions

Note from https://stackoverflow.com/a/58112065/594211: ""You can add new patterns without defining a custom tokenizer, but there's no way to remove a pattern without defining a custom tokenizer.""
Instantiate Tokenizer with custom prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizers

To get the default rules, you read the existing tokenizer's attributes (as shown above) or use the nlp object‚Äö√Ñ√∂‚àö√ë‚àö¬•s Defaults. There are code samples for the latter approach in https://stackoverflow.com/a/47502839/594211 and https://stackoverflow.com/a/58112065/594211.",special case limitation,Tokenizer.add_special_case() doesn't work for handling tokens that contain whitespace.,,1,C20230706014424327637,0.66919899,0.580848694,0.692658126,0.785113335,0.888035953,0.743445575,0.680707395,0.652545929,0.705167592,0.641297758,0.707169831,0.665679276,0.668156445,0.670286477,0.615554035,0.926543295,0.73467809,0.649531305,0.791137099,0.733141601,0.704627454,0.828645587,0.839157641,0.821060121,14special case limitation
109,31,Spacy,Performance,speed,Performance aspect,52897492,spaCy: optimizing tokenization,"I'm currently trying to tokenize a text file where each line is the body text of a tweet:
The file is 59,397 lines long (a day's worth of data) and I'm using spaCy for pre-processing/tokenization. It's currently taking me around 8.5 minutes and I was wondering if there were any way of optimising the following code to be quicker as 8.5 minutes seems awfully long for this process:Although it says files, it's currently only looping over 1 file.

Just to note, I only need this to tokenize the content; I don't need any extra tagging etc.","It sounds like you haven't optimised the pipeline yet. You'll get a significant speed up from disabling the pipeline components you don't need, like so:

nlp = spacy.load('en', disable=['parser', 'tagger', 'ner'])    
This should get you down to about the two-minute mark, or better, on its own.

If you need a further speed up, you can look at multi-threading using nlp.pipe. Docs for multi-threading are here: https://spacy.io/usage/processing-pipelines#section-multithreading",optimizing pipeline,Disabling unnecessary components in the pipeline improves efficiency.,,1,C20230706014928342595,0.534737408,0.586709678,0.70560199,0.393525749,0.484409124,0.914889634,0.572169125,0.703314483,0.785902441,0.617624164,0.647162497,0.784728765,0.577009737,0.734801233,0.595224023,0.494360059,0.668883979,0.625245273,0.642660439,0.712866545,0.74622339,0.748454452,0.750222802,0.712587357,31optimizing pipeline
166,48,Spacy,Stability,version,Stability aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",manual model download,"In the meantime, models can be downloaded manually and placed in the appropriate folder.",,1,C20230706015002416155,0.532683551,0.440336645,0.418569595,0.534340322,0.634523928,0.552021265,0.51481092,0.412440985,0.278533936,0.525513709,0.609696448,0.459482729,0.402215689,0.450464666,0.458117872,0.512157798,0.461265683,0.519056618,0.490075499,0.512808025,0.443269163,0.759391785,0.74388355,0.841944039,48manual model download
60,17,Spacy,Documentation,documentation,Documentation aspect,61241351,"Install specific version of spacy - working with pip, but not with conda","I am revisiting some code I wrote months ago with Spacy Version 2.1.8. I need this version of spacy. pip install is working but Anaconda does not even show that spacy is installed. And

conda install spacy=2.1.8
gives the PackagesNotFoundError error.","As explained in spaCy documentation, you can take advantage of the conda-forge community repository to install spacy

$ conda install -c conda-forge spacy=2.1.8
This version should be available according to spaCy's page on Conda Forge.",use of conda-forge,Documentation emphasizes the use of conda-forge community repository to install Spacy packages.,,0,C20230706014429993143,0.733945727,0.383391291,0.625813246,0.681731164,0.753466785,0.606782496,0.839098394,0.653196335,0.671491623,0.704631805,0.783802748,0.72023654,0.685639918,0.438980401,0.323910832,0.339271665,0.607791126,0.602911234,0.833229542,0.711594045,0.700926602,0.658004284,0.640361965,0.541083038,17use of conda-forge
24,7,Spacy,Ease of use,easy,Ease of use aspect,55087101,How to get all noun phrases in Spacy(Python),"I would like to extract ""all"" the noun phrases from a sentence. I'm wondering how I can do it. I have the following code:","Spacy clearly defines a noun chunk as:

A base noun phrase, or ""NP chunk"", is a noun phrase that does not permit other NPs to be nested within it ‚Äö√Ñ√∂‚àö√ë‚àö¬® so no NP-level coordination, no prepositional phrases, and no relative clauses."" (https://spacy.io/api/doc#noun_chunks)
If you process the dependency parse differently, allowing prepositional modifiers and nested phrases/chunks, then you can end up with what you're looking for.

I bet you could modify the existing spacy code fairly easily to do what you want:

https://github.com/explosion/spaCy/blob/06c6dc6fbcb8fbb78a61a2e42c1b782974bd43bd/spacy/lang/en/syntax_iterators.py",modifying spacy code to extract all noun phrases,"The user can modify the existing Spacy code to extract all noun phrases, and a link to the relevant code is provided.",,1,C20230706014339305504,0.674389601,0.867257535,0.74646616,0.817897618,0.823132157,0.720209718,0.648246884,0.680234611,0.543081284,0.853689909,0.669314861,0.769228697,0.722996533,0.597747624,0.753975034,0.866811335,0.512572169,0.552532673,0.817301869,0.725277007,0.724925876,0.839253128,0.707230151,0.861723483,7modifying spacy code to extract all noun phrases
248,73,Spacy,Feature,POS,POS tagging feature,47856247,Extract verb phrases using Spacy,I have been using Spacy for noun chunks extraction using Doc.noun_chunks property provided by Spacy. How could I extract verb phrases from input text using Spacy library (of the form 'VERB ? ADV * VERB +' )?,"This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
This might help you.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The author is writing a new book.'
pattern = r'<VERB>?<ADV>*<VERB>+'
doc = textacy.Doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.pos_regex_matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

is writing
On how to highlight the verb phrases do check the link below.

Highlight verb phrases using spacy and html

Another Approach:

Recently observed Textacy has made some changes to regex matches. Based on that approach i tried this way.

from __future__ import unicode_literals
import spacy,en_core_web_sm
import textacy
nlp = en_core_web_sm.load()
sentence = 'The cat sat on the mat. He dog jumped into the water. The author is writing a book.'
pattern = [{'POS': 'VERB', 'OP': '?'},
           {'POS': 'ADV', 'OP': '*'},
           {'POS': 'VERB', 'OP': '+'}]
doc = textacy.make_spacy_doc(sentence, lang='en_core_web_sm')
lists = textacy.extract.matches(doc, pattern)
for list in lists:
    print(list.text)
Output:

sat
jumped
writing
I checked the POS matches in this links seems the result is not the intended one.

[https://explosion.ai/demos/matcher][1]

Did anybody try framing POS tags instead of Regexp pattern for finding Verb phrases?",spacy supports pos tagging,"The Spacy library has a variety of functions that support POS tagging, including the Doc and extract functions that were used to extract verb phrases from the input text.",,1,C20230706015046058134,0.55253613,0.529033184,0.616495728,0.552182436,0.620469034,0.526593208,0.869388461,0.739893377,0.452752441,0.745027006,0.458010256,0.51422286,0.421514899,0.613972068,0.481057405,0.595186353,0.346849382,0.472755253,0.816611648,0.65655452,0.694007695,0.657908261,0.69880563,0.611042261,73spacy supports pos tagging
232,70,Spacy,Feature,tokenization,tokenization feature,50908667,Tokenization not working the same for both case.,"I have a document

doc = nlp('x-xxmessage-id:')
When I want to extract the tokens of this one I get 'x', 'xx', 'message' and 'id', ':'. Everything goes well. Then I create a new document

test_doc = nlp('id')
If I try to extract the tokens of test_doc, I will get 'i' and 'd'. Is there any way to get past this problem? Because I want to get the same token as above and this is creating problems in the text processing.","Just like language itself, tokenization is context-dependent and the language-specific data defines rules that tell spaCy how to split the text based on the surrounding characters. spaCy's defaults are also optimised for general-purpose text, like news text, web texts and other modern writing.

In your example, you've come across an interesting case: the abstract string ""x-xxmessage-id:"" is split on punctuation, while the isolated lowercase string ""id"" is split into ""i"" and ""d"", because in written text, it's most commonly an alternate spelling of ""I'd"" or ""i'd"" (""I could"", ""I would"" etc.). You can find the respective rules here.

If you're dealing with specific texts that are substantially different from regular natural language texts, you usually want to customise the tokenization rules or possibly even add a Language subclass for your own custom ""dialect"". If there's a fixed number of cases you want to tokenize differently that can be expressed by rules, another option would be to add a component to your pipeline that merges the split tokens back together.

Finally, you could also try using the language-independent xx / MultiLanguage class instead. It still includes very basic tokenization rules, like splitting on punctuation, but none of the rules specific to the English language.

from spacy.lang.xx import MultiLanguage
nlp = MultiLanguage()",adding language subclass,A Language subclass can be added for specific dialects to improve tokenization accuracy.,,1,C20230706015040071473,0.757114947,0.741279066,0.592501581,0.736672163,0.701878846,0.685927868,0.77487272,0.899201453,0.730025172,0.821414948,0.881498396,0.798518479,0.608440399,0.662871778,0.563227832,0.530976593,0.569108427,0.575968444,0.793661177,0.72099334,0.801062167,0.826301873,0.876358867,0.834761739,70adding language subclass
227,68,Spacy,Feature,tokenization,tokenization feature,59500498,spacy tokenizer: is there a way to use regex as a key in custom exceptions for update_exc,"It is possible to add custom exceptions to spacy tokenizer. And these exceptions work fine. However, as far as I know, it's possible to use only strings as keys to match for those exceptions. It's done this way:
The only clue I found is: https://github.com/explosion/spaCy/issues/840

In that revision of tokenizer_exceptions.py there was some way to use regexps as keys for tokenizer exceptions(however, I haven't found any examples to do so)

But in current revisions, at least initial analysis hasn't shown any ways to do s

So is there a way to solve this task?

(input: regex as a key for exception, output - phone numbers with spaces inside)","No, there's no way to have regular expressions as tokenizer exceptions. The tokenizer only looks for exceptions as exact string matches, mainly for reasons of speed. The other difficulty for this kind of example is that tokenizer exceptions currently can't contain spaces. (Support for spaces is planned for a future version of spacy, but not regexes, which would still be too slow.)

I think the best way to do this would be to add a custom pipeline component at the beginning of the pipeline that retokenizes the document with the retokenizer: https://spacy.io/api/doc#retokenize. You can provide any required attributes like lemmas while retokenizing.",no regex support,Spacy does not support regular expressions as tokenizer exceptions.,,1,C20230706015035650962,0.641800582,0.594227791,0.681208372,0.839768469,0.686997294,0.68935734,0.522744298,0.440725595,0.493740737,0.727467775,0.81701386,0.781208396,0.587905228,0.668967903,0.753170729,0.919900656,0.652320623,0.60500747,0.430106312,0.504044354,0.572528601,0.867561579,0.711119354,0.777468026,68no regex support
39,11,Spacy,Documentation,documentation,Documentation aspect,58215855,"How to get full list of POS, Tag, and Dep in spaCy?","The POS, TAG, and DEP values used in spaCy are common ones of NLP, but I believe there are some differences depending on the corpus database.

For example, Universal Dependencies Contributors has listed 37 syntactic dependencies. Does spaCy use all of these 37 dependencies? And nothing more?

Is there a command to output all POS, TAG, and DEP values, spaCy may provide?","A specific pipeline component can show its labels:

nlp = spacy.load('en')
nlp.get_pipe(""tagger"").labels
# ('$', ""''"", ',', '-LRB-', '-RRB-', '.', ':', 'ADD', 'AFX', 'CC', 'CD', 'DT', 'EX', 'FW', 'HYPH', 'IN', 'JJ', 'JJR', 'JJS', 'LS', 'MD', 'NFP', 'NN', 'NNP', 'NNPS', 'NNS', 'PDT', 'POS', 'PRP', 'PRP$', 'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB', 'XX', '_SP', '``')
spacy.explain(label) will give a short definition for most labels, e.g.:

spacy.explain(""NN"")
# 'noun, singular or mass'
spacy.explain(""PERSON"")
# 'People, including fictional'
The detailed documentation is here: https://spacy.io/api/annotation",outputting labels,"The nlp.get_pipe('tagger').labels command outputs all POS, TAG, and DEP values used by spaCy.",,1,C20230706014347618904,0.883557498,0.820843458,0.745842278,0.733181357,0.864893377,0.643948793,0.883213699,0.596480846,0.78784579,0.620778799,0.847895622,0.747325659,0.722003698,0.71228981,0.601709545,0.674884379,0.894575179,0.668569326,0.746288717,0.645445645,0.650030851,0.772272468,0.830724716,0.851566434,11outputting labels
22,7,Spacy,Ease of use,easy,Ease of use aspect,55087101,How to get all noun phrases in Spacy(Python),"I would like to extract ""all"" the noun phrases from a sentence. I'm wondering how I can do it. I have the following code:","Spacy clearly defines a noun chunk as:

A base noun phrase, or ""NP chunk"", is a noun phrase that does not permit other NPs to be nested within it ‚Äö√Ñ√∂‚àö√ë‚àö¬® so no NP-level coordination, no prepositional phrases, and no relative clauses."" (https://spacy.io/api/doc#noun_chunks)
If you process the dependency parse differently, allowing prepositional modifiers and nested phrases/chunks, then you can end up with what you're looking for.

I bet you could modify the existing spacy code fairly easily to do what you want:

https://github.com/explosion/spaCy/blob/06c6dc6fbcb8fbb78a61a2e42c1b782974bd43bd/spacy/lang/en/syntax_iterators.py",definition of noun chunk in spacy,"Spacy defines a noun chunk as a base noun phrase that does not permit other NPs to be nested within it ‚Äö√Ñ√¨ so no NP-level coordination, no prepositional phrases, and no relative clauses.",,1,C20230706014338419647,0.616053641,0.686434627,0.588481188,0.767100334,0.516552806,0.533349752,0.830456555,0.706557572,0.327225953,0.700538933,0.432149798,0.615500689,0.640938759,0.704991519,0.727967024,0.908789396,0.606683969,0.610961795,0.588051736,0.706549346,0.602660954,0.887116969,0.86621052,0.917818844,7definition of noun chunk in spacy
54,15,Spacy,Documentation,documentation,Documentation aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",solution for multiprocessing,The documentation of the Spacy library provides a solution to sharing Spacy models between processes by passing the n_process argument to nlp.pipe.,wrong labeling,1,C20230706014426944256,0.791702807,0.668477595,0.739235342,0.578852177,0.657067955,0.867542565,0.616499305,0.762513936,0.795354843,0.633617461,0.661109447,0.798286438,0.79386133,0.625165582,0.79933846,0.559583426,0.566701472,0.747987807,0.642114103,0.715269208,0.885282695,0.761081398,0.733916283,0.810603857,15solution for multiprocessing
288,84,Spacy,Feature,NER,NER feature,57536896,Custom entity ruler with SpaCy did not return a match,"This link shows how to create custom entity ruler.

I basically copied and modified the code for another custom entity ruler and used it to find a match in a doc as follows:
However, when I run the code (in Jupyter notebook), nothing returned.

Could you please tell me:

If the code returned nothing, did it mean no match was found?
Why couldn't my code find a match although it's almost identical to the original (except for the patterns added to the ruler)? What did I do wrong?","The problem is an interaction between the NER component provided in the English model and your EntityRuler component. The NER component finds 2 as a number (CARDINAL) and there's a restriction that entities aren't allowed to overlap, so the EntityRuler component doesn't find any matches.

You can either add your EntityRuler before the NER component:

nlp.add_pipe(ruler, before='ner')
Or tell the EntityRuler that it's allowed to overwrite existing entities:

ruler = EntityRuler(nlp, overwrite_ents=True)",solution: overwrite entities,Allowing the EntityRuler to overwrite existing entities provides another solution to the issue of overlapping entities.,,1,C20230706015143429047,0.68647331,0.713563144,0.634854555,0.943529189,0.967391133,0.944456816,0.79776144,0.791748941,0.731429338,0.879324138,0.753739715,0.844456315,0.731625855,0.754662335,0.733071744,0.682035387,0.693875253,0.65519166,0.79854387,0.892593026,0.802759707,0.783156931,0.848641336,0.832241654,84solution: overwrite entities
92,26,Spacy,Performance,fast,Performance aspect,59830899,sense2vec performance improvemets,"I am using Sense2Vec (builds upon Spacy, a fantastic NLP library/tool) and testing the similarity between various words. Unfortunately the performance is quite slow (execution is over a second on a regular MacBook Pro).

Does anyone have a way to speed this up?

Here is the code:

term = ""dog|NOUN""
sense2vec = Sense2Vec().from_disk(""path-to-s2v_reddit_2019_lg"")
sims = sense2vec.most_similar(term, n=top)
I suspect some caching would speed things, but I am not sure which elements should be cached.
","There is indeed a way to speed up Sense2Vec.most_similar. There is a script available from https://github.com/explosion/sense2vec/blob/master/scripts/06_precompute_cache.py, which precomputes a cache of the nearest neighbors. It will then save that cache with the component on disk, making the data larger but the queries fast. If a query is not covered by the cache, most_similar falls back to using the normal computation.",sense2vec performance issue,The user is experiencing slow performance while testing the similarity between various words using the Sense2Vec library.,,1,C20230706014916296473,0.803218007,0.655011654,0.676920891,0.650751293,0.700213909,0.62738806,0.530655026,0.667008698,0.547197878,0.479982018,0.698279202,0.683050871,0.883753598,0.79050827,0.45508194,0.712718368,0.557775497,0.537968278,0.60031414,0.358239949,0.571940124,0.396583766,0.520240963,0.209434941,26sense2vec performance issue
111,32,Spacy,Performance,speed,Performance aspect,57697374,List most similar words in spaCy in pretrained model,"With Gensim, after I've trained my own model, I can use model.wv.most_similar('cat', topn=5) and get a list of the 5 words that are closest to cat in the vector space. For example:

With spaCy, as per the documentation, I can do:

which gives similarity for tokens in a specified string. But combing through the docs and searching, I can't figure out if there is a gensim-type way of listing all similar words for a preloaded model with either nlp = spacy.load('en_core_web_lg') or nlp = spacy.load('en_vectors_web_lg'). Is there a way to do this?","I used Andy's response and it worked correctly but slowly. To resolve that I took the approach below.

SpaCy uses the cosine similarity, in the backend, to compute .similarity. Therefore, I decided to replace word.similarity(w) with its optimized counterpart. The optimized method that I worked with was cosine_similarity_numba(w.vector, word.vector), shown below, that uses the Numba library to speed up computations. You should replace line 12 in the most_similar method with the line below.
The method became 2-3 times faster which was essential for me.
I explained it in more details in this article: How to Build a Fast ‚Äö√Ñ√∂‚àö√ë‚àö‚à´Most-Similar Words‚Äö√Ñ√∂‚àö√ë‚àöœÄ Method in SpaCy",insufficient context provided,"Without further context and evaluation of the library's performance in other areas, it is difficult to make a strict assessment of Spacy's performance.",,1,C20230706014931488338,0.675988615,0.673437417,0.653728008,0.76381129,0.817708075,0.69816649,0.864582777,0.628676295,0.61176914,0.678824782,0.679899991,0.699455082,0.64443469,0.76428932,0.494666755,0.5886783,0.873157382,0.576733768,0.70471561,0.58524543,0.465516239,0.535986245,0.497895718,0.546173871,32insufficient context provided
185,53,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44176829,Python Spacy error: RuntimeError: Language not supported,"I am going to add new entities to the own spacy data model ""mymodel"". Before I have installed ""mymodel"" using this tutorial and it was working good. When I want to use ""mymodel"" to add new entities I have a misunderstanding. Please, help me
","The problem here is that spacy.load() currently expects either a language ID (e.g. 'en'), or a shortcut link to a model that tells spaCy where to find the data. Because spaCy can't find a shortcut link, it assumes that 'my_model' is a language, which obviously doesn't exist.

You can set up a link for your model like this:

python -m spacy link my_model my_model # if it's installed via pip, or:
python -m spacy link /path/to/my_model/data my_model
This will create a symlink in the /spacy/data directory, so you should run it with admin permissions.

Alternatively, if you've created a model package that can be installed via pip, you can simply install and import it, and then call its load() method with no arguments:

import my_model
nlp = my_model.load()
In some cases, this way of loading models is actually more convenient, as it's cleaner and lets you debug your code more easily. For example, if a model doesn't exist, Python will raise an ImportError immediately. Similarly, if loading fails, you know there's likely a problem with the model's own loading and meta.

Btw: I'm one of the spaCy maintainers and I agree that the way spacy.load() currently works is definitely unideal and confusing. We're looking forward to finally changing this with the next major release. We're very close to releasing the first alpha of v2.0, which will solve this problem more elegantly, and will also include a lot of improvements to the training process and documentation.",response from spacy maintainer,"The response was provided by one of the Spacy maintainers, indicating that the library is actively maintained.",,1,C20230706015011758538,0.706074774,0.281501472,0.429482847,0.685333192,0.881577134,0.620685637,0.501121759,0.339614093,0.606044829,0.449560851,0.544007719,0.664610267,0.437089741,0.434372991,0.514548242,0.776386499,0.709012032,0.553204596,0.486060441,0.360670745,0.357075393,0.717658997,0.640227616,0.509447455,53response from spacy maintainer
279,81,Spacy,Feature,Lemmatization,Lemmatization feature,59636002,Spacy lemmatization of a single word,"I am trying to get the lemmatized version of a single word. Is there a way using ""spacy"" (fantastic python NLP library) to do this.
Below is the code I have tried but this does not work):

from spacy.lemmatizer import Lemmatizer
from spacy.lookups import Lookups
lookups = Lookups()
lemmatizer = Lemmatizer(lookups)
word = ""ducks""
lemmas = lemmatizer.lookup(word)
print(lemmas)
The result I was hoping for was that the word ""ducks"" (plural) would result in ""duck"" (singular). Unfortunately, ""ducks"" (plural) is returned.

Is there a way of doing this?

NOTE: I realize that I could process an entire string of words from a document (nlp(document)) and then find the required token and then get its lemma (token.lemma_), but the word(s) I need to lemmatize are somewhat dynamic and are not able to be processed as a large document.","Otherwise you can keep using spaCy, but after disabling parser and NER pipeline components:

Start by downloading a 12M small model (English multi-task CNN trained on OntoNotes)
$ python -m spacy download en_core_web_sm
Python code
import spacy
nlp = spacy.load('en_core_web_sm', disable=['parser', 'ner']) # just keep tagger for lemmatization
"" "".join([token.lemma_ for token in nlp('ducks')])
Output

> duck",spacy supports lemmatization,Spacy has a lemmatizer that can be used to obtain the base form of a word.,,1,C20230706015135624843,0.823705673,0.600538909,0.513162255,0.657723546,0.847729385,0.681191802,0.682403326,0.611690998,0.658022821,0.48191309,0.534635901,0.669111848,0.667559385,0.654263496,0.551172972,0.594991922,0.791984022,0.578918099,0.777205944,0.593027592,0.659918725,0.628019929,0.686721981,0.616468668,81spacy supports lemmatization
194,57,Spacy,Active Maintenance,github,Active Maintenance aspect,46765198,Unable to load spacy English model - 'WindowsPath' object has no attribute 'read',"I installed spacy using pip and then downloaded the English model using  
$ python -m spacy download en which after downloading gave me the message

You can now load the model via spacy.load('en')
I have the English model files(en_core_web_sm) downloaded to the working directory, am I missing something? Do I need to set a path variable? Any help is much appreciated, thanks!",If anybody else receives this error : I opened this as an issue with spaCy's developers on Github. I was suggested using Python 3.6 instead of 2.7 for the moment as there is no alternate workaround to the problem. The next spaCy version should cover this bugfix (I'm told).,active community,The community is active and responsive as the issue was raised with the developers on Github and a solution was suggested.,No answer available against the challenge,1,C20230706015017768465,0.644432068,0.71988517,0.498037845,0.381968379,0.583461285,0.504461765,0.605074167,0.679171622,0.829131246,0.37810111,0.584642291,0.657540083,0.567971706,0.771176934,0.735918581,0.403883815,0.529350102,0.469770581,0.578676581,0.547977567,0.448973238,0.227261052,0.406678677,0.415925503,57active community
204,61,Spacy,Security,leak,Security aspect,58956171,"Dataflow job failed after more than 6 hours with ""The worker lost contact with the service""?","I am using Dataflow to read data from BigQuery and then do NLP preprocessing using python. I am using Python 3 and SDK 2.16.0. I am using 100 workers (provite IP, private access and Cloud NAT) with workers in europe-west6 and endpoint in europe-west1. The BigQuery tables are in US. Test jobs were working without any issue but when trying to process the full table (32 GB), the job failed after 6h 40 min and it is hard to fully understand what is the underlying error.","After some test and after few plots for monitoring, it was clear that even if the length of the text was the sime the processing time started to augment rapidly (botton right plot)
Then it became clear that the issue was with SpaCy 2.1.8 (memory leak).

Using Spacy 2.2.3 fix the issue. Now the 32 Gb of data are processed in 4h30 without any issue.",bigquery security measures,"The BigQuery data tables being located in the US could mean that there are security measures in place to ensure confidentiality, integrity, and availability of the data.",No answer available against the challenge,0,C20230706015024731108,0.791670322,0.655772626,0.663952529,0.931851625,0.90962249,0.967939854,0.573814332,0.511717319,0.661818266,0.851228356,0.727673829,0.695319176,0.308958858,0.530004799,0.493381202,0.430623174,0.65707159,0.588748097,0.392193109,0.446204454,0.416032642,0.107347228,0.010987476,0.748141825,61bigquery security measures
287,84,Spacy,Feature,NER,NER feature,57536896,Custom entity ruler with SpaCy did not return a match,"This link shows how to create custom entity ruler.

I basically copied and modified the code for another custom entity ruler and used it to find a match in a doc as follows:
However, when I run the code (in Jupyter notebook), nothing returned.

Could you please tell me:

If the code returned nothing, did it mean no match was found?
Why couldn't my code find a match although it's almost identical to the original (except for the patterns added to the ruler)? What did I do wrong?","The problem is an interaction between the NER component provided in the English model and your EntityRuler component. The NER component finds 2 as a number (CARDINAL) and there's a restriction that entities aren't allowed to overlap, so the EntityRuler component doesn't find any matches.

You can either add your EntityRuler before the NER component:

nlp.add_pipe(ruler, before='ner')
Or tell the EntityRuler that it's allowed to overwrite existing entities:

ruler = EntityRuler(nlp, overwrite_ents=True)",solution: change pipeline order,Adjusting the pipeline order by adding the EntityRuler before the NER component can prevent overlapping entities from causing issues.,,1,C20230706015142743653,0.687589765,0.653910935,0.630185664,0.96119374,0.740490735,0.724640846,0.752350867,0.678087533,0.882144153,0.866252899,0.78480792,0.741623163,0.686695457,0.722055376,0.628362119,0.764136374,0.614202023,0.831302881,0.762705922,0.814780712,0.851915121,0.852673173,0.840611935,0.865298331,84solution: change pipeline order
193,56,Spacy,Active Maintenance,github,Active Maintenance aspect,51855137,Rasa NLU: Tensorflow embedding with entity extraction,"Tensorflow embedding has a very good intent recogition.

In my experience it improved test results from about 45% confidence to 95% for simple inputs such as ""Hello"" compared to spacy.

But out of the box it does not have any entity extraction.

Is there any Pipeline configuration to solve this?","Config

The configuration below contains ner_crf for entity extraction.
Version

Rasa NLU: >=0.13.0

credit: github issue",version,The answer mentions that the solution is applicable for Rasa NLU versions equal or greater than 0.13.0.,,1,C20230706015017294347,0.755632162,0.589820385,0.686297297,0.688590527,0.679125547,0.460871518,0.71167469,0.645338655,0.528056085,0.711378813,0.71565789,0.764202416,0.594249308,0.411973029,0.639628589,0.492093533,0.496830136,0.764367759,0.670328557,0.625266552,0.528393149,0.710897565,0.706643522,0.693560481,56version
243,72,Spacy,Feature,POS,POS tagging feature,42830248,how to write spacy matcher of POS regex,"Spacy has two features I'd like to combine - part-of-speech (POS) and rule-based matching.

How can I combine them in a neat way?

For example - let's say input is a single sentence and I'd like to verify it meets some POS ordering condition - for example the verb is after the noun (something like noun**verb regex). result should be true or false. Is that doable? or the matcher is specific like in the example

Rule-based matching can have POS rules?

If not - here is my current plan - gather everything in one string and apply regex","Sure, simply use the POS attribute.

import spacy
nlp = spacy.load('en')
from spacy.matcher import Matcher
from spacy.attrs import POS
matcher = Matcher(nlp.vocab)
matcher.add_pattern(""Adjective and noun"", [{POS: 'ADJ'}, {POS: 'NOUN'}])

doc = nlp(u'what are the main issues')
matches = matcher(doc)",efficiency,"Spacy provides efficient NLP pipelines, making it easier to process large amounts of text.",No answer available against the challenge,0,C20230706015045602098,0.784891069,0.550464272,0.706064343,0.671944857,0.799368858,0.5357849,0.506098211,0.499754697,0.48508063,0.700426519,0.645047724,0.54984498,0.613208771,0.599927723,0.621555567,0.597349942,0.610526085,0.467535526,0.69140774,0.518062711,0.61157763,0.501847208,0.583723605,0.629522443,72efficiency
98,28,Spacy,Performance,fast,Performance aspect,40615717,Spacy.io multithreading with custom pipelines,"I'm trying to use Spacy.io with custom pipelines for language processing, but it seems that when I add a custom function to the pipeline the process runs only on one thread. With default pipeline process uses all the threads specified.

This is how I defined pipeline:

nlp = spacy.load(language, create_pipeline=custom_pipeline)
This is custom_pipeline function:

def custom_pipeline(nlp):
    return (nlp.tagger, score_vocab_pipe)
This is how I run the pipeline:

nlp.pipe(texts, batch_size=1000, n_threads=8)
Are there any requisites for custom pipeline functions to support multithreading with spacy?","This post might give you a better understanding of how the multi-threading is implemented. The multi-threading is described in the docs here.

In short: the tagger doesn't currently release the GIL, so the tagger.pipe() method is just a generator that applies the tagger one-by-one. The tagger should be quite fast for most workloads with one thread per process, especially since it doesn't use much memory. You can see the recipe for multi-processing batch jobs here.

We could release the GIL around the tagger as well, to allow efficient multi-threading. If you'd like to work on this, we can talk about it on the tracker or the spaCy Gitter.",multi-processing recipe,There is a recipe for multi-processing batch jobs in Spacy that can help improve performance for multi-threading with custom pipelines.,,1,C20230706014921525223,0.807668209,0.682444453,0.619682491,0.934600651,0.842806101,0.83506304,0.736471653,0.765273988,0.617550313,0.578211427,0.776855469,0.556949437,0.618795693,0.541166425,0.573204756,0.668275237,0.65848124,0.672977507,0.618389368,0.629197359,0.580172718,0.887948215,0.828086495,0.801623523,28multi-processing recipe
171,49,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",proactive approach to issue resolution,"The spaCy maintainer provided a specific command to address the user's issue, indicating a proactive and knowledgeable approach to resolving problems.",,1,C20230706015005571661,0.759489417,0.686319292,0.706024468,0.772699237,0.842336833,0.739308298,0.791835666,0.793450058,0.822746098,0.735137403,0.823147416,0.731757998,0.575259566,0.763121068,0.661627293,0.60976547,0.570177436,0.442086458,0.848218203,0.767883718,0.541903615,0.781058133,0.632485807,0.554628789,49proactive approach to issue resolution
223,67,GSON,Security,attack,Security aspect,53661408,Retrofit2 strange combination of different braces in front of request Body,"I am using Retrofit2 and I got stuck on the problem. I wrote simple entity for body:
also I wrote custom serializer for it:
DateTimeUtil:
and in request body somehow appears this:
How this "")]}'"" could be attached at front of my ""date"" json in request?
Only that I found is after JsonWriter do some magic in buffer.readByteString() it stores broken body.","I found where was the problem comes from:

Here my custom GsonBuilder:

private fun getGsonFactory(): Gson {
        return GsonBuilder()
            .setLenient()
            .serializeSpecialFloatingPointValues()
            .setLongSerializationPolicy(LongSerializationPolicy.DEFAULT)
            .generateNonExecutableJson()
            .enableComplexMapKeySerialization()
            .serializeNulls()
            .setPrettyPrinting()
            .registerTypeAdapter(CleaningProgress::class.java, CleaningProgressDeserializer())
            .create()
    }
The line of code below, add that "")]}'"" at front of request. Why am I add it to builder? I trust official documentation about this method:

Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some special text. This prevents attacks from third-party sites through script sourcing.",trust in documentation,The developer trust that the official documentation is correct in their recommendation to use the generateNonExecutableJson() method to improve security.,,1,C20230706015034552180,0.666405678,0.701671243,0.488813549,0.791531444,0.507012665,0.571341753,0.770664334,0.778731167,0.769260287,0.828641593,0.713874221,0.66602397,0.617165983,0.653044581,0.405684501,0.672494471,0.634863257,0.624854743,0.695333064,0.64583236,0.596443057,0.649553359,0.56021136,0.438819468,67trust in documentation
58,17,Spacy,Documentation,documentation,Documentation aspect,61241351,"Install specific version of spacy - working with pip, but not with conda","I am revisiting some code I wrote months ago with Spacy Version 2.1.8. I need this version of spacy. pip install is working but Anaconda does not even show that spacy is installed. And

conda install spacy=2.1.8
gives the PackagesNotFoundError error.","As explained in spaCy documentation, you can take advantage of the conda-forge community repository to install spacy

$ conda install -c conda-forge spacy=2.1.8
This version should be available according to spaCy's page on Conda Forge.",clear explanation,The provided explanation in the documentation is succinct and focuses on solving the issue of installing specific Spacy versions.,,0,C20230706014431657945,0.534980953,0.642811,0.6074754,0.75166297,0.519652307,0.519292295,0.727140069,0.711556673,0.646530509,0.846998692,0.692282617,0.674843371,0.455421835,0.30898273,0.635138214,0.618811667,0.65582794,0.618403971,0.578936279,0.41028595,0.606652379,0.698029339,0.623274207,0.585053027,17clear explanation
260,76,Spacy,Feature,dependency parsing,dependency parsing feature,55521858,"spacy noun-chunking creates unexpected lemma, pos, tag, and dep","I am using spacy to parse documents and unfortunately I am unable to process noun chunks the way I would have expected them to be processed. 

I expected a ""lemma"" would be the phrase ""the big dog"" with plural form changed to singular and the phrase would be ""pos"" of ""NOUN"", a ""tag"" of ""NNS"", and a ""dep"" of ""nsubj"".

Is this the correct behaviour, or am I using spacy incorrectly? If I am using spacy incorrectly, please let me know the correct manner in which to perform this task.","There are a few things to consider here

Lemmatisation is token based
POS tagging and dependency parsing is predictive
You probably will get the big dog if you take the lemma_ attribute for each token. It does not update the token pos of you use the attribute.

Also, since dependency parsing and POS tagging is trained in a predictive model, it is not guaranteed to always be ""right"" from a human linguistic perspective.

Other than the lemma issue, it seems you are using spacy correct",predictive model not always linguistically accurate,The predictive nature of Spacy's parsing model means that it may not always align perfectly with human linguistic perspectives.,No answer available against the challenge,1,C20230706015054333723,0.828944802,0.728730738,0.610896945,0.905621886,0.649400592,0.619561076,0.765320361,0.801890671,0.76462394,0.619405925,0.640464425,0.731631875,0.630669892,0.513987243,0.547561049,0.607482851,0.619896114,0.538469136,0.801286399,0.787346721,0.747831821,0.719783545,0.789531887,0.68600589,76predictive model not always linguistically accurate
273,80,Spacy,Feature,Lemmatization,Lemmatization feature,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.

class SpacyLemmatizer(object):
    def __init__(self, smodel):
        import spacy
        self.lemmatizer = spacy.load(smodel).vocab.morphology.lemmatizer

    # get the lemmas for every upos
    def getLemmas(self, entry):
        possible_lemmas = set()
        for upos in ('NOUN', 'VERB', 'ADJ', 'ADV'):
            lemmas = self.lemmatizer(entry, upos, morphology=None)
            lemma = lemmas[0]    # See morphology.pyx::lemmatize
            possible_lemmas.add( lemma )
        return possible_lemmas",loading model with spacy.load,The SpacyLemmatizer object uses the spacy.load method to load the model and get the lemmatizer object.,,1,C20230706015102389529,0.826765001,0.61604768,0.64375788,0.934709966,0.698425412,0.671530485,0.902230382,0.764642954,0.341269255,0.724316955,0.330898434,0.315910816,0.574944139,0.573063076,0.492542297,0.670906723,0.759787738,0.572286248,0.751114726,0.620027483,0.411249995,0.750855505,0.384629756,0.33291623,80loading model with spacy.load
221,66,GSON,Security,Security,Security aspect,39176229,Deserializing to a templated class with Gson,"I have a class with a nested subclass
Currently I would like to be able to have a function that takes as a parameter the held class, and returns an appropriate instance of GenericClassHolder, i.e. something like my current code:
But this does not work in my current implementation, with the error

Unable to invoke no-args constructor for GenericClassHolder<T>. Register an InstanceCreator with Gson for this type may fix this problem.
How can I succinctly achieve my aforementioned goal of having a function that takes as input the specification for a class that may change and parses to this object accordingly? If it is not possible to achieve an elegant solution through a function, how can I achieve this goal without one?","I deployed this code in a Google Appengine instance, and due to some security reasons, I could not deserialize the way I was deserializing and replicate the same way on my local machine. The solution was to make the deserialized classes static; they were nested inside of an outer encapsulating class as well",importance of secure handling,"The conversation highlights the importance of handling data and code securely in different environments, especially in context of web applications and web services.",,1,C20230706015033617762,0.737811267,0.770592749,0.636000633,0.898732007,0.585674107,0.717952311,0.752299845,0.723921597,0.507876158,0.712436616,0.692920208,0.550222635,0.691656291,0.698132813,0.644887865,0.942697048,0.412352383,0.393177181,0.645059288,0.568138897,0.626073122,0.833998621,0.546887517,0.560603857,66importance of secure handling
183,53,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44176829,Python Spacy error: RuntimeError: Language not supported,"I am going to add new entities to the own spacy data model ""mymodel"". Before I have installed ""mymodel"" using this tutorial and it was working good. When I want to use ""mymodel"" to add new entities I have a misunderstanding. Please, help me
","The problem here is that spacy.load() currently expects either a language ID (e.g. 'en'), or a shortcut link to a model that tells spaCy where to find the data. Because spaCy can't find a shortcut link, it assumes that 'my_model' is a language, which obviously doesn't exist.

You can set up a link for your model like this:

python -m spacy link my_model my_model # if it's installed via pip, or:
python -m spacy link /path/to/my_model/data my_model
This will create a symlink in the /spacy/data directory, so you should run it with admin permissions.

Alternatively, if you've created a model package that can be installed via pip, you can simply install and import it, and then call its load() method with no arguments:

import my_model
nlp = my_model.load()
In some cases, this way of loading models is actually more convenient, as it's cleaner and lets you debug your code more easily. For example, if a model doesn't exist, Python will raise an ImportError immediately. Similarly, if loading fails, you know there's likely a problem with the model's own loading and meta.

Btw: I'm one of the spaCy maintainers and I agree that the way spacy.load() currently works is definitely unideal and confusing. We're looking forward to finally changing this with the next major release. We're very close to releasing the first alpha of v2.0, which will solve this problem more elegantly, and will also include a lot of improvements to the training process and documentation.",acknowledgment of confusing method,The maintainer explicitly acknowledged that the method of loading models is currently unideal and confusing.,,1,C20230706015012382461,0.583319902,0.788240671,0.649172425,0.790721834,0.54457736,0.668017685,0.513587952,0.818519592,0.538730979,0.471533448,0.345301598,0.576666653,0.474462211,0.389914751,0.684762597,0.410936296,0.427659452,0.489980131,0.582523286,0.646859229,0.646768391,0.732035041,0.558069229,0.78908968,53acknowledgment of confusing method
222,66,GSON,Security,Security,Security aspect,39176229,Deserializing to a templated class with Gson,"I have a class with a nested subclass
Currently I would like to be able to have a function that takes as a parameter the held class, and returns an appropriate instance of GenericClassHolder, i.e. something like my current code:
But this does not work in my current implementation, with the error

Unable to invoke no-args constructor for GenericClassHolder<T>. Register an InstanceCreator with Gson for this type may fix this problem.
How can I succinctly achieve my aforementioned goal of having a function that takes as input the specification for a class that may change and parses to this object accordingly? If it is not possible to achieve an elegant solution through a function, how can I achieve this goal without one?","I deployed this code in a Google Appengine instance, and due to some security reasons, I could not deserialize the way I was deserializing and replicate the same way on my local machine. The solution was to make the deserialized classes static; they were nested inside of an outer encapsulating class as well",possible security implications,The issue with deserialization could have possible security implications related to preventing malicious code execution or preventing unauthorized access to sensitive data.,No answer available against the challenge,0,C20230706015033125862,0.693597257,0.584910214,0.413222224,0.702988505,0.567091942,0.472647905,0.630055606,0.554430783,0.338641196,0.621425331,0.48451826,0.680292964,0.29607439,0.575682878,0.685669184,0.386301219,0.421579689,0.227634355,0.263415873,0.397488594,0.563441157,0.572470367,0.591841817,0.474065602,66possible security implications
174,50,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",prodigy tool development,"The answer mentioned the development of a tool called Prodigy, which suggests that the SpaCy library is actively maintained and updated.",,1,C20230706015006612277,0.735454559,0.577951729,0.714171708,0.899152219,0.835223615,0.940263093,0.846920371,0.866961241,0.758950889,0.88117975,0.682955682,0.688676238,0.52027899,0.505906641,0.459788412,0.79008013,0.780038714,0.936457396,0.796808958,0.707921445,0.821246505,0.818398058,0.870270371,0.772343159,50prodigy tool development
278,81,Spacy,Feature,Lemmatization,Lemmatization feature,59636002,Spacy lemmatization of a single word,"I am trying to get the lemmatized version of a single word. Is there a way using ""spacy"" (fantastic python NLP library) to do this.
Below is the code I have tried but this does not work):

from spacy.lemmatizer import Lemmatizer
from spacy.lookups import Lookups
lookups = Lookups()
lemmatizer = Lemmatizer(lookups)
word = ""ducks""
lemmas = lemmatizer.lookup(word)
print(lemmas)
The result I was hoping for was that the word ""ducks"" (plural) would result in ""duck"" (singular). Unfortunately, ""ducks"" (plural) is returned.

Is there a way of doing this?

NOTE: I realize that I could process an entire string of words from a document (nlp(document)) and then find the required token and then get its lemma (token.lemma_), but the word(s) I need to lemmatize are somewhat dynamic and are not able to be processed as a large document.","Otherwise you can keep using spaCy, but after disabling parser and NER pipeline components:

Start by downloading a 12M small model (English multi-task CNN trained on OntoNotes)
$ python -m spacy download en_core_web_sm
Python code
import spacy
nlp = spacy.load('en_core_web_sm', disable=['parser', 'ner']) # just keep tagger for lemmatization
"" "".join([token.lemma_ for token in nlp('ducks')])
Output

> duck",initial code did not work,The initial code did not provide the expected result when it was run.,,1,C20230706015136464612,0.634551764,0.426227838,0.205841169,0.450185835,0.416007578,0.659987986,0.323408365,0.496727943,0.28230232,0.545656264,0.753757119,0.641962111,0.6871351,0.420178562,0.29172188,0.483751625,0.402102321,0.554317117,0.259451896,0.545914471,0.330490857,0.567517102,0.740569711,0.752204657,81initial code did not work
74,21,Spacy,Performance,performance,Performance aspect,48169545,Does spacy take as input a list of tokens?,"I would like to use spacy's POS tagging, NER, and dependency parsing without using word tokenization. Indeed, my input is a list of tokens representing a sentence, and I would like to respect the user's tokenization. Is this possible at all, either with spacy or any other NLP package ?

For now, I am using this spacy-based function to put a sentence (a unicode string) in the Conll format:
I would like to do the same while having as input a list of tokens...","You can run Spacy's processing pipeline against already tokenised text. You need to understand, though, that the underlying statistical models have been trained on a reference corpus that has been tokenised using some strategy and if your tokenisation strategy is significantly different, you may expect some performance degradation.

Here's how to go about it using Spacy 2.0.5 and Python 3. If using Python 2, you may need to use unicode literals.",version compatibility,Spacy 2.0.5 and Python 3 can be used for processing already tokenized text.,,1,C20230706014906069514,0.804935455,0.737834156,0.792313516,0.66346401,0.565876782,0.599084139,0.511618793,0.754508018,0.419882983,0.593643427,0.627162933,0.58397752,0.831144392,0.717879832,0.552610993,0.722371519,0.532468557,0.559335589,0.524958611,0.723872602,0.772201061,0.746605933,0.684090316,0.76543808,21version compatibility
310,91,Spacy,Feature,Entity linking,Entity linking feature,60809394,Can spaCy link only named entities?,"I'd would like to extract important entities and link them to Wikipedia entities. I've trained spaCy on a small sample of Wikipedia/WikiData and run entity linking on the review:

[('Tofu', 'PERSON', 'Q177378'), 
('Nyquil', 'WORK_OF_ART', 'NIL')]
I'd like other entities to be extracted and linked as well, e.g.:

kimchi -> Kimchi
cold -> Common cold
healing -> medicine 
medically -> medicine
It looks like spaCy can link only named entities. I've tried to explicitly list other entities as named (which obviously does not scale well):

ruler = EntityRuler(nlp)
patterns = [{""label"": ""ORG"", ""pattern"": ""kimchi""}, {""label"": ""ORG"", ""pattern"": ""cold""}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, spaCy does not seem to link new entities at all:

[ ('Tofu', 'PERSON', 'Q177378'),
  ('cold', 'ORG', ''),
  ('Nyquil', 'WORK_OF_ART', 'NIL'),
  ('kimchi', 'ORG', '')]
How can I make Spacy recognize also other entities?
Should this be done before training entity linking model or can be done with already trained model?
Is spaCy the right tool for my task at all?","In theory it's possible. First, you'll need to make sure you have a component that tags these kind of entities. You could train an NER model for this, but be aware that its performance might not be as good on things like ""cold"" than it would be for actual named entities like ""London"".

To create the Knowledge Base and the Entity Linker from Wikipedia/Wikidata, the example scripts are not limited to named entities - they attempt to parse anything that appears in an intra-wiki link. If the word ""cold"" gets linked to the page ""Common cold"", it should be able to learn it. The exact entities that are stored in the KB and that are used for training the EL model, depend on which entities are found by your entity recognizer component. So if you adjust that according to your use-case, the entity linking component will follow automatically.",named entity support,spaCy supports entity linking feature for named entities.,,1,C20230706015226084336,0.557568371,0.531550288,0.462562561,0.692105711,0.688130379,0.845725238,0.756694853,0.526280344,0.53447336,0.550404787,0.664786279,0.656919599,0.47220692,0.495755315,0.424789041,0.383254766,0.489782155,0.548256278,0.500967801,0.426797062,0.450836152,0.890236497,0.849805057,0.812369466,91named entity support
259,76,Spacy,Feature,dependency parsing,dependency parsing feature,55521858,"spacy noun-chunking creates unexpected lemma, pos, tag, and dep","I am using spacy to parse documents and unfortunately I am unable to process noun chunks the way I would have expected them to be processed. 

I expected a ""lemma"" would be the phrase ""the big dog"" with plural form changed to singular and the phrase would be ""pos"" of ""NOUN"", a ""tag"" of ""NNS"", and a ""dep"" of ""nsubj"".

Is this the correct behaviour, or am I using spacy incorrectly? If I am using spacy incorrectly, please let me know the correct manner in which to perform this task.","There are a few things to consider here

Lemmatisation is token based
POS tagging and dependency parsing is predictive
You probably will get the big dog if you take the lemma_ attribute for each token. It does not update the token pos of you use the attribute.

Also, since dependency parsing and POS tagging is trained in a predictive model, it is not guaranteed to always be ""right"" from a human linguistic perspective.

Other than the lemma issue, it seems you are using spacy correct",pos tagging and dependency parsing is predictive,Dependency parsing and POS tagging in Spacy is based on a predictive model.,Question not focused on main topic,1,C20230706015053804277,0.659815788,0.498394877,0.535303056,0.868664682,0.81145072,0.784952343,0.602977991,0.574654937,0.511980474,0.886841476,0.797808111,0.735646367,0.654783309,0.568340659,-0.032129459,0.728575468,0.472510964,0.575731277,0.627215922,0.549396634,0.190318614,0.848744214,0.005677002,0.033066332,76pos tagging and dependency parsing is predictive
291,85,Spacy,Feature,NER,NER feature,65220447,Add new named entity to Spacy's en_core_web_sm model?,"I'm following the example here on training a new entity type:

https://spacy.io/usage/training#example-new-entity-type

It works fine when I don't pass an existing model to it, and will correctly create a new model, which recognizes my new named entity e.g.

 python.exe train-new-entity-type.py
It also works fine when I pass an existing model to it (created by running it once before), and will correctly load the model in the dir/my_model dir, which still recognizes my new named entity e.g.

 python.exe train-new-entity-type.py -m dir/my_model
However, I want to train a new entity type, and add that to spacy's existing model, so that spacy will recognize it's own supported named entities as well as my new entity type, so I tried:

 python.exe train-new-entity-type.py -m en_core_web_sm
However, this didn't seem to work. Spacy's own supported named entities were recognized but they were not correct (vs just using the en_core_web_sm on its own without adding my new entity type to it), and my new entity type was no longer recognized at all.

Am I doing something wrong? Is this possible (adding named entities to en_core_web_sm)?","Read about the ""catastrophic forgetting"" problem when updating an existing model: https://spacy.io/usage/training#ner

It can be tricky to update an existing model, so it might be easier to train a separate model for your new entity type and add the NER component to the en_core_web_sm pipeline with a custom name. The main thing to watch out for is that you need to make sure the models are loaded with the same vocab so that you don't run into problems with the string store:

import spacy
nlp = spacy.load(""en_core_web_sm"")
custom_nlp = spacy.load(""my_model"", vocab=nlp.vocab)
nlp.add_pipe(custom_nlp.get_pipe(""ner""), name=""my_ner"", before=""ner"")
Where you add it in the pipeline (before/after the existing ner) will determine which entity spans have priority, since the ner component won't modify existing entity spans.",same vocab required,Ensure that the models are loaded with the same vocab to avoid any problems with the string store.,,1,C20230706015216152367,0.665303051,0.548026741,0.789694488,0.542102575,0.572625101,0.615460634,0.687489927,0.767960668,0.799237847,0.763476014,0.771784008,0.676738024,0.664153516,0.556803167,0.718468487,0.592077911,0.459268957,0.423833668,0.516929448,0.78008604,0.661585212,0.691284239,0.730574191,0.736366689,85same vocab required
326,96,Spacy,Feature,Text classification,Text classification feature,48834832,How do I create gold data for TextCategorizer training?,"I want to train a TextCategorizer model with the following (text, label) pairs.

Label COLOR:

The door is brown.
The barn is red.
The flower is yellow.
Label ANIMAL:

The horse is running.
The fish is jumping.
The chicken is asleep.
I am copying the example code in the documentation for TextCategorizer.

textcat = TextCategorizer(nlp.vocab)
losses = {}
optimizer = nlp.begin_training()
textcat.update([doc1, doc2], [gold1, gold2], losses=losses, sgd=optimizer)
The doc variables will presumably be just nlp(""The door is brown."") and so on. What should be in gold1 and gold2? I'm guessing they should be GoldParse objects, but I don't see how you represent text categorization information in those.","According to this example train_textcat.py it should be something like {'cats': {'ANIMAL': 0, 'COLOR': 1}} if you want to train a multi-label model. Also, if you have only two classes, you can simply use {'cats': {'ANIMAL': 1}} for label ANIMAL and {'cats': {'ANIMAL': 0}} for label COLOR.

You can use the following minimal working example for a one category text classification;",spacy supports textcategorizer,The user is able to train a TextCategorizer model with labeled data pairs using example code from Spacy's documentation.,Question not focused on main topic,0,C20230706015235056380,0.562290251,0.678403616,0.45449239,0.565122664,0.609652638,0.586478233,0.703010082,0.819448411,0.906545341,0.824892521,0.716671228,0.83610642,0.636355042,0.644804835,0.299447119,0.39992404,0.371326715,0.530577242,0.4503842,0.728310406,0.525545537,0.432056218,0.424324334,0.43496722,96spacy supports textcategorizer
170,49,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,51037475,spaCy language module not downloading,"I am working on Ubuntu 16.04. I downloaded spaCy using conda and am working on jupyter notebook. I tried

python -m spacy download en
which gives the following error:

/home/nikita/anaconda3/bin/python: No module named spacy.main; 'spacy' is a package and cannot be directly executed

So I tried

python -m spacy.en.download
which gives these errors:

Then I tried

python3 -m spacy.en.download --force all
which gives the same errors as the 2nd one. Please help!","For some reason, conda seems to have installed an older version of spaCy. To make sure you're installing the latest version (or any other specific one), you can use the following command:

conda install -c conda-forge spacy=2.0.11
(Disclaimer: I'm one of the spaCy maintainers. We're still investigating why this happens to some users, and whether it's related to how dependencies are resolved, an old Anaconda distribution that ships with spaCy 0.101.0 or something entirely different. The relevant thread on the issue tracker is here.)",ongoing issue investigation,"The spaCy maintainer indicated that they were investigating the issue to prevent it from affecting future users, demonstrating a focus on maintaining the library.",,1,C20230706015004523526,0.610666692,0.725659728,0.618449867,0.558072805,0.641692758,0.407858044,0.594527066,0.829979181,0.382237434,0.704437196,0.584230423,0.449805647,0.495889932,0.701425195,0.571927488,0.591720104,0.520568132,0.293374091,0.382046729,0.805997312,0.332535714,0.464474201,0.451719016,0.375514597,49ongoing issue investigation
277,81,Spacy,Feature,Lemmatization,Lemmatization feature,59636002,Spacy lemmatization of a single word,"I am trying to get the lemmatized version of a single word. Is there a way using ""spacy"" (fantastic python NLP library) to do this.
Below is the code I have tried but this does not work):

from spacy.lemmatizer import Lemmatizer
from spacy.lookups import Lookups
lookups = Lookups()
lemmatizer = Lemmatizer(lookups)
word = ""ducks""
lemmas = lemmatizer.lookup(word)
print(lemmas)
The result I was hoping for was that the word ""ducks"" (plural) would result in ""duck"" (singular). Unfortunately, ""ducks"" (plural) is returned.

Is there a way of doing this?

NOTE: I realize that I could process an entire string of words from a document (nlp(document)) and then find the required token and then get its lemma (token.lemma_), but the word(s) I need to lemmatize are somewhat dynamic and are not able to be processed as a large document.","Otherwise you can keep using spaCy, but after disabling parser and NER pipeline components:

Start by downloading a 12M small model (English multi-task CNN trained on OntoNotes)
$ python -m spacy download en_core_web_sm
Python code
import spacy
nlp = spacy.load('en_core_web_sm', disable=['parser', 'ner']) # just keep tagger for lemmatization
"" "".join([token.lemma_ for token in nlp('ducks')])
Output

> duck",downloading pre-trained model,Spacy has a pre-trained model (English multi-task CNN trained on OntoNotes) that can be downloaded and used for performing lemmatization.,,1,C20230706015137410511,0.826153398,0.687905252,0.808067381,0.769504428,0.795545161,0.780323684,0.495770454,0.615739584,0.577125907,0.46854347,0.670076609,0.621500432,0.768458068,0.570853114,0.673714936,0.626308322,0.601792634,0.608033538,0.61638546,0.55870527,0.726971984,0.746006966,0.734863877,0.526633561,81downloading pre-trained model
79,23,Spacy,Performance,performance,Performance aspect,72413618,How can I make it so that I process each sentence to look for and replace with a synonym for the words that match?,"I am currently working with spacy and have a corpus (containing 960,256 words) that looks like this:
I have a function that looks for the synonym of a word (using spacy):

Which returns an array of answers like so:
What I want is to grab the corpus, feed it sentence by sentence and word by word to most_similar so I can save the list of words to replace and do so by using replace_wordthe thing is that I'm not sure how to do this. I've tried for a while but it always fails somehow (either won't take batches so I can't do it at once, the words end up being empty vectors if I simply split each sentence by .split("" "") so...could you help me out please?","I hope I understood what you need correctly. I'm guessing you want to:

Iterate over a corpus
Find specific tokens using the matcher
Find synonyms of the matched tokens
Return a new list of sentences but with the replaced tokens.
If that's the case then what you need is a valid similarity function (I tried the one above but it didn't work for me properly) but you can try this:
You also mentioned that you want this to run on a corpus. I recommend that you use the nlp.pipe() method for performance gains combined with the set_extension method. You can do it like this:",issues with similarity function,User reported issues with the similarity function they tried.,,1,C20230706014910516754,0.654725373,0.60559696,0.758238077,0.795203686,0.820251048,0.933048785,0.775347531,0.572867632,0.656338513,0.643233001,0.757636905,0.620689988,0.504425168,0.451933444,0.686361015,0.551020682,0.501648545,0.513136923,0.508825243,0.5421471,0.565756738,0.627102554,0.735087395,0.707324326,23issues with similarity function
162,47,Spacy,Stability,version,Stability aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",active maintenance,The maintainer of the library is actively engaging with users on how to improve their experience with the library.,,0,C20230706015000328892,0.719782472,0.599764943,0.464060634,0.877665997,0.528066158,0.533653498,0.695831001,0.715407848,0.529476702,0.672549427,0.606253505,0.801404715,0.595850825,0.722192585,0.56897974,0.602735281,0.495208055,0.75824976,0.476818562,0.87294668,0.234414026,0.626304984,0.807145774,0.45815444,47active maintenance
228,68,Spacy,Feature,tokenization,tokenization feature,59500498,spacy tokenizer: is there a way to use regex as a key in custom exceptions for update_exc,"It is possible to add custom exceptions to spacy tokenizer. And these exceptions work fine. However, as far as I know, it's possible to use only strings as keys to match for those exceptions. It's done this way:
The only clue I found is: https://github.com/explosion/spaCy/issues/840

In that revision of tokenizer_exceptions.py there was some way to use regexps as keys for tokenizer exceptions(however, I haven't found any examples to do so)

But in current revisions, at least initial analysis hasn't shown any ways to do s

So is there a way to solve this task?

(input: regex as a key for exception, output - phone numbers with spaces inside)","No, there's no way to have regular expressions as tokenizer exceptions. The tokenizer only looks for exceptions as exact string matches, mainly for reasons of speed. The other difficulty for this kind of example is that tokenizer exceptions currently can't contain spaces. (Support for spaces is planned for a future version of spacy, but not regexes, which would still be too slow.)

I think the best way to do this would be to add a custom pipeline component at the beginning of the pipeline that retokenizes the document with the retokenizer: https://spacy.io/api/doc#retokenize. You can provide any required attributes like lemmas while retokenizing.",no spaces,Tokenizer exceptions currently do not support spaces.,,1,C20230706015036902513,0.728775203,0.416773051,0.562824667,0.829213202,0.758443475,0.81586206,0.544632733,0.34950006,0.485562801,0.619316697,0.681256413,0.900994778,0.651132286,0.372560143,0.524417877,0.636386871,0.613723934,0.77594322,0.381203234,0.452611268,0.561739683,0.793016315,0.693901122,0.731791794,68no spaces
132,38,Spacy,Stability,bug,Stability aspect,64164360,How can I add a specific substring to tokenize on in spaCy?,"I am using spaCy to tokenize a string, and the string is likely to contain a specific substring. If the substring is present, I would like spaCy to treat the substring as a token, regardless of any other rules it has. I would like to keep all other rules intact. Is this possible?

To provide a concrete example, suppose the substring of interest is 'banana'; I want 'I like bananabread.' to be tokenized as ['I', 'like', 'banana', 'bread', '.'].

Where do I go from here (keeping in mind that I would like to keep the rest of the tokenizer rules intact)? I have tried adding 'banana' to the prefixes, suffixes, and infixes, with no success.","Adding the string as a prefix, suffix, and infix should work, but depending on which version of spacy you're using, you may have run into a caching bug while testing. This bug is fixed in v2.2+.

With spacy v2.3.2:

(In v2.1 or earlier, the tokenizer customization still works on a newly loaded nlp, but if you've already processed some texts with the nlp pipeline and then modify the settings, the bug was that it would use the stored tokenization from the cache rather than the new settings.)",bug fix in latest version,The answer mentions a caching bug in earlier versions of Spacy that has been fixed in v2.2+.,,1,C20230706014941613282,0.705424845,0.440230906,0.49017179,0.487765223,0.5894593,0.531418383,0.608919799,0.843490839,0.72579217,0.534015059,0.438260436,0.838378429,0.597286165,0.416209191,0.515967667,0.332368523,0.420709997,0.388360888,0.55695188,0.602117896,0.714270592,0.692524791,0.614693642,0.766303241,38bug fix in latest version
38,11,Spacy,Documentation,documentation,Documentation aspect,58215855,"How to get full list of POS, Tag, and Dep in spaCy?","The POS, TAG, and DEP values used in spaCy are common ones of NLP, but I believe there are some differences depending on the corpus database.

For example, Universal Dependencies Contributors has listed 37 syntactic dependencies. Does spaCy use all of these 37 dependencies? And nothing more?

Is there a command to output all POS, TAG, and DEP values, spaCy may provide?","A specific pipeline component can show its labels:

nlp = spacy.load('en')
nlp.get_pipe(""tagger"").labels
# ('$', ""''"", ',', '-LRB-', '-RRB-', '.', ':', 'ADD', 'AFX', 'CC', 'CD', 'DT', 'EX', 'FW', 'HYPH', 'IN', 'JJ', 'JJR', 'JJS', 'LS', 'MD', 'NFP', 'NN', 'NNP', 'NNPS', 'NNS', 'PDT', 'POS', 'PRP', 'PRP$', 'RB', 'RBR', 'RBS', 'RP', 'SYM', 'TO', 'UH', 'VB', 'VBD', 'VBG', 'VBN', 'VBP', 'VBZ', 'WDT', 'WP', 'WP$', 'WRB', 'XX', '_SP', '``')
spacy.explain(label) will give a short definition for most labels, e.g.:

spacy.explain(""NN"")
# 'noun, singular or mass'
spacy.explain(""PERSON"")
# 'People, including fictional'
The detailed documentation is here: https://spacy.io/api/annotation",label differences,The labels used by spaCy may differ based on the corpus database being used.,wrong labeling,1,C20230706014346989310,0.694733024,0.59264642,0.706828356,0.824570417,0.886214435,0.869775295,0.696781635,0.673689306,0.687059999,0.802782893,0.884188235,0.82265383,0.72021538,0.471026748,0.532593489,0.480274856,0.3582578,0.457473189,0.657730162,0.58580178,0.66313678,0.566881657,0.623764694,0.846987486,11label differences
141,41,Spacy,Stability,bug,Stability aspect,68559878,Force 'parser' to not segment sentences?,"Is there an easy way to tell the ""parser"" pipe not to change the value of Token.is_sent_start ?

So, here is the story: I am working with documents that are pre-sentencized (1 line = 1 sentence), this segmentation is all I need. I realized the parser's segmentation is not always the same as in my documents, so I don't want to rely on the segmentation made by it.

I can't change the segmentation after the parser has done it, so I cannot correct it when it makes mistakes (you get an error). And if I segment the text myself and then apply the parser, it overrules the segmentation I've just made, so it doesn't work.

So, to force keeping the original segmentation and still use a pretrained transformer model (fr_dep_news_trf), I either :

disable the parser,
add a custom Pipe to nlp to set Token.is_sent_start how I want,
create the Doc with nlp(""an example"")
or, I simply create a Doc with

doc = Doc(words=[""an"", ""example""], sent_starts=[True, False])
and then I apply every element of the pipeline except the parser.

However, if I still do need the parser at some point (which I do, because I need to know some subtrees), If I simply apply it on my Doc, it overrules the segmentation already in place, so, in some cases, the segmentation is incorrect. So I do the following workaround:

Keep the correct segmentation in a list sentences = list(doc.sents)
Apply the parser on the doc
Work with whatever syntactic information the parser computed
Retrieve whatever sentencial information I need from the list I previously made, as I now cannot trust Token.is_sent_start.
It works, but it doesn't really feel right imho, it feels a bit messy. Is there an easier, cleaner way I missed ?

Something else I am considering is setting a custom extension, so that I would, for instance, use Token._.is_sent_start instead of the default Token.is_sent_start, and a custom Doc._.sents, but I fear it might be more confusing than helpful ...

Some user suggested using span.merge() for a pretty similar topic, but the function doesn't seem to exist in recent releases of spaCy (Preventing spaCy splitting paragraph numbers into sentences)","The parser is supposed to respect sentence boundaries if they are set in advance. There is one outstanding bug where this doesn't happen, but that was only in the case where some tokens had their sentence boundaries left unset.

If you set all the token boundaries to True or False (not None) and then run the parser, does it overwrite your values? If so it'd be great to have a specific example of that, because that sounds like a bug.

Given that, if you use a custom component to set your true sentence boundaries before the parser, it should work.

Regarding some of your other points...

I don't think it makes any sense to keep your sentence boundaries separate from the parser's - if you do that you can end up with subtrees that span multiple sentences, which will just be weird and unhelpful.

You didn't mention this in your question, but is treating each sentence/line as a separate doc an option? (It's not clear if you're combining multiple lines and the sentence boundaries are wrong, or if you're passing in a single line but it's turning into multiple sentences.)

Thanks a million for you answer! It made me go back to my documents and check every output of every element in the pipeline... Well, I feel terribly stupid, but I simply cannot reproduce my observation of a ""deffective parser"", everything seems fine now. I guess after my initial struggle with forcing my own sentence boundaries (which wasn't even actually that complicated ...), I convinced myself somehow it wasn't working even after my own boundaries were set ? Or I fixed something else in my code ? Terribly sorry. I'll keep an eye on it, might post here again if I find a mistake again",custom component workaround,Using a custom component to set sentence boundaries before running the parser should work if the user wants to override default segmentation.,,1,C20230706014947492313,0.702937782,0.522215605,0.522547007,0.457950652,0.526266515,0.796317637,0.689498305,0.657762408,0.630275488,0.753618181,0.72644645,0.849850953,0.526713431,0.578172863,0.472558588,0.564354897,0.5513919,0.80323422,0.764517426,0.696087301,0.741383731,0.787356675,0.789148033,0.802512288,41custom component workaround
202,60,Spacy,Security,leak,Security aspect,55841087,Python: Spacy and memory consumption,"1 - THE PROBLEM

I'm using ""spacy"" on python for text documents lemmatization. There are 500,000 documents having size up to 20 Mb of clean text.

The problem is the following: spacy memory consuming is growing in time till the whole memory is used.

2 - BACKGROUND

My hardware configuration: CPU: Intel I7-8700K 3.7 GHz (12 cores) Memory: 16 Gb SSD: 1 Tb GPU is onboard but is not used for this task

I'm using ""multiprocessing"" to split the task among several processes (workers). Each worker receives a list of documents to process. The main process performs monitoring of child processes. I initiate ""spacy"" in each child process once and use this one spacy instance to handle the whole list of documents in the worker.

3 - EXPECTATIONS

I have seen a good recommendation to build a separated server-client solution [here]Is possible to keep spacy in memory to reduce the load time?

Is it possible to keep memory consumption under control using ""multiprocessing"" approach?
","Memory problems when processing large amounts of data seem to be a known issue, see some relevant github issues:

https://github.com/explosion/spaCy/issues/3623
https://github.com/explosion/spaCy/issues/3556
Unfortunately, it doesn't look like there's a good solution yet.",known memory issues,"Memory problems when processing large amounts of data are a known issue, as evidenced by relevant github issues.",,1,C20230706015021820496,0.776934505,0.83213371,0.750355065,0.754083157,0.881244659,0.798489332,0.409102201,0.415850788,0.423839718,0.857438385,0.755425036,0.821616471,0.562855065,0.549910307,0.689822853,0.644205332,0.6221385,0.49594444,0.624579668,0.495295912,0.636470973,0.599669158,0.525199175,0.616516232,60known memory issues
72,21,Spacy,Performance,performance,Performance aspect,48169545,Does spacy take as input a list of tokens?,"I would like to use spacy's POS tagging, NER, and dependency parsing without using word tokenization. Indeed, my input is a list of tokens representing a sentence, and I would like to respect the user's tokenization. Is this possible at all, either with spacy or any other NLP package ?

For now, I am using this spacy-based function to put a sentence (a unicode string) in the Conll format:
I would like to do the same while having as input a list of tokens...","You can run Spacy's processing pipeline against already tokenised text. You need to understand, though, that the underlying statistical models have been trained on a reference corpus that has been tokenised using some strategy and if your tokenisation strategy is significantly different, you may expect some performance degradation.

Here's how to go about it using Spacy 2.0.5 and Python 3. If using Python 2, you may need to use unicode literals.",performance degradation,Performance degradation may occur if the user's tokenization strategy is significantly different from the reference corpus used in Spacy's statistical models.,,1,C20230706014833291870,0.800618589,0.663209975,0.669825256,0.787762225,0.472042859,0.384061456,0.830747724,0.80649972,0.686965466,0.755356789,0.866811872,0.630097091,0.609196246,0.53202635,0.398031414,0.589686036,0.344344199,0.262701035,0.753543079,0.830525875,0.726692379,0.883906484,0.673193395,0.692625999,21performance degradation
129,37,Spacy,Stability,bug,Stability aspect,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.",insufficient information for stability assessment,"It is difficult to determine the stability or thorough testing of the SpaCy library based on this conversation alone without a thorough analysis of its documentation, source code, and usage in various applications.",Original explanation is not conclusive,1,C20230706014940286001,0.581472039,0.843526781,0.471148998,0.534607887,0.53163588,0.704906344,0.777814746,0.782681406,0.481010348,0.745738149,0.536784828,0.505063355,0.406977177,0.884762347,0.498462141,0.819022715,0.573435128,0.597962379,0.524022222,0.59831804,0.505633652,0.430918008,0.602950156,0.406225532,37insufficient information for stability assessment
100,29,Spacy,Performance,fast,Performance aspect,69738938,How to use existing huggingface-transformers model into spacy?,"I'm here to ask you guys if it is possible to use an existing trained huggingface-transformers model with spacy.

My first naive attempt was to load it via spacy.load('bert-base-uncased'), it didn't work because spacy demands a certain structure, which is understandable.

Now I'm trying to figure out how to use the spacy-transformers library to load the model, create the spacy structure, and use it from that point as a normal spacy-aware model.

I don't know if it is even possible as I couldn't find anything regarding the subject. I've tried to read the documentation but all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place? I can believe someone has to train everything again with spacy.
","What you do is add a Transformer component to your pipeline and give the name of your HuggingFace model as a parameter to that. This is covered in the docs, though people do have trouble finding it. It's important to understand that a Transformer is only one piece of a spaCy pipeline, and you should understand how it all fits together.

To pull from the docs, this is how you specify a custom model in a config:

[components.transformer.model]
@architectures = ""spacy-transformers.TransformerModel.v3""
# XXX You can change the model name here
name = ""bert-base-cased""
tokenizer_config = {""use_fast"": true}
Going back to why you need to understand spaCy's structure, it's very important to understand that in spaCy, Transformers are only sources of features. If your HuggingFace model has an NER head or something it will not work. So if you use a custom model, you'll need to train other components, like NER, on top of it.

Also note that spaCy has a variety of non-Transformers built-in models. These are very fast to train and in many situations will give performance comparable to Transformers; even if they aren't as accurate, you can use the built-in models to get your pipeline configured and then just swap in a Transformer.

all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place?",creating spacy/en_core_web_sm model,"The pre-trained model spacy/en_core_web_sm was created through training on a large corpus of data and adjusting the model's parameters until it performed well on defined tasks like part-of-speech tagging, dependency parsing, and named entity recognition.",ChatGPT giving out of context response,0,C20230706014924545034,0.715058386,0.45538193,0.713163376,0.401624471,0.735347152,0.289717704,0.842892289,0.657700479,0.774344981,0.84854126,0.784735262,0.653277457,0.641179025,0.462008834,0.629662216,0.512833714,0.622547507,0.454382211,0.753378093,0.70114404,0.66990453,0.730984986,0.719729602,0.682108879,29creating spacy/en_core_web_sm model
145,42,Spacy,Stability,bug,Stability aspect,62737680,Spacy tagger loss is zero while training,"I use this snippet of code to train a tagger in spacy 2.3.0.
The problem is that the loss value is always zero. What am I doing wrong?","Sorry, this is a bug in v2.3.0. It will be fixed in the upcoming v2.3.1. You can train a tagger with spacy train instead or use v2.2.4 in the meanwhile.

If you'd like to have this fix sooner, you can also install from source in the current master branch (the fix is in commit b7107ac8).",active open-source community,The recommendation to install the fix from the current master branch highlights the active community of developers who are contributing to Spacy's stability and reliability.,No answer available against the challenge,0,C20230706014950557098,0.73200798,0.710210383,0.534402072,0.51762408,0.311981529,0.610055864,0.269520015,0.705588222,0.653545022,0.414658606,0.520120382,0.778956652,0.540769756,0.612586021,0.43331489,0.834173262,0.194282278,0.372324735,0.417899311,0.720205545,0.506762266,0.387963474,0.40075174,0.607963979,42active open-source community
33,10,Spacy,Documentation,documentation,Documentation aspect,48200524,Named entity recognition in Spacy,"I am trying to find Named entities for a sentence as below

import spacy.lang.en
parser = spacy.lang.en.English()
ParsedSentence = parser(u""Alphabet is a new startup in China"")
for Entity in  ParsedSentence.ents:  
    print (Entity.label, Entity.label_, ' '.join(t.orth_ for t in Entity))
I am expecting to get the result ""Alphabet"",""China"" but I am getting an empty set as result. What am I doing wrong here","As per spacy documentation for Name Entity Recognition here is the way to extract name entity

import spacy
nlp = spacy.load('en') # install 'en' model (python3 -m spacy download en)
doc = nlp(""Alphabet is a new startup in China"")
print('Name Entity: {0}'.format(doc.ents))
Result
Name Entity:  (China,) ",loading 'en' model,Required for Spacy to identify English language.,,1,C20230706014345533097,0.483219922,0.63904947,0.630183041,0.460094422,0.541309595,0.923859358,0.576259077,0.561980188,0.502767205,0.613962948,0.61966753,0.827338755,0.677987278,0.588567138,0.67227143,0.450370193,0.476494908,0.705280602,0.422396094,0.533230662,0.537307978,0.586665571,0.564587235,0.742990494,10loading 'en' model
123,36,Spacy,Stability,bug,Stability aspect,62796437,Spacy French langage gives NoneType error,"Here is the code :

import spacy
nlp = spacy.load('fr_core_news_sm')
doc = nlp('Demain je travaille ‚Äö√†√∂‚Äö√Ñ‚Ä† la maison')
for token in doc:
    print(token.text)
It gives the error :

File ""c:\users\ab\appdata\local\programs\python\python37\lib\site-packages\spacy\lang\fr\lemmatizer.py"", line 49, in call if self.is_base_form(univ_pos, morphology): TypeError: 'NoneType' object is not callable
If I change 'fr_core_news_sm' to 'en_core_web_sm', it works well.

My python version is 3.7.7. And Spacy version is 2.3.1.","This seems to be a bug at spaCy 2.3.1: https://github.com/explosion/spaCy/issues/5728

Downgrade to 2.3.0 and it should work: pip install spacy==2.3.0",active support,The quick identification of the issue and the provision of a workaround by the developers suggest that the library is well-supported and actively maintained.,,1,C20230706014937256590,0.826555431,0.336411327,0.605659008,0.318310797,0.759579062,0.347271532,0.546863437,0.678653121,0.445941359,0.587151706,0.675365686,0.609389424,0.494431734,0.646511436,0.363342911,0.561108828,0.496482432,0.634194851,0.591214597,0.735118091,0.215938851,0.602656186,0.521606028,0.256440103,36active support
333,98,Spacy,Feature,Rule-based matching,Rule-based matching feature,72346631,Highlight text parts based on labels,"thanks to fellow stackoverflowrians I have data labels that I would like to high light in the text:

eg. I have product description

Description: Tampered black round grey/natural swing with yellow load-bearing left hook
Features were extracted as

colors=['black','grey','natural','yellow']
shape = ['round']
direction= ['left']
In Spacy it is possible to highlight the features like this

enter image description here

Is there any possibility to highlight it also like this from the data I have as labels? So that I have labels shown in the text too? I dont know if Spacy is the good tool or any other is better?
","I'm not entirely sure what you're asking, but you can put entities of your own on the spaCy Doc object and pass them to Displacy.

To simply set entities manually, you can do this:

doc = nlp(...)
span = doc[0:1] # whatever span of the doc you want to highlight
span.ent_label_ = ""COLOR"" # the label you want
ents = [span] # in reality you could do more than one
doc.ents = ents
If you have word list and need to look for words, you can use rule-based matching with an EntityRuler. Check the rule-based matching guide.",spacy suitability,"Based on the conversation, Spacy appears to be a suitable tool for the user's needs of highlighting text based on labels, although this may depend on their specific use case.",,1,C20230706015240241771,0.705330014,0.792420983,0.738681674,0.791044593,0.787802517,0.788790524,0.823993921,0.74174279,0.783121467,0.858159661,0.791549981,0.751257896,0.762084901,0.494042426,0.682108998,0.618703663,0.528423369,0.584947169,0.701197207,0.604152143,0.622708976,0.74348712,0.704937875,0.666239798,98spacy suitability
93,27,Spacy,Performance,fast,Performance aspect,48199353,How to use spacy in large dataset with short sentences efficiently?,"I choose spacy to process kinds of text because of the performance of it's lemmatation compared with nltk. But When I process millions short text, it always consumed all of my memory(32G) and crashed. Without it just a few minutes and less than 10G mem is consumed.

Is something wrong with the usage of this method? is there any better solution to improve the performance? Thanks!","You can use multithreading in spacy to create a fast tokenization and data ingestion pipeline.

Rewriting your code block and functionality using the nlp.pipe method would look something like this:
This way puts all your filtering into the token_filter function, which takes in a spacy token and returns True only if it is not punctuation, a space, a stopword, and 4 or less characters. Then, you use this function as you pass through each token in each document, where it will return the lemma only if it meets all of those conditions. Then, filtered_tokens is a list of your tokenized documents.

Some helpful references for customizing this pipeline would be:

Token attributes
Language.pipe",multithreading solution,Multithreading in Spacy can create a faster pipeline for tokenization and data ingestion.,,1,C20230706014919007335,0.752247751,0.606659234,0.525653303,0.617815793,0.706770957,0.684612751,0.831916094,0.204149708,0.765733957,0.196594849,0.76901865,0.2088826,0.557792723,0.541915894,0.583162546,0.545728743,0.593542695,0.579482734,0.804008782,0.54228586,0.757092774,0.65274322,0.817393243,0.645122051,27multithreading solution
149,43,Spacy,Stability,backwards compatibility,Stability aspect,54201004,Multithreading with spacy: Is joblib necessary?,"In this part of the documentation, it is mentioned that nlp.pipe() works in parallel and the following example is given:

for doc in nlp.pipe(texts, batch_size=10000, n_threads=3):
    pass
After that, another, longer example is given that makes use of joblib. I don't quite understand the relationship between the two. As I understand the documentation, if I simply want to parallelize the tokenisation of many documents, the above, simple for loop will work and I do not have to use joblib, right?

My pipeline looks like this:

nlp = spacy.load('en', disable=['parser', 'ner', 'textcat'])
When would I need to use joblib?","Based on an answer in Spacy github issues:

We kept the n_threads argument to avoid breaking people's code, but unfortunately the implementation doesn't currently release the GIL, the way we did in v1. In v2 the neural network model is more complicated and more subject to change, so we haven't implemented it in Cython. We might at a later date.

In v2.1.0 (you can get an alpha by installing spacy-nightly, the matrix multiplications are now single-threaded. This makes it safe to launch multiple processes for the pipeline, so we can look at doing that internally. In the meantime, the n_threads argument sits idle...Which I agree is confusing, but removing it and breaking backwards compatibility seems worse.
Thus, to summarize: n_threads doesn't work in v2.1. What I'm doing now is using Spacy with joblib to read a dataset in minibatches.

Spacy released an example for that: Spacy Multiprocessing, and it works perfectly.

I have a dataset with almost ~4M short text. Without using the example they released, it took almost 23 hours to finish parsing them, but using joblib with spacy, it took 1 hour and half to finish!

To reference the readers of this question to Spacy Multiprocessing example: Spacy Multiprocessing",idle n_threads argument,"Despite the update, the n_threads argument remains idle and joblib is still necessary for efficient parallel processing.",,1,C20230706014953903432,0.647806287,0.542190135,0.372000217,0.378046989,0.614446104,0.497220933,0.420064837,0.718428731,0.577914059,0.778977215,0.669409335,0.8092978,0.588955164,0.522332788,0.478126049,0.368810236,0.528528094,0.375198156,0.71690768,0.674037933,0.588336766,0.74653703,0.78695631,0.702811778,43idle n_threads argument
337,99,Spacy,Feature,Rule-based matching,Rule-based matching feature,76011075,"Entity Ruler cannot recognize ""Frankfurt am Main"" as Geo-Political Entity (GPE)","I try to add a new rule in Named Entity Recognition so that Spacy will label the phrase ""Frankfurt am Main"" as GPE.

nlp = spacy.load(""en_core_web_sm"")
ruler = nlp.add_pipe(""entity_ruler"")
patterns = [{""label"": ""ORG"", ""pattern"": ""MyCorp Inc.""},{""label"": ""GPE"", ""pattern"": ""Frankfurt am Main""}]
ruler.add_patterns(patterns)
doc = nlp(""MyCorp Inc. is a company in Frankfurt am Main"")
print([(ent.text, ent.label_) for ent in doc.ents])
But Spacy still label the word ""Frankfurt"" as GPE instead of the whole phrase ""Frankfurt am Main"":

[('MyCorp Inc.', 'ORG'), ('Frankfurt', 'GPE')]
I want to know how I can adjust spacy so that it can label ""Frankfurt am Main"" as GPE.","Put the entity_ruler before ner so that its entity spans have priority over the ner entities.

nlp.add_pipe(""entity_ruler"", before=""ner"")
See: https://spacy.io/usage/rule-based-matching#entityruler-usage",entity ruler limitations,"The user encountered an issue where the Entity Ruler was unable to recognize 'Frankfurt am Main' as a GPE entity, indicating some limitations in the feature.",,1,C20230706015241507160,0.527737677,0.584527075,0.630089164,0.216082662,0.493143618,0.37466532,0.386195242,0.60730207,0.330194443,0.420022845,0.530315638,0.437255919,0.52875191,0.609936237,0.451156467,0.279873788,0.40584439,0.316352636,0.550756991,0.627407789,0.591108799,0.837186873,0.818590343,0.815472543,99entity ruler limitations
257,76,Spacy,Feature,dependency parsing,dependency parsing feature,55521858,"spacy noun-chunking creates unexpected lemma, pos, tag, and dep","I am using spacy to parse documents and unfortunately I am unable to process noun chunks the way I would have expected them to be processed. 

I expected a ""lemma"" would be the phrase ""the big dog"" with plural form changed to singular and the phrase would be ""pos"" of ""NOUN"", a ""tag"" of ""NNS"", and a ""dep"" of ""nsubj"".

Is this the correct behaviour, or am I using spacy incorrectly? If I am using spacy incorrectly, please let me know the correct manner in which to perform this task.","There are a few things to consider here

Lemmatisation is token based
POS tagging and dependency parsing is predictive
You probably will get the big dog if you take the lemma_ attribute for each token. It does not update the token pos of you use the attribute.

Also, since dependency parsing and POS tagging is trained in a predictive model, it is not guaranteed to always be ""right"" from a human linguistic perspective.

Other than the lemma issue, it seems you are using spacy correct",lemmatisation is token based,The lemma attribute for each token does not update the token pos. It is token based.,,1,C20230706015052945867,0.72378391,0.782112479,0.699036837,0.69275403,0.664635122,0.858483791,0.478438944,0.739123106,0.746164978,0.674872577,0.640587986,0.807991564,0.855371296,0.532755315,0.823383987,0.744934857,0.623017907,0.662873864,0.664521396,0.103571028,0.516953588,0.303419977,0.628118217,0.51958102,76lemmatisation is token based
178,51,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",recommendation for upgrade,The responder suggests upgrading to a more recent version of Spacy as models are more transparently hosted on GitHub and easier to manage.,,1,C20230706015009016356,0.427082866,0.570011616,0.803951502,0.712267518,0.62594229,0.595196307,0.660201013,0.627777874,0.587073624,0.508745313,0.52655077,0.842570722,0.588419795,0.544752181,0.496106565,0.642129302,0.578150749,0.640268326,0.61691463,0.50937283,0.505090237,0.710540652,0.613319516,0.573747098,51recommendation for upgrade
159,45,Spacy,Stability,backwards,Stability aspect,66503956,"spaCy 3.0, installed files are different from the files in github repo","I installed spaCy 3.0 on my ubuntu. I use ctrl+B to find the definition of class ""sentencizer"" which is in sentencizer.py file:
Why there is no content in the functions defined in sentencizer.py. In the spaCy github repo, there is no sentencizer.py file and the class ""sentencizer"" is defined in sentencizer.pyx:
Why the installed files are different from the github repo? Thanks!","When developing a Python library, small changes are saved in Git as they're made, but they're only released to PyPI when the maintainer intentionally makes a release. So it's normal for the files on your computer to be a little different from the files in a git repo, even if you have a very recent release.

I was really confused about the sentencizer.py code you posted, since there doesn't seem to have ever been a file with that name in spaCy, but it looks like that is a magic PyCharm feature - it's not showing you the actual source code, it's doing some sort of decompilation.

You noticed spaCy has the sentencizer.pyx file. That's compiled into a binary .so file that Python runs when you use the code. PyCharm is presumably working backwards from the .so file.",pycharm decompilation feature,The code identified by the user as being in the file 'sentencizer.py' is not the actual source code - it seems to be a result of the PyCharm decompilation feature.,,1,C20230706014957696750,0.624705732,0.773163438,0.769612968,0.663534641,0.793563247,0.687141061,0.537328541,0.69642669,0.461706221,0.716632903,0.720958889,0.545178115,0.46975109,0.614472926,0.573733389,0.53517586,0.46146363,0.612248063,0.675350189,0.591086268,0.470221102,0.689447165,0.62896806,0.669951558,45pycharm decompilation feature
6,2,Spacy,Ease of use,easy,Ease of use aspect,56694713,In spaCy is there a way to extract the sentence the entity has been extracted from?,"considering the following sentence:

""the quick brown fox jumps over the lazy dog""
and if I want to extract brown, extracting only brown is fairly easy to do however I want the following output:

""brown"" , ""the quick brown fox jumps over the lazy dog""","Yes, there is a way to do this in Spacy. You have to iterate over the entity Span objects and extract the sentence from each Span object. Here is an example:

    doc = nlp(""John and Claire live in London. They have a dog. Claire walks her 
    dog everyday."")
    for entity in doc.ents:
       print('Entity extracted : ', entity.text)
       print('Sentence extracted from : ', entity.sent)",requires programming skills,Using Spacy for sentence and entity extraction requires expertise in coding.,Question not focused on main topic,0,C20230706014105602836,0.708297193,0.756207407,0.621955097,0.82195127,0.860407531,0.791625321,0.624661565,0.83947444,0.709662199,0.67776525,0.736098766,0.836061597,0.572481275,0.841643095,0.744704664,0.618464112,0.908716559,0.617863178,0.622668445,0.831060648,0.787595451,0.623247802,0.688455164,0.750671625,2requires programming skills
265,77,Spacy,Feature,dependency parsing,dependency parsing feature,43397502,Rule-based matcher of entities with spacy,"I want to use the python library spacy for matching tokens in a text (adding a labels as a semantic reference). Then, I want to use the matches to extract relations between the tokens. My first was to make use of the matcher.add and matcher.add_pattern of spacy. The matcher.add is working fine and I can find tokens, my code until now:

I have tried in different ways to make this works but is obviously not, I guess there is something wrong with my understanding of matcher.add_pattern.

Can some please put me in the right direction how to do this with spacy?
Is it possible to add regex here to find patterns, how?
How can I add more than one token with the same label, or somehow create a list of tokens for the same label, eg. ""FINANCE""?
I will appreciate any comments.","Your matcher would identify the tokens, but to find relations between them you will have to do dependency parsing. Here is visual example from spacy :
You can then traverse the tree to find relations between the tokens. https://spacy.io/docs/usage/dependency-parse#navigating

The dep (enum) and dep_ (verbose name) attribute of each token would give you the relationships with its child",traversing the dependency tree,The user can traverse the tree to find relations between tokens.,,1,C20230706015055909051,0.684070528,0.706993163,0.854050517,0.784090936,0.818632782,0.76526159,0.592053413,0.54528445,0.544769883,0.860941589,0.579735458,0.5730533,0.62315166,0.479209393,0.55604732,0.617453337,0.610637665,0.671643317,0.554865658,0.60664773,0.357055813,0.629982173,0.617550552,0.479732603,77traversing the dependency tree
144,41,Spacy,Stability,bug,Stability aspect,68559878,Force 'parser' to not segment sentences?,"Is there an easy way to tell the ""parser"" pipe not to change the value of Token.is_sent_start ?

So, here is the story: I am working with documents that are pre-sentencized (1 line = 1 sentence), this segmentation is all I need. I realized the parser's segmentation is not always the same as in my documents, so I don't want to rely on the segmentation made by it.

I can't change the segmentation after the parser has done it, so I cannot correct it when it makes mistakes (you get an error). And if I segment the text myself and then apply the parser, it overrules the segmentation I've just made, so it doesn't work.

So, to force keeping the original segmentation and still use a pretrained transformer model (fr_dep_news_trf), I either :

disable the parser,
add a custom Pipe to nlp to set Token.is_sent_start how I want,
create the Doc with nlp(""an example"")
or, I simply create a Doc with

doc = Doc(words=[""an"", ""example""], sent_starts=[True, False])
and then I apply every element of the pipeline except the parser.

However, if I still do need the parser at some point (which I do, because I need to know some subtrees), If I simply apply it on my Doc, it overrules the segmentation already in place, so, in some cases, the segmentation is incorrect. So I do the following workaround:

Keep the correct segmentation in a list sentences = list(doc.sents)
Apply the parser on the doc
Work with whatever syntactic information the parser computed
Retrieve whatever sentencial information I need from the list I previously made, as I now cannot trust Token.is_sent_start.
It works, but it doesn't really feel right imho, it feels a bit messy. Is there an easier, cleaner way I missed ?

Something else I am considering is setting a custom extension, so that I would, for instance, use Token._.is_sent_start instead of the default Token.is_sent_start, and a custom Doc._.sents, but I fear it might be more confusing than helpful ...

Some user suggested using span.merge() for a pretty similar topic, but the function doesn't seem to exist in recent releases of spaCy (Preventing spaCy splitting paragraph numbers into sentences)","The parser is supposed to respect sentence boundaries if they are set in advance. There is one outstanding bug where this doesn't happen, but that was only in the case where some tokens had their sentence boundaries left unset.

If you set all the token boundaries to True or False (not None) and then run the parser, does it overwrite your values? If so it'd be great to have a specific example of that, because that sounds like a bug.

Given that, if you use a custom component to set your true sentence boundaries before the parser, it should work.

Regarding some of your other points...

I don't think it makes any sense to keep your sentence boundaries separate from the parser's - if you do that you can end up with subtrees that span multiple sentences, which will just be weird and unhelpful.

You didn't mention this in your question, but is treating each sentence/line as a separate doc an option? (It's not clear if you're combining multiple lines and the sentence boundaries are wrong, or if you're passing in a single line but it's turning into multiple sentences.)

Thanks a million for you answer! It made me go back to my documents and check every output of every element in the pipeline... Well, I feel terribly stupid, but I simply cannot reproduce my observation of a ""deffective parser"", everything seems fine now. I guess after my initial struggle with forcing my own sentence boundaries (which wasn't even actually that complicated ...), I convinced myself somehow it wasn't working even after my own boundaries were set ? Or I fixed something else in my code ? Terribly sorry. I'll keep an eye on it, might post here again if I find a mistake again",user's issue resolved,"The user's issue with the parser seems to have been resolved, possibly due to some error or misunderstanding.",,1,C20230706014946913242,0.796920419,0.507166445,0.641745508,0.484400243,0.468451649,0.577281177,0.768461704,0.728018403,0.700001419,0.945595384,0.726258457,0.714737833,0.499412894,0.443756372,0.583953023,0.338526219,0.464129835,0.444179982,0.523600042,0.503126025,0.545609474,0.891355038,0.715597987,0.749675214,41user's issue resolved
199,58,Spacy,Active Maintenance,github,Active Maintenance aspect,53728770,Cannot install es_core_news_sm from Spacy,"When I try to install es_core_news_sm with this commmand

python -m spacy download es_core_news_sm
with conda I get this error

No module name spacy._main_;'spacy'is a package and cannot be directly executed. 
Thank you so much!","This could happen if conda installed an older version of spaCy. See the following issue on spaCy's github.

The fix as stated in the issue is as follows:

Find the most recent version of spaCy on conda:conda search -f spacy
Then run: conda install spacy=NEWEST_VERSION
The newest version of spaCy on Conda is 2.0.18",fix provided,The answer provides a solution to the compatibility issue by suggesting a fix to install the most recent version of spaCy on conda.,,1,C20230706015020249953,0.618508458,0.800489783,0.627354503,0.662814617,0.616120934,0.419931412,0.872654676,0.705631852,0.778782427,0.635604203,0.723236084,0.762879312,0.693025053,0.680831194,0.155738294,0.480382204,0.467846781,0.204259336,0.914870441,0.768447936,0.733665049,0.788187742,0.701355577,0.677924514,58fix provided
49,14,Spacy,Documentation,documentation,Documentation aspect,57206701,Spacy tokenizer rule for exceptions that contain whitespace?,"When I create a pipeline with the default tokenizer for say English, I can then call the method for adding a special case:

tokenizer.add_special_case(""don't"", case)
The tokenizer will happily accept a special case that contains whitespace:

tokenizer.add_special_case(""some odd case"", case)
but it appears that does not actually change the behavior of the tokenizer or will never match?

More generally, what is the best way of extending an existing tokenizer so that the some patterns which normally would result in multiple tokens only create one token? For example something like [A-Za-z]+\([A-Za-z0-9]+\)[A-Za-z]+ should not result in three tokens because of the parentheses but in a single token, e.g. for asdf(a33b)xyz while the normal English rules should still apply if that pattern does not match.

Is this something that can be done somehow by augmenting an existing tokenizer or would I have to first tokenize, then find entities that match the corresponding token patterns and then merge the entity tokens?","As you found, Tokenizer.add_special_case() doesn't work for handling tokens that contain whitespace. That's for adding strings like ""o'clock"" and "":-)"", or expanding e.g. ""don't"" to ""do not"".

Modifying the prefix, suffix and infix rules (either by setting them on an existing tokenizer or creating a new tokenizer with custom parameters) also doesn't work since those are applied after whitespace splitting.

To override the whitespace splitting behavior, you have four options:

Merge after tokenization. You use Retokenizer.merge(), or possibly merge_entities or merge_noun_chunks. The relevant documentation is here: https://spacy.io/usage/linguistic-features#retokenization and https://spacy.io/api/pipeline-functions#merge_entities and https://spacy.io/api/pipeline-functions#merge_noun_chunks

This is your best bet for keeping as much of the default behavior as possible.
Subclass Tokenizer and override __call__. Sample code:

Implement a completely new tokenizer (without subclassing Tokenizer). Relevant docs here: https://spacy.io/usage/linguistic-features#custom-tokenizer-example
Tokenize externally and instantiate Doc with words. Relevant docs here: https://spacy.io/usage/linguistic-features#own-annotations
To answer the second part of your question, if you don't need to change whitespace splitting behavior, you have two other options:

Add to the default prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizer-additions

Note from https://stackoverflow.com/a/58112065/594211: ""You can add new patterns without defining a custom tokenizer, but there's no way to remove a pattern without defining a custom tokenizer.""
Instantiate Tokenizer with custom prefix, suffix and infix rules. The relevant documentation is here: https://spacy.io/usage/linguistic-features#native-tokenizers

To get the default rules, you read the existing tokenizer's attributes (as shown above) or use the nlp object‚Äö√Ñ√∂‚àö√ë‚àö¬•s Defaults. There are code samples for the latter approach in https://stackoverflow.com/a/47502839/594211 and https://stackoverflow.com/a/58112065/594211.",rules modification limitation,"Modifying the prefix, suffix and infix rules doesn't work since those are applied after whitespace splitting.",,1,C20230706014424847126,0.664637268,0.74443692,0.599102199,0.537713468,0.667048633,0.374693781,0.804540098,0.745495677,0.443073332,0.835932374,0.511285305,0.514753759,0.662036777,0.735784829,0.599427104,0.550991833,0.593257189,0.574417591,0.620800376,0.663392782,0.466069609,0.927747726,0.792514443,0.833102524,14rules modification limitation
195,57,Spacy,Active Maintenance,github,Active Maintenance aspect,46765198,Unable to load spacy English model - 'WindowsPath' object has no attribute 'read',"I installed spacy using pip and then downloaded the English model using  
$ python -m spacy download en which after downloading gave me the message

You can now load the model via spacy.load('en')
I have the English model files(en_core_web_sm) downloaded to the working directory, am I missing something? Do I need to set a path variable? Any help is much appreciated, thanks!",If anybody else receives this error : I opened this as an issue with spaCy's developers on Github. I was suggested using Python 3.6 instead of 2.7 for the moment as there is no alternate workaround to the problem. The next spaCy version should cover this bugfix (I'm told).,bug fixing,"The developers are currently working on a fix for the bug, indicating that the library is being actively maintained and updated.",,1,C20230706015018716211,0.697217703,0.823271751,0.661343813,0.554875255,0.645527899,0.909974098,0.845282197,0.797792971,0.697486162,0.718049109,0.733725667,0.792743802,0.624668181,0.702877164,0.754397452,0.417958617,0.480692834,0.820022881,0.738783538,0.876738667,0.759969354,0.829878688,0.677688301,0.77337271,57bug fixing
2,1,Spacy,Ease of use,simple,Ease of use aspect,62766608,Is there a simple way to get the position of a token in sequence with spacy?,"I want to the start index and the end index of every token in a sequence. Is there a simple way to do that with spacy?
","import spacy

text = 'Brown is a nice guy'
nlp = spacy.load(""en_core_web_sm"")
doc = nlp(text)

for token in doc:
  print(token.text, token.idx, token.idx + len(token.text) - 1)",spacy handles parsing,"Spacy's ability to automatically parse natural language text allows users to focus on specific tasks and analyses, rather than worrying about the underlying processing and parsing mechanisms.",,1,C20230706014105098675,0.696406722,0.49848786,0.556618631,0.829528809,0.786726892,0.795596838,0.74339962,0.71621418,0.673414052,0.759407461,0.766501069,0.754762352,0.558145821,0.446402878,0.73976934,0.58165282,0.606874347,0.716373026,0.501362205,0.705996811,0.59100616,0.465305269,0.445743769,0.635744691,1spacy handles parsing
217,65,GSON,Security,Security,Security aspect,4981101,Gson Security concerns,I plan to use Gson (http://code.google.com/p/google-gson/) on my server and transfer JavaScript objects from the browser to Java objects on the server. I will use Ajax to POST the request. I am a little concerned that everybody will be able to post Java objects to my server VM. A Java object that runs in the server process will have the potential to do whatever it wants. How does Gson address that?,"gson/json is data only, not code. So noone can post code to your server, just data.

When you're deserializing json, you specify which class (or you just extract primitives or collections of primitives directly) to populate with data - noone can send you json that aribtarly instantiate any of your classes living on the server.",deserialization process,"The Gson deserialization process requires the specification of classes or extraction of primitives or collections of primitives. As such, it is not possible for anyone to send arbitrary data that could instantiate any of the classes living in the server.",,1,C20230706015031256736,0.712440431,0.678792655,0.606141508,0.806924939,0.582028389,0.611942172,0.861114025,0.864810824,0.782459199,0.939988971,0.841044664,0.896776497,0.72642678,0.713717818,0.666711509,0.950753272,0.861687005,0.839440465,0.627960563,0.731427193,0.736130774,0.777103066,0.88958168,0.76675725,65deserialization process
69,20,Spacy,Performance,performance,Performance aspect,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",kb performance issue,Descriptions not stored in KB due to performance.,,1,C20230706014830664743,0.66663295,0.749299526,0.79783088,0.730447114,0.621295035,0.552856088,0.513173282,0.675216496,0.549294293,0.693039834,0.513145149,0.494271398,0.735870421,0.683862984,0.536147475,0.715422332,0.566655576,0.584241986,0.537160873,0.662866592,0.68466419,0.785085022,0.726956367,0.835380316,20kb performance issue
19,6,Spacy,Ease of use,difficult,Ease of use aspect,48980120,Is it possible to parse emojis using spaCy?,"Is it possible to tokenize emojis like :), :(, ;~( properly using the spaCy Python library? e.g. If I run the following code:

import spacy

nlp = spacy.load('en')
doc = nlp(""Hello bright world :)"")
And then visualize the doc with displaCy:
It incorrectly parses world :) as one token. How can I modify spaCy so it recognizes these additional symbols? Thanks.

edit: Found the following: https://github.com/ines/spacymoji but I think it only supports Unicode emojis like ‚Äö√Ñ√∂‚àö‚à´¬¨√Ü and not ASCII ones like :)","Yes, spaCy actually includes a pretty comprehensive list of text-based emoticons as part of its tokenizer exceptions. So using your example above and printing the individual tokens, the emoticon is tokenized correctly:

doc = nlp(""Hello bright world :)"")
print([token.text for token in doc])
# ['Hello', 'bright', 'world', ':)']
I think what happens here is that you actually came across an interesting (maybe non-ideal) edge case with the displacy defaults. To avoid very long dependency arcs for punctuation, the collapse_punct setting defaults to True. This means that when the visualisation is rendered, punctuation is merged onto the preceding token. Punctuation is identified by checking whether the token's is_punct attribute returns True ‚Äö√Ñ√∂‚àö√ë‚àö¬® which also happens to be the case for "":)"".

In your example, you can work around this by setting collapse_punct to False in the options passed to displacy.serve:

displacy.serve(doc, style='dep', options={'collapse_punct': False})
(The displaCy visualizer should probably include an exception for emoticons when merging punctuation. This is currently difficult, because spaCy doesn't have an is_emoji or is_symbol flag. However, it might be a nice addition in the future ‚Äö√Ñ√∂‚àö√ë‚àö¬® you can vote for it on this thread.)",limitations of spacy emoji support,GitHub repository for spaCy emojis only currently supports Unicode emojis and not ASCII ones.,Question not focused on main topic,1,C20230706014337758480,0.649310052,0.874073565,0.617383063,0.60693723,0.746152222,0.627296567,0.855977178,0.800037026,0.775022864,0.73435986,0.851412535,0.699054062,0.71287936,0.590478539,0.702947199,0.490476638,0.558080196,0.465664685,0.496723622,0.702093661,0.626479089,0.592962801,0.640685976,0.830593824,6limitations of spacy emoji support
297,88,Spacy,Feature,Entity linking,Entity linking feature,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?

import spacy
nlp = spacy.load(r""D:\el model\nlp"")
doc = nlp(""Amir Khan is a great boxer"")
ents = [(e.text, e.label_, e.kb_id_) for e in doc.ents]
print(ents) ","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",file for entity descriptions,Spacy generates an intermediary result during processing which includes a file entity_descriptions.csv. This file maps the WikiData ID to its corresponding description in a simple tabular format.,,1,C20230706015220316530,0.665618598,0.610018134,0.705514491,0.638226151,0.590583563,0.686094105,0.469583869,0.793940663,0.760259509,0.666051447,0.622138321,0.72587961,0.615806103,0.592210293,0.625361741,0.596667469,0.530909419,0.540119708,0.608519912,0.870064795,0.729148448,0.649182498,0.461543858,0.729635537,88file for entity descriptions
312,91,Spacy,Feature,Entity linking,Entity linking feature,60809394,Can spaCy link only named entities?,"I'd would like to extract important entities and link them to Wikipedia entities. I've trained spaCy on a small sample of Wikipedia/WikiData and run entity linking on the review:

[('Tofu', 'PERSON', 'Q177378'), 
('Nyquil', 'WORK_OF_ART', 'NIL')]
I'd like other entities to be extracted and linked as well, e.g.:

kimchi -> Kimchi
cold -> Common cold
healing -> medicine 
medically -> medicine
It looks like spaCy can link only named entities. I've tried to explicitly list other entities as named (which obviously does not scale well):

ruler = EntityRuler(nlp)
patterns = [{""label"": ""ORG"", ""pattern"": ""kimchi""}, {""label"": ""ORG"", ""pattern"": ""cold""}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, spaCy does not seem to link new entities at all:

[ ('Tofu', 'PERSON', 'Q177378'),
  ('cold', 'ORG', ''),
  ('Nyquil', 'WORK_OF_ART', 'NIL'),
  ('kimchi', 'ORG', '')]
How can I make Spacy recognize also other entities?
Should this be done before training entity linking model or can be done with already trained model?
Is spaCy the right tool for my task at all?","In theory it's possible. First, you'll need to make sure you have a component that tags these kind of entities. You could train an NER model for this, but be aware that its performance might not be as good on things like ""cold"" than it would be for actual named entities like ""London"".

To create the Knowledge Base and the Entity Linker from Wikipedia/Wikidata, the example scripts are not limited to named entities - they attempt to parse anything that appears in an intra-wiki link. If the word ""cold"" gets linked to the page ""Common cold"", it should be able to learn it. The exact entities that are stored in the KB and that are used for training the EL model, depend on which entities are found by your entity recognizer component. So if you adjust that according to your use-case, the entity linking component will follow automatically.",training needed,An NER model needs to be trained to identify other important entities.,,0,C20230706015226609389,0.746951818,0.741615415,0.632373631,0.920855343,0.812452972,0.849401176,0.772124827,0.809224606,0.693224907,0.849736869,0.790052593,0.780448794,0.589679837,0.386634171,0.599156141,0.354433507,0.66303283,0.370824844,0.540228724,0.613240778,0.510376692,0.736444056,0.756365836,0.685034215,91training needed
269,79,Spacy,Feature,dependency parsing,dependency parsing feature,55498881,Vectorized form of cleaning function for NLP,"I made the following function to clean the text notes of my dataset :
Problem is when I want to clean all my dataset text, it take hour and hour. (my dataset is 70k row and between 100 to 5000 words per row)

I tried to use swifter to run the apply method on multiplethread like that : data.note_line_comment.swifter.apply(clean)

But it doesn't made really better as it took almost one hour.

I was wondering if there is any way to make a vectorized form of my function or maybe and other way to speed up the process. Any idea ?","Short answer

This type of problem inherently takes time.

Long answer

Use regular expressions
Change the spacy pipeline
The more information about the strings you need to make a decision, the longer it will take.

Good news is, if your cleaning of the text is relatively simplified, a few regular expressions might do the trick.

Otherwise you are using the spacy pipeline to help remove bits of text which is costly since it does many things by default:

Tokenisation
Lemmatisation
Dependency parsing
NER
Chunking
Alternatively, you can try your task again and turn off the aspects of the spacy pipeline you don't want which may speed it up quite a bit.

For example, maybe turn off named entity recognition, tagging and dependency parsing...

nlp = spacy.load(""en"", disable=[""parser"", ""tagger"", ""ner""])
Then try again, it will speed up.",dependency parsing bottleneck,"Dependency parsing is one of the default features of Spacy pipeline, which can slow down the processing time for certain tasks.",,1,C20230706015100617801,0.552201033,0.398188561,0.544465601,0.79495126,0.674983382,0.734317422,0.820492029,0.723938167,0.655453742,0.882627249,0.789601982,0.670546055,0.569201827,0.478036135,0.752757907,0.615423262,0.650433898,0.557168007,0.72769779,0.697061598,0.691520393,0.85169822,0.834100485,0.764105678,79dependency parsing bottleneck
201,59,Spacy,Active Maintenance,github,Active Maintenance aspect,61943409,Spacy's BERT model doesn't learn,"I've been trying to use spaCy's pretrained BERT model de_trf_bertbasecased_lg to increase accuracy in my classification project. I used to build a model from scratch using de_core_news_sm and everything worked fine: I had an accuracy around 70%. But now I am using BERT pretrained model instead and I'm getting 0% accuracy. I don't believe that it's working so bad, so I'm assuming that there is just a problem with my code. I might have missed something important but I can't figure out what. I used the code in this article as an example.

Function get_data() opens files with different categories, creates a tuple like this one (text, {'cats' : {'category1': 0, 'category2':1, ...}}), gathers all these tuples into one array, which is then being returned to the main function.

Function test(nlp) opens the file with test data, predicts categories for each line in the file and checks, whether the prediction was correct.

Again, everything worked just fine with de_core_news_sm, so I'm pretty sure that functions get_data() and test(nlp) are working fine. Code above looks like in example but still 0% accuracy.I don't understand what I'm doing wrong.","Received an answer to my question on GitHub and it looks like there must be some optimizer parameters specified, just like in this example.",multiple models available,"The existence of multiple models available for use in Spacy, including pre-trained ones like BERT, indicates that the development of the library is ongoing and continually improving.",,0,C20230706015021297922,0.657644331,0.487796754,0.467241228,0.754872501,0.548440039,0.587501407,0.9424721,0.876983106,0.812574506,0.839693367,0.833545983,0.79424417,0.523284733,0.51445061,0.757341862,0.540151596,0.44854179,0.523983121,0.730966926,0.206578419,0.363514572,0.335664541,0.477769762,0.538818061,59multiple models available
274,80,Spacy,Feature,Lemmatization,Lemmatization feature,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.

class SpacyLemmatizer(object):
    def __init__(self, smodel):
        import spacy
        self.lemmatizer = spacy.load(smodel).vocab.morphology.lemmatizer

    # get the lemmas for every upos
    def getLemmas(self, entry):
        possible_lemmas = set()
        for upos in ('NOUN', 'VERB', 'ADJ', 'ADV'):
            lemmas = self.lemmatizer(entry, upos, morphology=None)
            lemma = lemmas[0]    # See morphology.pyx::lemmatize
            possible_lemmas.add( lemma )
        return possible_lemmas",modifying code to get correct upos,The code can be modified to pass in the correct upos for a specific word and receive the correct lemma.,,1,C20230706015135009886,0.451060236,0.727791011,0.720204055,0.663904548,0.851378143,0.763862312,0.685689032,0.845011532,0.785190225,0.753433287,0.558662713,0.80039078,0.522853315,0.726302624,0.658018768,0.443892449,0.590372622,0.583920777,0.722804248,0.813095987,0.731293142,0.759530127,0.706289411,0.68010956,80modifying code to get correct upos
181,52,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,55852115,Token extension versus matcher versus phrase matcher vs entity ruler in spaCy,"I am trying to figure out the best way (fast) to extract entities, e.g. a month. I have come up with 5 different approaches using spaCy.

Initial setup

For each solution I start with an initial setup
Conclusion

The custom attributes with is limited to single token matching and the token matcher seems to be faster so that seems to be preferable. The EntityRuler seems to be the slowest which isn't surprising since it is changing the Doc.ents. It is however quite convenient that you have your matches in Doc.ents so you might want to consider this method still.

I was quite surprised that the token matcher outperforms the phrase matcher. I thought it would be opposite:

If you need to match large terminology lists, you can also use the PhraseMatcher and create Doc objects instead of token patterns, which is much more efficient overall
Question

Am I missing something important here or can I trust this analysis on a larger scale?","I think ultimately, it all comes down to finding the optimal tradeoff between speed, maintainability of the code and the way this piece of logic fits into the larger picture of your application. Finding a few strings in a text is unlikely to be the end goal of what you're trying to do ‚Äö√Ñ√∂‚àö√ë‚àö¬® otherwise, you probably wouldn't be using spaCy and would stick to regular expressions. How your application needs to ""consume"" the result of the matching and what the matches mean in the larger context should motivate the approach you choose.

As you mention in the conclusion, if your matches are ""named entities"" by definition, adding them to the doc.ents makes a lot of sense and will even give you an easy way to combine your logic with statistical predictions. Even if it adds slightly more overhead, it'll likely still outperform any scaffolding you'd otherwise have to write around it yourself.",continued development,The longevity and maintenance of the Spacy library will depend on continued engagement and support from its developers and users.,,0,C20230706015011149537,0.805416822,0.618878722,0.711947083,0.816940784,0.54786849,0.538399637,0.712089598,0.599199176,0.687511444,0.820653737,0.723726749,0.638370275,0.550925672,0.687324822,0.834219158,0.596778333,0.568243206,0.462441087,0.532482624,0.593154907,0.5704723,0.715794623,0.348977864,0.376073182,52continued development
85,24,Spacy,Performance,performance,Performance aspect,66433304,spacy- why nlp() works for single string while nlp.pipe() works fine for a list of strings?,"I recently ran into a strange behavior while using spacy, which is when I process string,

in case the string is a single string object, I have to use nlp(string),

while I have to use nlp.pipe(a list) for a list made of strings elements.
Why is this? I assume this must be something to do with nlp.pipe() behavior which is generator.

What is the reason?","Spacy does this because generators are more efficient. Since generators are consumed only once they are more memory efficient than a list.

According to their documentation instead of processing texts one-by-one and applying nlp pipeline it processes texts in batches.

Furthermore, you can configure batch size in nlp.pipe to optimize performance according to your system

Process the texts as a stream using nlp.pipe and buffer them in batches, instead of one-by-one. This is usually much more efficient.
If your goal is to process large streams of data using nlp.pipe it would be much more efficient to write a streamer/generator to produce results as you need them from database/filesystem than loading everything in memory and then processing them one by one.",streamlining data processing,Writing a streamer or generator to produce results as needed is recommended for efficient processing of large streams of data.,Too large question and answer,1,C20230706014913850593,0.657297134,0.692813754,0.536671579,0.882469475,0.870166719,0.856482089,0.680712163,0.754980862,0.618054867,0.928905606,0.816081524,0.826081991,0.583704889,0.76581347,0.668868721,0.51091224,0.921064734,0.532430649,0.687780559,0.336564988,0.6060794,0.383086622,0.89117974,0.3585127,24streamlining data processing
158,45,Spacy,Stability,backwards,Stability aspect,66503956,"spaCy 3.0, installed files are different from the files in github repo","I installed spaCy 3.0 on my ubuntu. I use ctrl+B to find the definition of class ""sentencizer"" which is in sentencizer.py file:
Why there is no content in the functions defined in sentencizer.py. In the spaCy github repo, there is no sentencizer.py file and the class ""sentencizer"" is defined in sentencizer.pyx:
Why the installed files are different from the github repo? Thanks!","When developing a Python library, small changes are saved in Git as they're made, but they're only released to PyPI when the maintainer intentionally makes a release. So it's normal for the files on your computer to be a little different from the files in a git repo, even if you have a very recent release.

I was really confused about the sentencizer.py code you posted, since there doesn't seem to have ever been a file with that name in spaCy, but it looks like that is a magic PyCharm feature - it's not showing you the actual source code, it's doing some sort of decompilation.

You noticed spaCy has the sentencizer.pyx file. That's compiled into a binary .so file that Python runs when you use the code. PyCharm is presumably working backwards from the .so file.",normal git workflow,"Small changes are saved in Git as they're made, but they're only released to PyPI when the maintainer intentionally makes a release.",,1,C20230706014957222120,0.629294097,0.660119414,0.849380195,0.541318238,0.506685853,0.254855186,0.395382911,0.885006547,0.412274152,0.457495779,0.503303111,0.405996293,0.504422665,0.515180409,0.617242873,0.553004444,0.462861747,0.329090327,0.616687536,0.516108513,0.518119335,0.761084199,0.480389506,0.247220069,45normal git workflow
234,70,Spacy,Feature,tokenization,tokenization feature,50908667,Tokenization not working the same for both case.,"I have a document

doc = nlp('x-xxmessage-id:')
When I want to extract the tokens of this one I get 'x', 'xx', 'message' and 'id', ':'. Everything goes well. Then I create a new document

test_doc = nlp('id')
If I try to extract the tokens of test_doc, I will get 'i' and 'd'. Is there any way to get past this problem? Because I want to get the same token as above and this is creating problems in the text processing.","Just like language itself, tokenization is context-dependent and the language-specific data defines rules that tell spaCy how to split the text based on the surrounding characters. spaCy's defaults are also optimised for general-purpose text, like news text, web texts and other modern writing.

In your example, you've come across an interesting case: the abstract string ""x-xxmessage-id:"" is split on punctuation, while the isolated lowercase string ""id"" is split into ""i"" and ""d"", because in written text, it's most commonly an alternate spelling of ""I'd"" or ""i'd"" (""I could"", ""I would"" etc.). You can find the respective rules here.

If you're dealing with specific texts that are substantially different from regular natural language texts, you usually want to customise the tokenization rules or possibly even add a Language subclass for your own custom ""dialect"". If there's a fixed number of cases you want to tokenize differently that can be expressed by rules, another option would be to add a component to your pipeline that merges the split tokens back together.

Finally, you could also try using the language-independent xx / MultiLanguage class instead. It still includes very basic tokenization rules, like splitting on punctuation, but none of the rules specific to the English language.

from spacy.lang.xx import MultiLanguage
nlp = MultiLanguage()",customizing tokenization rules,"For specific cases, tokenization rules can be customized to provide accurate results.",,1,C20230706015039640525,0.768245339,0.673641682,0.549301803,0.652230978,0.690865874,0.910797179,0.765892267,0.784480631,0.647523463,0.840679526,0.681886673,0.756235123,0.570448518,0.681999445,0.670880258,0.412716269,0.442554027,0.926019669,0.699429154,0.714883208,0.687658727,0.815079093,0.856605351,0.869426429,70customizing tokenization rules
23,7,Spacy,Ease of use,easy,Ease of use aspect,55087101,How to get all noun phrases in Spacy(Python),"I would like to extract ""all"" the noun phrases from a sentence. I'm wondering how I can do it. I have the following code:","Spacy clearly defines a noun chunk as:

A base noun phrase, or ""NP chunk"", is a noun phrase that does not permit other NPs to be nested within it ‚Äö√Ñ√∂‚àö√ë‚àö¬® so no NP-level coordination, no prepositional phrases, and no relative clauses."" (https://spacy.io/api/doc#noun_chunks)
If you process the dependency parse differently, allowing prepositional modifiers and nested phrases/chunks, then you can end up with what you're looking for.

I bet you could modify the existing spacy code fairly easily to do what you want:

https://github.com/explosion/spaCy/blob/06c6dc6fbcb8fbb78a61a2e42c1b782974bd43bd/spacy/lang/en/syntax_iterators.py",modifying dependency parse to extract noun phrases,Modifying the dependency parse will allow prepositional modifiers and nested phrases to be extracted as noun phrases.,wrong labeling,1,C20230706014338848778,0.746754885,0.80498296,0.829118371,0.869953871,0.859740734,0.929810882,0.782993078,0.800270498,0.724188507,0.809484184,0.748132229,0.855069935,0.640315354,0.757187605,0.693559527,0.93839097,0.924798071,0.975644588,0.736148655,0.870094836,0.714103758,0.802227616,0.847893655,0.824535429,7modifying dependency parse to extract noun phrases
323,95,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,57779549,Converting Spacy generated dependency into CoNLL format cannot handle more than one ROOT?,"I used the SpaCy library to generate dependencies and save it into a CoNLL format using the code below.

This works, but there are some sentences in my dataset that get splits into two by Spacy because they have two ROOTS. This results in having two fields for one sentence in the CoNLL format.

Example: A random sentence from my dataset is : ""teanna trump probably cleaner twitter hoe but""

Is there a way to save it all in one field instead of two even though it has two ROOTS so that 'but' becomes 7th item in field number 1? Which means it would look like this instead","I'd recommend using (or adapting) the textacy CoNLL exporter to get the right format, see: How to generate .conllu from a Doc object?

Spacy's parser is doing sentence segmentation and you're iterating over doc.sents, so you'll see each sentence it exported separately. If you want to provide your own sentence segmentation, you can do that with a custom component, e.g.:

def set_custom_boundaries(doc):
    for token in doc[:-1]:
        if token.text == ""..."":
            doc[token.i+1].is_sent_start = True
    return doc

nlp.add_pipe(set_custom_boundaries, before=""parser"")
Details (especially about how to handle None vs. False vs. True): https://spacy.io/usage/linguistic-features#sbd-custom

Spacy's default models aren't trained on twitter-like text, the parser probably won't perform well with respect to sentence boundaries here.

(Please ask unrelated questions as separate questions, and also take a look at spacy's docs: https://spacy.io/usage/linguistic-features#special-cases)",limitations of spacy's sentence segmentation,"Spacy's parser may not perform well with respect to sentence boundaries in certain types of text, such as Twitter-like text.",,1,C20230706015233599059,0.706069171,0.791821063,0.629715443,0.806212246,0.602725923,0.746691048,0.571689606,0.8310799,0.808055401,0.758292317,0.73508954,0.942808628,0.645851552,0.681602836,0.607652843,0.473999798,0.442481518,0.825249851,0.723748684,0.930483043,0.720758498,0.736894608,0.860980392,0.736326635,95limitations of spacy's sentence segmentation
26,8,Spacy,Ease of use,complex,Ease of use aspect,65850018,processing text with spacy nlp.pipe,"I'm procerssing 40,000 abstracts with spacy nlp.pipe using the code below and its taking 8 mins. Is there a way to speed this up further? I've also disabled ner.","Try tuning batch_size and n_process params :
Note as well, by joining on "" "" you may have some surprises, as spaCy's splitting rules are a bit more complex than that.",parameter tuning,Performance can be improved with tuning batch_size and n_process.,,1,C20230706014340466081,0.696931183,0.61309737,0.530593336,0.713974416,0.448519558,0.365855098,0.588122308,0.637167454,0.622273564,0.709883869,0.743664682,0.872279882,0.607351601,0.60696584,0.507942975,0.513835669,0.36523205,0.238698453,0.429893672,0.627129614,0.729875207,0.530147254,0.516992211,0.909464777,8parameter tuning
299,88,Spacy,Feature,Entity linking,Entity linking feature,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?

import spacy
nlp = spacy.load(r""D:\el model\nlp"")
doc = nlp(""Amir Khan is a great boxer"")
ents = [(e.text, e.label_, e.kb_id_) for e in doc.ents]
print(ents) ","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",solution for entity descriptions,The user can make use of the entity_descriptions.csv to display entity descriptions from the KB.,,1,C20230706015220864942,0.682274163,0.786536932,0.703432024,0.771804571,0.78942275,0.87405771,0.696432173,0.699941099,0.608491898,0.854924917,0.690503299,0.824742615,0.71852988,0.700780988,0.692180514,0.662524045,0.792100906,0.761306584,0.619807065,0.727876306,0.710330784,0.700978577,0.850505769,0.860422313,88solution for entity descriptions
35,10,Spacy,Documentation,documentation,Documentation aspect,48200524,Named entity recognition in Spacy,"I am trying to find Named entities for a sentence as below

import spacy.lang.en
parser = spacy.lang.en.English()
ParsedSentence = parser(u""Alphabet is a new startup in China"")
for Entity in  ParsedSentence.ents:  
    print (Entity.label, Entity.label_, ' '.join(t.orth_ for t in Entity))
I am expecting to get the result ""Alphabet"",""China"" but I am getting an empty set as result. What am I doing wrong here","As per spacy documentation for Name Entity Recognition here is the way to extract name entity

import spacy
nlp = spacy.load('en') # install 'en' model (python3 -m spacy download en)
doc = nlp(""Alphabet is a new startup in China"")
print('Name Entity: {0}'.format(doc.ents))
Result
Name Entity:  (China,) ",spacy documentation,Provides guidelines for using Spacy library.,,1,C20230706014344516514,0.471022636,0.453301162,0.456387579,0.587733328,0.392879844,0.734906614,0.572615027,0.564040065,0.548373163,0.635775149,0.594133437,0.797546208,0.472236753,0.697489202,0.809361577,0.540767491,0.414420515,0.432532579,0.454516709,0.512796581,0.517696679,0.480383128,0.354573935,0.605766356,10spacy documentation
229,69,Spacy,Feature,tokenization,tokenization feature,50719732,Keeping all white spaces as tokens,"I have a question about whether there is a way to keep single white space as an independent token in spaCy tokenization.

For example if I ran:

import spacy

nlp = spacy.load(""en_core_web_sm"")
doc = nlp(""This is easy."")
toks = [w.text for w in doc]
toks
The result is

['This', 'is', 'easy', '.']
Instead, I would like to have something like

['This', ' ', 'is', ' ', 'easy', '.']
Is there are a simple way to do that?","spaCy exposes the token's whitespace as the whitespace_ attribute. So if you only need a list of strings, you could do:

token_texts = []
for token in doc:
   token_texts.append(token.text)
   if token.whitespace_:  # filter out empty strings
       token_texts.append(token.whitespace_)
If you want to create an actual Doc object out of those tokens, that's possible, too. Doc objects can be constructed with a words keyword argument (a list of strings to add as tokens). However, I'm not sure how useful that would be.",construction of doc objects,"Spacy allows the creation of an actual Doc object out of the tokens, but it may not be very useful in certain cases.",,1,C20230706015038633753,0.707129657,0.80392313,0.676220357,0.801409304,0.87104708,0.800836682,0.702857435,0.556342781,0.553984344,0.675806165,0.584996223,0.811384559,0.651364267,0.751128495,0.562707305,0.741806209,0.942659974,0.729254782,0.577394187,0.717961669,0.685642838,0.616030991,0.687667072,0.688959181,69construction of doc objects
96,27,Spacy,Performance,fast,Performance aspect,48199353,How to use spacy in large dataset with short sentences efficiently?,"I choose spacy to process kinds of text because of the performance of it's lemmatation compared with nltk. But When I process millions short text, it always consumed all of my memory(32G) and crashed. Without it just a few minutes and less than 10G mem is consumed.

Is something wrong with the usage of this method? is there any better solution to improve the performance? Thanks!","You can use multithreading in spacy to create a fast tokenization and data ingestion pipeline.

Rewriting your code block and functionality using the nlp.pipe method would look something like this:
This way puts all your filtering into the token_filter function, which takes in a spacy token and returns True only if it is not punctuation, a space, a stopword, and 4 or less characters. Then, you use this function as you pass through each token in each document, where it will return the lemma only if it meets all of those conditions. Then, filtered_tokens is a list of your tokenized documents.

Some helpful references for customizing this pipeline would be:

Token attributes
Language.pipe",token filtering customization,Customizing the token filtering process can further enhance Spacy's multithreaded performance.,,0,C20230706014920127221,0.773013294,0.653851807,0.622950315,0.767954111,0.657409132,0.761942148,0.731169641,0.700810552,0.650556028,0.902155817,0.674725711,0.736866295,0.633229375,0.557719469,0.580640256,0.645465791,0.521922231,0.564680815,0.721391499,0.728785455,0.773756385,0.858999908,0.840907216,0.857471883,27token filtering customization
81,23,Spacy,Performance,performance,Performance aspect,72413618,How can I make it so that I process each sentence to look for and replace with a synonym for the words that match?,"I am currently working with spacy and have a corpus (containing 960,256 words) that looks like this:
I have a function that looks for the synonym of a word (using spacy):

Which returns an array of answers like so:
What I want is to grab the corpus, feed it sentence by sentence and word by word to most_similar so I can save the list of words to replace and do so by using replace_wordthe thing is that I'm not sure how to do this. I've tried for a while but it always fails somehow (either won't take batches so I can't do it at once, the words end up being empty vectors if I simply split each sentence by .split("" "") so...could you help me out please?","I hope I understood what you need correctly. I'm guessing you want to:

Iterate over a corpus
Find specific tokens using the matcher
Find synonyms of the matched tokens
Return a new list of sentences but with the replaced tokens.
If that's the case then what you need is a valid similarity function (I tried the one above but it didn't work for me properly) but you can try this:
You also mentioned that you want this to run on a corpus. I recommend that you use the nlp.pipe() method for performance gains combined with the set_extension method. You can do it like this:",successful task execution,User is able to find synonyms of words and apply them to their corpus.,Unclear context,0,C20230706014909486757,0.701083124,0.778435171,0.664889336,0.724101305,0.599908113,0.584136724,0.68133074,0.503732622,0.649523795,0.640830219,0.862077117,0.650603354,0.491259694,0.863623738,0.532744169,0.583745956,0.444087446,0.572957635,0.605717838,0.414434135,0.432720304,0.491207689,0.816862285,0.48919782,23successful task execution
53,15,Spacy,Documentation,documentation,Documentation aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",safety of single spacy object,It is safe to create a single Spacy object and access it from multiple processes for named entity recognition as long as it is done through nlp.pipe and the number of processes is specified to avoid any interference.,wrong labeling,1,C20230706014428609838,0.661610782,0.74248302,0.593051314,0.756361723,0.740449965,0.56033957,0.862473428,0.901774764,0.841077745,0.863834262,0.730533063,0.776055694,0.577548981,0.67037648,0.426627815,0.646595418,0.488143414,0.378259331,0.736786723,0.846794248,0.762493074,0.794931114,0.753355324,0.892961144,15safety of single spacy object
25,8,Spacy,Ease of use,complex,Ease of use aspect,65850018,processing text with spacy nlp.pipe,"I'm procerssing 40,000 abstracts with spacy nlp.pipe using the code below and its taking 8 mins. Is there a way to speed this up further? I've also disabled ner.","Try tuning batch_size and n_process params :
Note as well, by joining on "" "" you may have some surprises, as spaCy's splitting rules are a bit more complex than that.",ease of use,Spacy library is easy to use for text processing.,,0,C20230706014339793574,0.622695923,0.642314911,0.533375263,0.774363279,0.799563468,0.908478618,0.460851192,0.739816368,0.563583791,0.482472897,0.462840855,0.799953401,0.483387321,0.579278708,0.582031131,0.703453541,0.562510133,0.621691883,0.52878201,0.512269199,0.595751345,0.762920618,0.846954644,0.89455229,8ease of use
89,26,Spacy,Performance,fast,Performance aspect,59830899,sense2vec performance improvemets,"I am using Sense2Vec (builds upon Spacy, a fantastic NLP library/tool) and testing the similarity between various words. Unfortunately the performance is quite slow (execution is over a second on a regular MacBook Pro).

Does anyone have a way to speed this up?

Here is the code:

term = ""dog|NOUN""
sense2vec = Sense2Vec().from_disk(""path-to-s2v_reddit_2019_lg"")
sims = sense2vec.most_similar(term, n=top)
I suspect some caching would speed things, but I am not sure which elements should be cached.
","There is indeed a way to speed up Sense2Vec.most_similar. There is a script available from https://github.com/explosion/sense2vec/blob/master/scripts/06_precompute_cache.py, which precomputes a cache of the nearest neighbors. It will then save that cache with the component on disk, making the data larger but the queries fast. If a query is not covered by the cache, most_similar falls back to using the normal computation.",fallback to normal computation,"If a query is not covered by the cache, most_similar still falls back to using the normal computation.",,1,C20230706014917856289,0.72793895,0.73375845,0.735214949,0.620468736,0.430347651,0.752456367,0.752952158,0.757528305,0.685965776,0.665637791,0.842815995,0.672083437,0.516867936,0.689629316,0.605817199,0.285174429,0.288206995,0.719593763,0.404929936,0.762790143,0.6664325,0.453988433,0.452851653,0.835649967,26fallback to normal computation
293,86,Spacy,Feature,NER,NER feature,68682465,pattern match issue with SpaCy,"I have the following script using a pattern to match the postcode. However, depending on how I supply the postcode string seems to affect how it is matched.

It would appear that for some reason the first postcode is never matched. In the last example both ""RH5 0XE"" & ""PO01 0IO"" should match, as you can see ""RH5 0XE"" matched in the previous run.

Any ideas on how I can improve the match rate?","Put the entity_ruler before ner in the pipeline so that its matches have priority over the CARDINAL spans from ner, or alternatively you can set it to overwrite overlapping entities with the overwrite_ents setting.",entity ruler feature,"SpaCy provides an entity ruler that can be used before NER in the pipeline, giving matches priority over CARDINAL spans from ner.",,1,C20230706015217173223,0.703730881,0.674821079,0.593960881,0.456534326,0.620300055,0.581870794,0.753219903,0.554464817,0.625669181,0.790387213,0.780442536,0.755969822,0.623243332,0.712662935,0.628144979,0.567128897,0.62573576,0.826362014,0.743911147,0.397167236,0.565671623,0.55099833,0.71884644,0.591976345,86entity ruler feature
152,43,Spacy,Stability,backwards compatibility,Stability aspect,54201004,Multithreading with spacy: Is joblib necessary?,"In this part of the documentation, it is mentioned that nlp.pipe() works in parallel and the following example is given:

for doc in nlp.pipe(texts, batch_size=10000, n_threads=3):
    pass
After that, another, longer example is given that makes use of joblib. I don't quite understand the relationship between the two. As I understand the documentation, if I simply want to parallelize the tokenisation of many documents, the above, simple for loop will work and I do not have to use joblib, right?

My pipeline looks like this:

nlp = spacy.load('en', disable=['parser', 'ner', 'textcat'])
When would I need to use joblib?","Based on an answer in Spacy github issues:

We kept the n_threads argument to avoid breaking people's code, but unfortunately the implementation doesn't currently release the GIL, the way we did in v1. In v2 the neural network model is more complicated and more subject to change, so we haven't implemented it in Cython. We might at a later date.

In v2.1.0 (you can get an alpha by installing spacy-nightly, the matrix multiplications are now single-threaded. This makes it safe to launch multiple processes for the pipeline, so we can look at doing that internally. In the meantime, the n_threads argument sits idle...Which I agree is confusing, but removing it and breaking backwards compatibility seems worse.
Thus, to summarize: n_threads doesn't work in v2.1. What I'm doing now is using Spacy with joblib to read a dataset in minibatches.

Spacy released an example for that: Spacy Multiprocessing, and it works perfectly.

I have a dataset with almost ~4M short text. Without using the example they released, it took almost 23 hours to finish parsing them, but using joblib with spacy, it took 1 hour and half to finish!

To reference the readers of this question to Spacy Multiprocessing example: Spacy Multiprocessing",matrix multiplications,"In version 2.1.0, matrix multiplications are single-threaded, making it safe to launch multiple processes for the pipeline.",unknown,1,C20230706014953239715,0.65174365,0.52267611,0.552590668,0.555520117,0.472267419,0.752675593,0.857004702,0.702620924,0.628293931,0.809824467,0.726894498,0.780716181,0.669751108,0.600447655,0.695878267,0.645103514,0.764158785,0.781257808,0.733044922,0.668490827,0.728737056,0.709846139,0.93932575,0.745758057,43matrix multiplications
190,55,Spacy,Active Maintenance,github,Active Maintenance aspect,58327580,How to add new lemma rule to existing language for spacy,"I want to add a new lemmatiser rule for an existing language, i.e. lemmatise all nouns ending with ""z"" to ending with """".

In the case of individual words, spaCy gives the opportunity to add a tokeniser exception to an existing language after loading using

nlp.tokenizer.add_special_case(""adidas"", [{ORTH: 'adidas', LEMMA: 'Adidas', POS: 'NOUN', TAG: 'NNP'}])
The above sets the lemma, pos and tag of the new word and this is not altered. The default English lemmatiser returned ""adida"" as the lemma.

Now, I am trying to ""lemmatise"" nouns ""wordz"" to ""word"", ""windowz"" to ""window"" etc without setting all cases as exceptions but rather add a new rule: Noun ending with ""z"" has lemma the noun without the trailing ""z"".

I understand that it will depend on the tagger output as the rules that exist in _lemma_rules.py are pos dependent.

Is there a way to add the rule without creating a new language as a copy of an existing with just one modified file?","Since my question was very specific, I had to communicate with the spaCy developer team and got a working answer.

Actually it is does not work for the fake example in English but it works in real case scenario while using the Greek models as Greek lemmatisation is mainly rule based.

The proposed solution is to use the Lookups Api, which is only available in versions 2.2 and later.

As they mention,

nlp.vocab.lookups.get_table(""lemma_rules"") 
returns a dict-like table that you can write to.

Full answer in spaCy GitHub",developer team available,The fact that a specific question about adding a new lemma rule to an existing language was answered by the Spacy developer team suggests that the library is still actively maintained and support is available for users.,wrong labeling,0,C20230706015015560924,0.712893128,0.423767895,0.67218852,0.46378231,0.514052868,0.292284071,0.6214692,0.895367265,0.853618443,0.63567704,0.734030008,0.794632137,0.541649938,0.43784675,0.48249498,0.290320039,0.561459184,0.376262993,0.71873492,0.720697641,0.597897828,0.656222284,0.548190713,0.500678122,55developer team available
321,94,Spacy,Feature,Sentence segmentation,Sentence segmentation feature,50742516,How to get the index of a token in a sentence in spaCy?,"Is there an elegant way to get the index of a word/token in its sentence? I am aware of the attributes for tokens https://spacy.io/api/token#attributes The i attribute returns the index within the whole parent document. But the parent document can contain multiple sentences.

Example:

""This is an example. This is another example.""
What I need is both ""This"" to be returned as index 0, both ""is"" to be returned as index 1 etc...","A spaCy Doc object also lets you iterate over the doc.sents, which are Span objects of the individual sentence. To get a span's start and end index in the parent document you can look at the start and end attribute. So if you iterate over the sentences and subtract the sentence start index from the token.i, you get the token's relative index within the sentence:

for sent in doc.sents:
    for token in sent:
        print(token.text, token.i - sent.start)
The default sentence segmentation uses the dependency parse, which is usually more accurate. However, you can also plug in a rule-based or entirely custom solution (see here for details).",relative index calculation,Subtracting sentence start index from token.i provides the token's relative index within the sentence.,,1,C20230706015232562611,0.79202801,0.848140419,0.615217328,0.918614149,0.698501348,0.670757353,0.808035731,0.855507314,0.628151953,0.895672917,0.596432388,0.579295218,0.647193074,0.700362682,0.716601014,0.922562122,0.821990728,0.844696462,0.740680516,0.865428746,0.699314952,0.885738194,0.783913374,0.736884236,94relative index calculation
70,20,Spacy,Performance,performance,Performance aspect,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",spacy entity linking capability,"Spacy is capable of entity linking, as evidenced by the provided answer.",,1,C20230706014831834027,0.687228739,0.786448896,0.793444991,0.790802121,0.932027161,0.771582723,0.515444577,0.613074958,0.419943035,0.826915801,0.748104334,0.80090183,0.505186975,0.637023628,0.656230927,0.607449234,0.589619935,0.673822045,0.478766441,0.448661476,0.585059047,0.703521132,0.762587011,0.710422277,20spacy entity linking capability
99,28,Spacy,Performance,fast,Performance aspect,40615717,Spacy.io multithreading with custom pipelines,"I'm trying to use Spacy.io with custom pipelines for language processing, but it seems that when I add a custom function to the pipeline the process runs only on one thread. With default pipeline process uses all the threads specified.

This is how I defined pipeline:

nlp = spacy.load(language, create_pipeline=custom_pipeline)
This is custom_pipeline function:

def custom_pipeline(nlp):
    return (nlp.tagger, score_vocab_pipe)
This is how I run the pipeline:

nlp.pipe(texts, batch_size=1000, n_threads=8)
Are there any requisites for custom pipeline functions to support multithreading with spacy?","This post might give you a better understanding of how the multi-threading is implemented. The multi-threading is described in the docs here.

In short: the tagger doesn't currently release the GIL, so the tagger.pipe() method is just a generator that applies the tagger one-by-one. The tagger should be quite fast for most workloads with one thread per process, especially since it doesn't use much memory. You can see the recipe for multi-processing batch jobs here.

We could release the GIL around the tagger as well, to allow efficient multi-threading. If you'd like to work on this, we can talk about it on the tracker or the spaCy Gitter.",potential optimization,"Releasing the GIL around the tagger in Spacy could allow for efficient multi-threading, which may help optimize the performance for multithreading with custom pipelines.",,1,C20230706014922236947,0.797916234,0.822178185,0.738069832,0.925534129,0.812624395,0.820288062,0.909107745,0.800198138,0.755749822,0.733237624,0.699979484,0.728342474,0.659436524,0.70985961,0.571585119,0.710219145,0.702488184,0.64633894,0.838545918,0.846702099,0.572560012,0.787643433,0.602832973,0.686848283,28potential optimization
332,98,Spacy,Feature,Rule-based matching,Rule-based matching feature,72346631,Highlight text parts based on labels,"thanks to fellow stackoverflowrians I have data labels that I would like to high light in the text:

eg. I have product description

Description: Tampered black round grey/natural swing with yellow load-bearing left hook
Features were extracted as

colors=['black','grey','natural','yellow']
shape = ['round']
direction= ['left']
In Spacy it is possible to highlight the features like this

enter image description here

Is there any possibility to highlight it also like this from the data I have as labels? So that I have labels shown in the text too? I dont know if Spacy is the good tool or any other is better?
","I'm not entirely sure what you're asking, but you can put entities of your own on the spaCy Doc object and pass them to Displacy.

To simply set entities manually, you can do this:

doc = nlp(...)
span = doc[0:1] # whatever span of the doc you want to highlight
span.ent_label_ = ""COLOR"" # the label you want
ents = [span] # in reality you could do more than one
doc.ents = ents
If you have word list and need to look for words, you can use rule-based matching with an EntityRuler. Check the rule-based matching guide.",setting entities manually,"Entities can be set manually to highlight specific spans of text, as described in the provided answer.",,1,C20230706015239199193,0.560834289,0.669349134,0.757561147,0.630195856,0.469000965,0.53199476,0.474714786,0.643183172,0.454028368,0.588749409,0.439880401,0.723387361,0.593809485,0.678654253,0.627477646,0.539707184,0.511551321,0.603320241,0.602529645,0.62877816,0.504807055,0.674027324,0.708466887,0.673321128,98setting entities manually
300,88,Spacy,Feature,Entity linking,Entity linking feature,59316859,Displaying the description of entity from kb id in spacy entity linking,"I have successfully trained a spacy entity linking model(obviously by limiting the data).

my question is how to display the description of entity from kb as output?

import spacy
nlp = spacy.load(r""D:\el model\nlp"")
doc = nlp(""Amir Khan is a great boxer"")
ents = [(e.text, e.label_, e.kb_id_) for e in doc.ents]
print(ents) ","As said by Sofie Van Landeghem(Spacy Entity Linking Representative). The descriptions are currently not stored in the KB itself because of performance reasons. However, from the intermediary results during processing, you should have a file entity_descriptions.csv that maps the WikiData ID to its description in a simple tabular format.",spacy supports entity linking,The user has successfully trained a Spacy entity linking model and is now looking for ways to display the description of an entity from the knowledge base (KB) as output.,,1,C20230706015219267186,0.611966074,0.670659959,0.740208685,0.264761388,0.704694271,0.311856329,0.600731909,0.852492511,0.574174225,0.612009466,0.654836893,0.569872439,0.713975847,0.639592886,0.364870638,0.368397206,0.562830925,0.314870328,0.560199499,0.711502194,0.674354136,0.475044638,0.436329991,0.662335634,88spacy supports entity linking
21,6,Spacy,Ease of use,difficult,Ease of use aspect,48980120,Is it possible to parse emojis using spaCy?,"Is it possible to tokenize emojis like :), :(, ;~( properly using the spaCy Python library? e.g. If I run the following code:

import spacy

nlp = spacy.load('en')
doc = nlp(""Hello bright world :)"")
And then visualize the doc with displaCy:
It incorrectly parses world :) as one token. How can I modify spaCy so it recognizes these additional symbols? Thanks.

edit: Found the following: https://github.com/ines/spacymoji but I think it only supports Unicode emojis like ‚Äö√Ñ√∂‚àö‚à´¬¨√Ü and not ASCII ones like :)","Yes, spaCy actually includes a pretty comprehensive list of text-based emoticons as part of its tokenizer exceptions. So using your example above and printing the individual tokens, the emoticon is tokenized correctly:

doc = nlp(""Hello bright world :)"")
print([token.text for token in doc])
# ['Hello', 'bright', 'world', ':)']
I think what happens here is that you actually came across an interesting (maybe non-ideal) edge case with the displacy defaults. To avoid very long dependency arcs for punctuation, the collapse_punct setting defaults to True. This means that when the visualisation is rendered, punctuation is merged onto the preceding token. Punctuation is identified by checking whether the token's is_punct attribute returns True ‚Äö√Ñ√∂‚àö√ë‚àö¬® which also happens to be the case for "":)"".

In your example, you can work around this by setting collapse_punct to False in the options passed to displacy.serve:

displacy.serve(doc, style='dep', options={'collapse_punct': False})
(The displaCy visualizer should probably include an exception for emoticons when merging punctuation. This is currently difficult, because spaCy doesn't have an is_emoji or is_symbol flag. However, it might be a nice addition in the future ‚Äö√Ñ√∂‚àö√ë‚àö¬® you can vote for it on this thread.)",spacy tokenizer exceptions,"spaCy includes a list of text-based emoticons as part of its tokenizer exceptions, which means that the emoticons in question are tokenized correctly.",,1,C20230706014335035118,0.838363826,0.763573647,0.710490823,0.879173219,0.714703441,0.755903125,0.72504133,0.843183398,0.745769799,0.804977834,0.871731818,0.748438537,0.668187201,0.59436214,0.529947698,0.691882789,0.527375102,0.576721907,0.775838971,0.744166434,0.632799804,0.91306448,0.826421261,0.793750107,6spacy tokenizer exceptions
308,91,Spacy,Feature,Entity linking,Entity linking feature,60809394,Can spaCy link only named entities?,"I'd would like to extract important entities and link them to Wikipedia entities. I've trained spaCy on a small sample of Wikipedia/WikiData and run entity linking on the review:

[('Tofu', 'PERSON', 'Q177378'), 
('Nyquil', 'WORK_OF_ART', 'NIL')]
I'd like other entities to be extracted and linked as well, e.g.:

kimchi -> Kimchi
cold -> Common cold
healing -> medicine 
medically -> medicine
It looks like spaCy can link only named entities. I've tried to explicitly list other entities as named (which obviously does not scale well):

ruler = EntityRuler(nlp)
patterns = [{""label"": ""ORG"", ""pattern"": ""kimchi""}, {""label"": ""ORG"", ""pattern"": ""cold""}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, spaCy does not seem to link new entities at all:

[ ('Tofu', 'PERSON', 'Q177378'),
  ('cold', 'ORG', ''),
  ('Nyquil', 'WORK_OF_ART', 'NIL'),
  ('kimchi', 'ORG', '')]
How can I make Spacy recognize also other entities?
Should this be done before training entity linking model or can be done with already trained model?
Is spaCy the right tool for my task at all?","In theory it's possible. First, you'll need to make sure you have a component that tags these kind of entities. You could train an NER model for this, but be aware that its performance might not be as good on things like ""cold"" than it would be for actual named entities like ""London"".

To create the Knowledge Base and the Entity Linker from Wikipedia/Wikidata, the example scripts are not limited to named entities - they attempt to parse anything that appears in an intra-wiki link. If the word ""cold"" gets linked to the page ""Common cold"", it should be able to learn it. The exact entities that are stored in the KB and that are used for training the EL model, depend on which entities are found by your entity recognizer component. So if you adjust that according to your use-case, the entity linking component will follow automatically.",entity recognizer adjustment,The exact entities stored in the KB and used for training depend on the adjustments made to the entity recognizer component.,Limitation of similarity calculation (large text),1,C20230706015227657025,0.807363868,0.795279145,0.864912808,0.454815239,0.541028023,0.869794548,0.617639184,0.794276416,0.853350997,0.818287075,0.766730964,0.867636979,0.561243534,0.69584918,0.661664069,0.315890461,0.404399991,0.638254106,0.439342082,0.776517153,0.661468387,0.582327008,0.678733706,0.686025679,91entity recognizer adjustment
104,30,Spacy,Performance,speed,Performance aspect,70925238,Sharing Spacy model between processes,"My code is using Python's multiprocessing for parallel computation. As part of the computation Spacy is used. Is it safe to create a single spacy object with nlp = spacy.load(""de_core_news_lg"") and access it by multiple processes for named entity recognition?","You can take advantange of multiprocessing with spaCy by passing the n_process argument to nlp.pipe. For example:

docs = [""This is the first doc"", ""this is the second doc""]

nlp = spacy.load(""en_core_web_sm"")  # use your model here

docs_tokens = []
for doc in nlp.pipe(docs, n_process=2):
    tokens = [t.text for t in doc]
    docs_tokens.append(tokens)
There's more about this in the spaCy documentation, as well as this Speed FAQ.",multiprocessing compatibility,Spacy is compatible with Python's multiprocessing module for parallel computation. This means that it's possible to use multiple processes to speed up certain tasks.,,1,C20230706014926247135,0.702291906,0.453009158,0.603641391,0.508944631,0.691509962,0.609663427,0.27737233,0.327551931,0.417286247,0.732036054,0.738725901,0.792300999,0.622711122,0.67227602,0.584238768,0.579923451,0.581768215,0.677978754,0.592476189,0.794345677,0.531454265,0.724844754,0.781240702,0.646169245,30multiprocessing compatibility
261,77,Spacy,Feature,dependency parsing,dependency parsing feature,43397502,Rule-based matcher of entities with spacy,"I want to use the python library spacy for matching tokens in a text (adding a labels as a semantic reference). Then, I want to use the matches to extract relations between the tokens. My first was to make use of the matcher.add and matcher.add_pattern of spacy. The matcher.add is working fine and I can find tokens, my code until now:

I have tried in different ways to make this works but is obviously not, I guess there is something wrong with my understanding of matcher.add_pattern.

Can some please put me in the right direction how to do this with spacy?
Is it possible to add regex here to find patterns, how?
How can I add more than one token with the same label, or somehow create a list of tokens for the same label, eg. ""FINANCE""?
I will appreciate any comments.","Your matcher would identify the tokens, but to find relations between them you will have to do dependency parsing. Here is visual example from spacy :
You can then traverse the tree to find relations between the tokens. https://spacy.io/docs/usage/dependency-parse#navigating

The dep (enum) and dep_ (verbose name) attribute of each token would give you the relationships with its child",adding tokens with the same label,The user can add more than one token with the same label or create a list of tokens for the same label.,No answer available against the challenge,0,C20230706015057731889,0.759900153,0.719471455,0.681323767,0.801203072,0.654767454,0.697752178,0.57836771,0.526373863,0.369715959,0.740244269,0.629479229,0.526548862,0.709237695,0.612450361,0.69453603,0.863154054,0.828225791,0.870194912,0.618206561,0.40159905,0.342611045,0.701700509,0.610253751,0.456677258,77adding tokens with the same label
173,50,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,46826541,Methods for creating training data for SpaCy models?,"I recently began a NLP journey using SpaCy, and I have ~5,500 strings which I want to label up. For the first 100, I did this using a spreadsheet with custom columns, which was then run through a script to generate Python dictionaries. In the sheet, I have strored the string, label type, label value. The script then works out the position of the label value from within the string.

It's rather time consuming to product training data in this way, and it's open to error.

Are there any tools available to assist with this? I literally just need the ability to highlight a substring, and then choose the label type. I could build it myself, but I feel it may already exist.","I'm one of the maintainers of spaCy and we've actually been thinking about this problem a lot! So we've built Prodigy, an annotation tool that integrates with spaCy and puts the model in the loop to help you train and evaluate models faster. It's currently in beta, but you can sign up for a free invite. Prodigy takes a slightly different approach to the click-drag-highlight-select concept of other annotation tools. It uses the model in the loop to suggest annotations with the most relevant gradient for training, and only asks you for a simple binary feedback: accept or reject. This lets you move through examples quickly. As you annotate, the model in the loop is updated, and its predictions will influence what Prodigy asks next.

This works especially well if you're looking to improve existing entity types present in your spaCy model, or if you're working with a large corpus of example text you want to use for annotation.

If you're looking for a tool more specifically for highlighting and annotating spans of text, you should also check out Brat. I'm not 100% sure what the output looks like, but you should definitely be able to convert it to spaCy's training format. There's also a trainable version of the displaCy ENT visualizer, developed by someone from the community.",maintainer response,The answer was provided by one of the maintainers of the SpaCy library.,,1,C20230706015006097079,0.459847748,0.768110812,0.543018222,0.783793271,0.864929497,0.803289235,0.638807237,0.65863657,0.674426556,0.580518603,0.718794346,0.779908121,0.254903048,0.576003253,0.264306903,0.663049817,0.610613644,0.484613687,0.36435768,0.495739579,0.381843895,0.630074441,0.812813342,0.614010751,50maintainer response
283,82,Spacy,Feature,Lemmatization,Lemmatization feature,74175424,"Is Spacy lemmatization not working properly or does it not lemmatize all words ending with ""-ing""?","When I run the spacy lemmatizer, it does not lemmatize the word ""consulting"" and therefore I suspect it is failing.

Here is my code:

nlp = spacy.load('en_core_web_trf', disable=['parser', 'ner'])
lemmatizer = nlp.get_pipe('lemmatizer')
doc = nlp('consulting')
print([token.lemma_ for token in doc])
And my output:

['consulting']","The spaCy lemmatizer is not failing, it's performing as expected. Lemmatization depends heavily on the Part of Speech (PoS) tag assigned to the token, and PoS tagger models are trained on sentences/documents, not single tokens (words). For example, parts-of-speech.info which is based on the Stanford PoS tagger, does not allow you to enter single words.

In your case, the single word ""consulting"" is being tagged as a noun, and the spaCy model you are using deems ""consulting"" to be the appropriate lemma for this case. You'll see if you change your string instead to ""consulting tomorrow"", spaCy will lemmatize ""consulting"" to ""consult"" as it is tagged as a verb (see output from the code below). In short, I recommend not trying to perform lemmatization on single tokens, instead, use the model on sentences/documents as it was intended.",single token issues,Performing lemmatization on single tokens (words) without considering the context can be unreliable and lead to incorrect lemmatization results.,Limitation of similarity calculation (large text),1,C20230706015139424764,0.824950337,0.585836887,0.650755703,0.717221618,0.829044998,0.800133944,0.919925511,0.777897298,0.685138106,0.803996205,0.754323781,0.906009972,0.673788249,0.584127843,0.533505976,0.859632492,0.627724886,0.607004285,0.674219668,0.605935276,0.7493155,0.935653865,0.886095881,0.824643135,82single token issues
184,53,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44176829,Python Spacy error: RuntimeError: Language not supported,"I am going to add new entities to the own spacy data model ""mymodel"". Before I have installed ""mymodel"" using this tutorial and it was working good. When I want to use ""mymodel"" to add new entities I have a misunderstanding. Please, help me
","The problem here is that spacy.load() currently expects either a language ID (e.g. 'en'), or a shortcut link to a model that tells spaCy where to find the data. Because spaCy can't find a shortcut link, it assumes that 'my_model' is a language, which obviously doesn't exist.

You can set up a link for your model like this:

python -m spacy link my_model my_model # if it's installed via pip, or:
python -m spacy link /path/to/my_model/data my_model
This will create a symlink in the /spacy/data directory, so you should run it with admin permissions.

Alternatively, if you've created a model package that can be installed via pip, you can simply install and import it, and then call its load() method with no arguments:

import my_model
nlp = my_model.load()
In some cases, this way of loading models is actually more convenient, as it's cleaner and lets you debug your code more easily. For example, if a model doesn't exist, Python will raise an ImportError immediately. Similarly, if loading fails, you know there's likely a problem with the model's own loading and meta.

Btw: I'm one of the spaCy maintainers and I agree that the way spacy.load() currently works is definitely unideal and confusing. We're looking forward to finally changing this with the next major release. We're very close to releasing the first alpha of v2.0, which will solve this problem more elegantly, and will also include a lot of improvements to the training process and documentation.",improvements coming in next release,"The maintainer stated that the next major release will solve this problem more elegantly, and will also include improvements to the training process and documentation.",,1,C20230706015012910461,0.505467594,0.577053964,0.562460244,0.631191611,0.450848281,0.597704351,0.599552333,0.71140784,0.763481379,0.848398089,0.629772782,0.673347414,0.529425025,0.579114616,0.40876615,0.618191004,0.483924121,0.459118545,0.552716255,0.656536162,0.395204872,0.721956313,0.757499158,0.72419101,53improvements coming in next release
226,68,Spacy,Feature,tokenization,tokenization feature,59500498,spacy tokenizer: is there a way to use regex as a key in custom exceptions for update_exc,"It is possible to add custom exceptions to spacy tokenizer. And these exceptions work fine. However, as far as I know, it's possible to use only strings as keys to match for those exceptions. It's done this way:
The only clue I found is: https://github.com/explosion/spaCy/issues/840

In that revision of tokenizer_exceptions.py there was some way to use regexps as keys for tokenizer exceptions(however, I haven't found any examples to do so)

But in current revisions, at least initial analysis hasn't shown any ways to do s

So is there a way to solve this task?

(input: regex as a key for exception, output - phone numbers with spaces inside)","No, there's no way to have regular expressions as tokenizer exceptions. The tokenizer only looks for exceptions as exact string matches, mainly for reasons of speed. The other difficulty for this kind of example is that tokenizer exceptions currently can't contain spaces. (Support for spaces is planned for a future version of spacy, but not regexes, which would still be too slow.)

I think the best way to do this would be to add a custom pipeline component at the beginning of the pipeline that retokenizes the document with the retokenizer: https://spacy.io/api/doc#retokenize. You can provide any required attributes like lemmas while retokenizing.",exact string matches,The tokenizer only matches exceptions with exact string matches for reasons of speed.,,1,C20230706015036106424,0.703240454,0.736447513,0.745806158,0.716056645,0.745891571,0.714836478,0.834049881,0.774216592,0.660151482,0.778555989,0.715325952,0.756330967,0.566769958,0.648768663,0.601204813,0.613076568,0.627848327,0.72309792,0.637660146,0.5865345,0.493076235,0.813253164,0.784705877,0.598141909,68exact string matches
165,48,Spacy,Stability,version,Stability aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",active maintenance,The Spacy maintainer is active and working to fix issues with model downloads.,,1,C20230706015001939199,0.703317523,0.549768686,0.601170003,0.46829325,0.514374435,0.533300817,0.451087207,0.585043192,0.635598242,0.423232615,0.476215184,0.72314322,0.401250511,0.412047893,0.566642702,0.536648095,0.48806718,0.548991442,0.533258855,0.562141657,0.590068579,0.761374116,0.812707901,0.601435423,48active maintenance
86,25,Spacy,Performance,fast,Performance aspect,58212589,How to check if a sentence is a question with spacy?,"I am using spacy library to build a chat bot. How do I check if a document is a question with a certain confidence? I know how to do relevance, but not sure how to filter statements from questions.

I am looking for something like below:

spacy.load('en_core_web_lg')('Is this a question?').is_question","My first response is to suggest looking for question marks at the end of the sentence.

Otherwise, most questions start with {is, does, do, what, when, where, who, why, what, how}.

There is a more complex answer involving the inclusion of auxiliary verbs and their placement relative to the verb, but if your data is well-formed, this may be sufficient (and fast).",finding common question words,Suggests identifying frequently used question words to identify a question,,0,C20230706014915229802,0.55045253,0.713089645,0.5507375,0.746093273,0.583235025,0.688716352,0.532740951,0.596773982,0.572953522,0.686036289,0.79362601,0.675146818,0.489826143,0.416928023,0.391962647,0.522690058,0.286648571,0.376671493,0.603875637,0.518823683,0.592986226,0.637111783,0.629351854,0.823177695,25finding common question words
225,68,Spacy,Feature,tokenization,tokenization feature,59500498,spacy tokenizer: is there a way to use regex as a key in custom exceptions for update_exc,"It is possible to add custom exceptions to spacy tokenizer. And these exceptions work fine. However, as far as I know, it's possible to use only strings as keys to match for those exceptions. It's done this way:
The only clue I found is: https://github.com/explosion/spaCy/issues/840

In that revision of tokenizer_exceptions.py there was some way to use regexps as keys for tokenizer exceptions(however, I haven't found any examples to do so)

But in current revisions, at least initial analysis hasn't shown any ways to do s

So is there a way to solve this task?

(input: regex as a key for exception, output - phone numbers with spaces inside)","No, there's no way to have regular expressions as tokenizer exceptions. The tokenizer only looks for exceptions as exact string matches, mainly for reasons of speed. The other difficulty for this kind of example is that tokenizer exceptions currently can't contain spaces. (Support for spaces is planned for a future version of spacy, but not regexes, which would still be too slow.)

I think the best way to do this would be to add a custom pipeline component at the beginning of the pipeline that retokenizes the document with the retokenizer: https://spacy.io/api/doc#retokenize. You can provide any required attributes like lemmas while retokenizing.",custom retokenizer component,A custom pipeline component with the retokenizer can be added at the beginning to tokenize the document with desired attributes like lemmas.,,1,C20230706015037365641,0.661379397,0.52249819,0.680368543,0.486647457,0.64558655,0.483667552,0.55509907,0.297647417,0.456085116,0.462577581,0.567762733,0.690320015,0.735717535,0.562782943,0.565430999,0.567011774,0.597106218,0.569155037,0.491287231,0.507655263,0.46493715,0.704194903,0.759280086,0.732489765,68custom retokenizer component
239,71,Spacy,Feature,tokenization,tokenization feature,50330455,How to detokenize spacy text without doc context?,"I have a sequence to sequence model trained on tokens formed by spacy's tokenization. This is both encoder and decoder.

The output is a stream of tokens from a seq2seq model. I want to detokenize the text to form natural text.

Example:

Input to Seq2Seq: Some text

Output from Seq2Seq: This does n't work .

Is there any API in spacy to reverse tokenization done by rules in its tokenizer?","TL;DR I've written a code that attempts to do it, the snippet is below.

Another approach, with a computational complexity of O(n^2) * would be to use a function I just wrote. The main thought was ""What spaCy splits, shall be rejoined once more!""
Downsides:

In this approach you may easily merge ""do"" and ""nt"", as well as strip space between the dot ""."" and preceding word. This method is not perfect, as there are multiple possible combinations of sentences that lead to specific spaCy tokenization.

I am not sure if there is a method to fully detokenize a sentence when all you have is spaCy separated text, but this is the best I've got.

After having searched for hours on Google, only a few answers came along, with this very stack question being opened on 3 of my tabs on chrome ;), and all it wrote was basically ""don't use spaCy, use revtok"". As I couldn't change the tokenization other researchers chose, I had to develop my own solution. Hope it helps someone ;)",no built-in function,Spacy does not have a built-in function to reverse tokenization done by its tokenizer.,,0,C20230706015041337049,0.64043808,0.922920346,0.549116552,0.461243004,0.455112845,0.903448045,0.502056003,0.848194718,0.549706697,0.454901725,0.736967564,0.670820475,0.537972629,0.563804567,0.51361692,0.472883493,0.288624614,0.562297404,0.483442038,0.580160379,0.635501087,0.736186266,0.705493689,0.811128318,71no built-in function
18,6,Spacy,Ease of use,difficult,Ease of use aspect,48980120,Is it possible to parse emojis using spaCy?,"Is it possible to tokenize emojis like :), :(, ;~( properly using the spaCy Python library? e.g. If I run the following code:

import spacy

nlp = spacy.load('en')
doc = nlp(""Hello bright world :)"")
And then visualize the doc with displaCy:
It incorrectly parses world :) as one token. How can I modify spaCy so it recognizes these additional symbols? Thanks.

edit: Found the following: https://github.com/ines/spacymoji but I think it only supports Unicode emojis like ‚Äö√Ñ√∂‚àö‚à´¬¨√Ü and not ASCII ones like :)","Yes, spaCy actually includes a pretty comprehensive list of text-based emoticons as part of its tokenizer exceptions. So using your example above and printing the individual tokens, the emoticon is tokenized correctly:

doc = nlp(""Hello bright world :)"")
print([token.text for token in doc])
# ['Hello', 'bright', 'world', ':)']
I think what happens here is that you actually came across an interesting (maybe non-ideal) edge case with the displacy defaults. To avoid very long dependency arcs for punctuation, the collapse_punct setting defaults to True. This means that when the visualisation is rendered, punctuation is merged onto the preceding token. Punctuation is identified by checking whether the token's is_punct attribute returns True ‚Äö√Ñ√∂‚àö√ë‚àö¬® which also happens to be the case for "":)"".

In your example, you can work around this by setting collapse_punct to False in the options passed to displacy.serve:

displacy.serve(doc, style='dep', options={'collapse_punct': False})
(The displaCy visualizer should probably include an exception for emoticons when merging punctuation. This is currently difficult, because spaCy doesn't have an is_emoji or is_symbol flag. However, it might be a nice addition in the future ‚Äö√Ñ√∂‚àö√ë‚àö¬® you can vote for it on this thread.)",default collapse_punct setting,The displacy default setting of collapse_punct to True caused the emoticon to be merged with the preceding token in the visualization.,,1,C20230706014335560465,0.606462717,0.727243543,0.670575619,0.672362626,0.84569335,0.789908111,0.647885859,0.825855792,0.839953661,0.730656743,0.748624861,0.831344545,0.459187359,0.717638016,0.592742443,0.355967313,0.679535449,0.538921833,0.722800612,0.781431019,0.666640162,0.76601398,0.93401438,0.771614134,6default collapse_punct setting
339,100,Spacy,Feature,Rule-based matching,Rule-based matching feature,57479028,spaCy NLP custom rule matcher,"I am begginer with NLP. I am using spaCy python library for my NLP project. Here is my requirement,

I have a JSON File with all country names. Now i need to parse and get goldmedal count for the each countries in the document. Given below the sample sentence,

""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics""
I am able to fetch country names but not it medal count. Given below my code. Please help to proceed further.","Spacy provides Rule-based matching which you could use.

They can be used as follows:

import spacy
from spacy.pipeline import EntityRuler
nlp = spacy.load('en_core_web_sm', disable=[""ner"", ""parser""])

countries = ['Czech Republic', 'Slovakia']
ruler = EntityRuler(nlp)
for a in countries:
    ruler.add_patterns([{""label"": ""country"", ""pattern"": a}])
nlp.add_pipe(ruler)


doc = nlp(""Czech Republic won 5 gold medals at olympics. Slovakia won 0 medals olympics"")

with doc.retokenize() as retokenizer:
    for ent in doc.ents:
        retokenizer.merge(doc[ent.start:ent.end])


from spacy.matcher import Matcher
matcher = Matcher(nlp.vocab)
pattern =[{'ENT_TYPE': 'country'}, {'lower': 'won'},{""IS_DIGIT"": True}]
matcher.add('medal', None, pattern)
matches = matcher(doc)


for match_id, start, end in matches:
    span = doc[start:end]
    print(span)

output:

Czech Republic won 5
Slovakia won 0
The above code should get you started. Naturally, you will have to write your own more complex rules so that you can handle cases like: ""Czech Republic unsurprisingly won 5 gold medals at olympics in 1995."" And other more complex sentence structures.",entityruler for pattern matching,EntityRuler can be used to create patterns for entity matching in the given text. Users can add multiple patterns using this.,,1,C20230706015243442482,0.804447472,0.552970767,0.610339284,0.694138587,0.669718027,0.636562645,0.550129473,0.611319125,0.507674098,0.351548791,0.645267904,0.385089844,0.462195933,0.593742132,0.656506181,0.889189482,0.48474896,0.490817904,0.406872213,0.66735673,0.599853873,0.576694906,0.38955009,0.700446546,100entityruler for pattern matching
8,3,Spacy,Ease of use,easy,Ease of use aspect,74799295,How to extract cities with Spacy / Can't load French model,"I know it's perhaps an easy question but i'm not very familiar with Spacy.

So i'm trying to extract cities in a text file.","I just skimmed some of the source code for locationtagger, and it appears that it hardcodes usage of the en_core_web_sm model. It likely does not form correct parses of your input text.

I would not use nltk or locationtagger for this task.

Instead, download a proper spaCy model for French:

python3 -m spacy download fr_core_news_{sm|md|lg|trf}
Read spaCy's documentation on named entity recognition [1]. This includes information about identifying geopolitical entities (""GPE"").

The default spaCy models will tag cities, states/provinces/districts, and countries under the ""GPE"" tag. If you are interested only in the cities, then, you should filter the found GPEs against the data in locationtagger's City-Region-Locations.csv.

Additionally, you may wish to segment the text by paragraph and use spaCy's nlp.pipe to process paragraphs in parallel.",data filtering,"When extracting cities using Spacy, filtering out non-city GPEs may be necessary, using external data sources if available.",,1,C20230706014331552465,0.721106946,0.716716528,0.724244654,0.832732856,0.844703555,0.748070657,0.724495113,0.831026435,0.832564414,0.74011904,0.74492687,0.814965785,0.767824292,0.640961707,0.526797473,0.62558192,0.649707139,0.533218622,0.784702837,0.863932908,0.731829643,0.789056957,0.723205745,0.740505457,3data filtering
302,89,Spacy,Feature,Entity linking,Entity linking feature,59050554,Error running Spacy entity linking example,"I was trying the entity linking example in spacy.
Using this example to train the entity linker and generating the knowledge base for the same with this example.

I can create a knowledge base with the available en_core_web_md, this is the output for the same.
When I try to train the entity linker with the knowledge base from above, I get this error.
File ""pipes.pyx"", line 1219, in spacy.pipeline.pipes.EntityLinker.update
I did follow the instructions specified here. I used the en_core_web_md to create the knowledge base since I do not have a pre-trained model.

I did not write any custom code just trying to run this example, Can someone point me to the right direction.
","This was asked and answered in the following issue on spaCy's GitHub.

It looks like the script no longer worked after a refactor of the entity linking pipeline as it now expects either a statistical or rule-based NER component in the pipeline.

The new script adds such an EntityRuler to the pipeline as an example. I.e.,

# Add a custom component to recognize ""Russ Cochran"" as an entity for the example training data.
# Note that in a realistic application, an actual NER algorithm should be used instead.
ruler = EntityRuler(nlp)
patterns = [{""label"": ""PERSON"", ""pattern"": [{""LOWER"": ""russ""}, {""LOWER"": ""cochran""}]}]
ruler.add_patterns(patterns)
nlp.add_pipe(ruler)
However, this can be replaced with your own statistical NER model.",error caused by pipeline refactor,The error encountered by the user was due to a recent refactor of the entity linking pipeline in Spacy. The new pipeline expects a statistical or rule-based NER component.,,1,C20230706015221955271,0.619736552,0.706256449,0.469910085,0.672507226,0.464259595,0.639446139,0.577388346,0.820062935,0.797587991,0.619450152,0.538807988,0.815181732,0.621023893,0.523018718,0.503892481,0.535851777,0.413717389,0.448583037,0.666611612,0.805354953,0.669887185,0.674877346,0.650162816,0.8830989,89error caused by pipeline refactor
331,97,Spacy,Feature,Text classification,Text classification feature,62092445,Is it possible to improve spaCy's similarity results with custom named entities?,"I've found that spaCy's similarity does a decent job of comparing my documents using ""en_core_web_lg"" out-of-the-box.

I'd like to tighten up relationships in some areas and thought adding custom NER labels to the model would help, but my results before and after show no improvements, even though I've been able to create a test set of custom entities.

Now I'm wondering, was my theory completely wrong, or could I simply be missing something in my pipeline?

If I was wrong, what's the best approach to improve results? Seems like some sort of custom labeling should help.","I found my solution was nestled in this tutorial: Text Classification in Python Using spaCy, which generates a BoW matrix for spaCy's text data by using SciKit-Learn's CountVectorizer.

I avoided sentiment analysis tutorials, due to binary classification, since I need support for multiple categories. The trick was to set multi_class='auto' on the LogisticRegression linear model, and to use average='micro' on the precision score and precision recall, so all my text data, like entities, were leveraged:

classifier = LogisticRegression(solver='lbfgs', multi_class='auto')
and...

print(""Logistic Regression Accuracy:"",metrics.accuracy_score(y_test, predicted))
print(""Logistic Regression Precision:"",metrics.precision_score(y_test, predicted,average='micro'))
print(""Logistic Regression Recall:"",metrics.recall_score(y_test, predicted,average='micro'))
Hope this helps save someone some time!",text classification tutorial,The user found success with a text classification tutorial using spaCy and SciKit-Learn's CountVectorizer.,,1,C20230706015237619196,0.566343904,0.698698699,0.592818499,0.795357049,0.729714572,0.782024503,0.574088037,0.775009394,0.535242796,0.844297111,0.570521176,0.680336177,0.552619815,0.618234217,0.555994868,0.655642748,0.563489914,0.795898139,0.454289705,0.60988903,0.558490396,0.815723836,0.812869668,0.780110002,97text classification tutorial
207,62,GSON,Security,Security,Security aspect,13267258,Gson SecurityException: Can not make Class Constructor accessible,"I am using Gson to serialize/deserialize a class that contains a static nested class. The class looks like below.

public class ClassA {
private NestedClass nestedClass;

public NestedClass getNestedClass() {
return nestedClass;
}

public void setNestedClass(NestedClass nestedClass) {
this.nestedClass = nestedClass;
}

public static class NestedClass implements Serializable {

public NestedClass() {
}
}
}
The serialization works fine, but when i am trying to deserialize the json string back into an object i get the following SecurityException.

The exception seems to be coming from Java while trying to reflect the inner class. Has anyone been in that situation before?

Any help appreciated.",It appears you're running Gson on a JVM with a SecurityManager enabled. You'll need to disable the security manager to use Gson.,disabling security manager,The answer provided suggests that disabling the security manager may be necessary to use GSON.,,1,C20230706015027101697,0.755953312,0.63524121,0.771779358,0.843688011,0.788871825,0.740530849,0.540295064,0.667476535,0.513590813,0.481430531,0.818057716,0.509388626,0.625374794,0.617233574,0.70972681,0.620753348,0.67800653,0.621966183,0.648833096,0.663018644,0.67802763,0.550918519,0.677651227,0.71891278,62disabling security manager
43,13,Spacy,Documentation,documentation,Documentation aspect,74550422,Concatenate two spacy docs together?,"How do I concatenate two spacy docs together? To merge them into one?

import spacy

nlp = spacy.load('en')
doc1 = nlp(u'This is the doc number one.')
doc2 = nlp(u'And this is the doc number two.')
new_doc = doc1+doc2
Of course that will return an error as a doc object is not concatenable by default. Is there a straightforward solution to do that?

I looked at this: https://github.com/explosion/spaCy/issues/2229 The issue seems closed so it sounds like they have implemented a solution but I cannot find a simple example of that being used.","What about this:
For ""a lot"" of different sentences, it might be better to use nlp.pipe as shown in the documentation.

Hope it helps.",efficiency,Using nlp.pipe is more efficient for a lot of different sentences.,,1,C20230706014421703319,0.761793315,0.696801305,0.843578458,0.911412179,0.69830215,0.70810473,0.698425293,0.622734606,0.819345951,0.873406887,0.776449442,0.735606372,0.792737246,0.698336124,0.614728808,0.799316704,0.907679379,0.758115649,0.666465938,0.607834458,0.5416857,0.884670854,0.787614405,0.762488008,13efficiency
179,51,Spacy,Active Maintenance,Maintain,Active Maintenance aspect,44980966,Spacy model download issue,"I am using Spacy 1.3

However, it looks like I cannot download the model now.

20/29 : RUN python -m spacy.en.download all
The command '/bin/sh -c python -m spacy.en.download all' returned a non-zero code","There seems to be a problem with the download server ‚Äö√Ñ√∂‚àö√ë‚àö¬® this will be fixed asap. (I'm one of the spaCy maintainers btw. Sorry about the inconvenience.)

All models are also attached as archives to the v1.6 release ‚Äö√Ñ√∂‚àö√ë‚àö¬® so in the meantime, you can always download them manually from there, unzip the archive and place the contained folder in spacy/data.

If you don't have to use v1.3, I'd also recommend checking out the newer versions and upgrading to spaCy v1.7+. Models are now hosted on GitHub, which makes the downloading process more transparent and doesn't rely on a separate download server. They're also wrapped as native Python packages, which lets you install them via pip, add them to your project's requirements.txt and even import them as a module at the top of your file. You can read more about this in the models documentation.

This makes it easier to manage model dependencies, especially as more models become available. If you're using spaCy 1.8+, you'll be able to use models for English, German, French and Spanish. If you have trained your own models and decide to upgrade, note that you will have to retrain your models with the input from the new version. Models trained on spaCy <v1.7 are not compatible with v1.7+.",solution provided,The responder provides a solution by offering a manual download of models while they work on fixing the download server issue.,,1,C20230706015008376076,0.535480738,0.627251327,0.513488054,0.492495716,0.706551254,0.441121131,0.587508917,0.612893403,0.706689417,0.68130827,0.755752087,0.824818254,0.418373704,0.605717778,0.455950499,0.422601938,0.602627575,0.434489638,0.576345921,0.406245023,0.610667944,0.795378149,0.881325305,0.827124476,51solution provided
272,80,Spacy,Feature,Lemmatization,Lemmatization feature,60638828,SpaCy use Lemmatizer as stand-alone component,"I want to use SpaCy's lemmatizer as a standalone component (because I have pre-tokenized text, and I don't want to re-concatenate it and run the full pipeline because SpaCy will most likely tokenize differently in some cases).

I found the lemmatizer in the package but I somehow needs to load the dictionaries with the rules to initialize this Lemmatizer. These files must be somewhere in the model of the English or German model, right? I couldn't find them there.

from spacy.lemmatizer import Lemmatizer
where do the LEMMA_INDEX, etc. files are comming from?
lemmatizer = Lemmatizer(LEMMA_INDEX, LEMMA_EXC, LEMMA_RULES)
I found a similar question here: Spacy lemmatizer issue/consistency but this one did not entirely answer how to get these dictionary files from the model. The spacy.lang.* parameter seems to no longer exist in newer versions.","Here's an extracted bit of code I had, that used the SpaCy lemmatizer by itself. I'm not somewhere I can run it so it might have a small bug or two if I made an editing mistake.

Note that in general, you need to know the upos for the word in order to lemmatize correctly. This code will return all the possible lemmas but I would advise modifying it to pass in the correct upos for your word.

class SpacyLemmatizer(object):
    def __init__(self, smodel):
        import spacy
        self.lemmatizer = spacy.load(smodel).vocab.morphology.lemmatizer

    # get the lemmas for every upos
    def getLemmas(self, entry):
        possible_lemmas = set()
        for upos in ('NOUN', 'VERB', 'ADJ', 'ADV'):
            lemmas = self.lemmatizer(entry, upos, morphology=None)
            lemma = lemmas[0]    # See morphology.pyx::lemmatize
            possible_lemmas.add( lemma )
        return possible_lemmas",getting lemmas for every upos,The lemmatizer object is used to get the lemmas for every upos in the SpacyLemmatizer class.,,1,C20230706015134444194,0.7552073,0.673714459,0.610305309,0.739941299,0.828478217,0.781882346,0.748600721,0.790431261,0.688382626,0.844387531,0.752601326,0.739401698,0.404943079,0.710218251,0.537799776,0.523009241,0.615355551,0.704284668,0.626817524,0.777361035,0.57269311,0.695692897,0.855070114,0.684048891,80getting lemmas for every upos
154,44,Spacy,Stability,backwards,Stability aspect,52598788,spaCy: custom attributes not matching correctly?,"I have been having problems using custom extension attributes with the recently improved Matcher (spaCy 2.012). Even a simple example (mostly copied from here) is not working as I expected:
In other words, the rule correctly matches on the span 'have' (1, 2), but incorrectly matches 'have' (5, 6) and 'had' (6, 7). Furthermore, the callback function is not called. The custom attribute appears to be ignored.
The first rule functions as above. Then the second rule triggers, along with the callback function (which prints the message). There is an additional correct match for the new pattern along with the correct and erroneous matches from the first rule.

So, I have a few questions:

why does pattern1 match incorrectly? (i.e. why does the _ custom attribute constraint not apply?)
why does the callback function not work on the first call?
why does it work upon addition of a new rule?
In my own code, when using custom attributes as constraints in subsequent patterns, these patterns match on ALL tokens. I assume this is related to the behaviour exhibited by the code above.","Sorry if this was confusing ‚Äö√Ñ√∂‚àö√ë‚àö¬® but the GitHub thread you're referring to is still only the spec and proposal, i.e. the planned implementation. The changes will hopefully ship with spaCy v2.1.0 (since some of the changes to the Matcher internals are not fully backwards compatible).

While the custom attribute matching isn't implemented yet, the basic improvements to the Matcher engine are already available on the develop branch and in the alpha version via spacy-nightly (pip install spacy-nightly). Those updates likely also resolve the inconsistent behaviour you observed with the callback function.",custom attribute not implemented,"Based on the conversation, it seems that the custom attribute matching feature in spaCy is still in the planning and development stage, and is not currently implemented.",,1,C20230706014955136282,0.68743813,0.659358561,0.540607572,0.723512769,0.489837229,0.512124479,0.759751618,0.771590948,0.846524954,0.591545463,0.806030691,0.778089464,0.764189661,0.602770984,0.552445889,0.889172614,0.486728787,0.466575503,0.66450274,0.739772499,0.632110238,0.797950208,0.708440721,0.840728641,44custom attribute not implemented
65,19,Spacy,Performance,performance,Performance aspect,58724562,When creating a Doc using the standard constructor the model is not loaded ,"I'm trying to use SpaCY and instantiate the Doc object using the constructor:
but when I do that, if I try to use the dependency parser:
I get the error:

ValueError: [E029] noun_chunks requires the dependency parse, which requires a statistical model to be installed and loaded. For more info, see the documentation:
While if I use the method nlp(""Hello world!"") that does not happens.

The reason I do that, is because I use the entity extraction from a third party application I want to supply to SpaCy my tokenisation and my entities.
What should I do? load the pipeline by myself in the document, and exclude the tokeniser for example?","nlp() returns a Doc where the tokenizer and all the pipeline components in nlp.pipeline have been applied to the document.

If you create a Doc by hand, the tokenizer and the pipeline components are not loaded or applied at any point.

After creating a Doc by hand, you can still apply individual pipeline components from a loaded model:

nlp = spacy.load('en_core_web_sm')
nlp.tagger(doc)
nlp.parser(doc)
Then you can add your own entities to the document. (Note that if your tokenizer is very different from the default tokenizer used when training a model, the performance may not be as good.)",nlp() applies tokenizer and pipeline components,"When using the nlp() method to instantiate a Doc object in Spacy, the tokenizer and all pipeline components in nlp.pipeline are loaded and applied to the document, resulting in optimal performance and error-free use of functions like the dependency parser.",,1,C20230706014828758730,0.711925447,0.805332422,0.737808168,0.859677792,0.562631965,0.60371232,0.86815089,0.838988781,0.726640761,0.854123533,0.597034335,0.731274843,0.642317712,0.744631827,0.731112301,0.733151495,0.646236241,0.623129547,0.663484514,0.681852043,0.640493691,0.560397923,0.865429461,0.575206757,19nlp() applies tokenizer and pipeline components
102,29,Spacy,Performance,fast,Performance aspect,69738938,How to use existing huggingface-transformers model into spacy?,"I'm here to ask you guys if it is possible to use an existing trained huggingface-transformers model with spacy.

My first naive attempt was to load it via spacy.load('bert-base-uncased'), it didn't work because spacy demands a certain structure, which is understandable.

Now I'm trying to figure out how to use the spacy-transformers library to load the model, create the spacy structure, and use it from that point as a normal spacy-aware model.

I don't know if it is even possible as I couldn't find anything regarding the subject. I've tried to read the documentation but all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place? I can believe someone has to train everything again with spacy.
","What you do is add a Transformer component to your pipeline and give the name of your HuggingFace model as a parameter to that. This is covered in the docs, though people do have trouble finding it. It's important to understand that a Transformer is only one piece of a spaCy pipeline, and you should understand how it all fits together.

To pull from the docs, this is how you specify a custom model in a config:

[components.transformer.model]
@architectures = ""spacy-transformers.TransformerModel.v3""
# XXX You can change the model name here
name = ""bert-base-cased""
tokenizer_config = {""use_fast"": true}
Going back to why you need to understand spaCy's structure, it's very important to understand that in spaCy, Transformers are only sources of features. If your HuggingFace model has an NER head or something it will not work. So if you use a custom model, you'll need to train other components, like NER, on top of it.

Also note that spaCy has a variety of non-Transformers built-in models. These are very fast to train and in many situations will give performance comparable to Transformers; even if they aren't as accurate, you can use the built-in models to get your pipeline configured and then just swap in a Transformer.

all guides, examples, and posts I found, start from a spacy structured model like spacy/en_core_web_sm, but how did that model was created in the first place?",spacy's built-in models,Many situations may not require custom models and spaCy's built-in models are fast to train and can provide comparable performance. Using built-in models as a starting point and then swapping in a Transformer later is also an option.,,0,C20230706014923957819,0.752001405,0.601370335,0.530073941,0.54703784,0.596431315,0.757164419,0.406324089,0.640714705,0.397863299,0.68587172,0.791831136,0.698160052,0.543857694,0.379340619,0.371297538,0.434420854,0.533408999,0.545914352,0.456380874,0.445003062,0.473844737,0.808621883,0.675983846,0.742636919,29spacy's built-in models